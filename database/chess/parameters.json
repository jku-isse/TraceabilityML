[{"id":1, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":1, "methodname":"de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n * @param engine\r\n * \t\tThe current engine.\r\n * @param board\r\n * \t\tThe current board.\r\n * @param timer\r\n * \t\tThe game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}"},
 {"id":2, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":1, "methodname":"de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n * @param engine\r\n * \t\tThe current engine.\r\n * @param board\r\n * \t\tThe current board.\r\n * @param timer\r\n * \t\tThe game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}"},
 {"id":3, "parametername":"ChessEngine engine", "parametertype":"de.java_chess.javaChess.engine.ChessEngine", "parameterclass":23, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":1, "methodname":"de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n * @param engine\r\n * \t\tThe current engine.\r\n * @param board\r\n * \t\tThe current board.\r\n * @param timer\r\n * \t\tThe game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}"},
 {"id":4, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":1, "methodname":"de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n * @param engine\r\n * \t\tThe current engine.\r\n * @param board\r\n * \t\tThe current board.\r\n * @param timer\r\n * \t\tThe game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}"},
 {"id":5, "parametername":"GameTimer timer", "parametertype":"de.java_chess.javaChess.timer.GameTimer", "parameterclass":99, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":1, "methodname":"de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n * @param engine\r\n * \t\tThe current engine.\r\n * @param board\r\n * \t\tThe current board.\r\n * @param timer\r\n * \t\tThe game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}"},
 {"id":6, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":16, "methodname":"de.java_chess.javaChess.GameController.setGame(de.java_chess.javaChess.game.Game)", "isreturn":0, "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}"},
 {"id":7, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":17, "methodname":"de.java_chess.javaChess.GameController.setGameNotation(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"/**\r\n * Set the current game notation.\r\n *\r\n * @param gameNotation\r\n * \t\tThe new game notation.\r\n */\r\npublic final void setGameNotation(GameNotation gameNotation) {\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":8, "parametername":"ChessEngine engine", "parametertype":"de.java_chess.javaChess.engine.ChessEngine", "parameterclass":23, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":15, "methodname":"de.java_chess.javaChess.GameController.setEngine(de.java_chess.javaChess.engine.ChessEngine)", "isreturn":0, "sourcecode":"/**\r\n * Set a new chess engine.\r\n *\r\n * @param engine\r\n * \t\tThe new engine.\r\n */\r\nfinal void setEngine(ChessEngine engine) {\r\n    _engine = engine;\r\n}"},
 {"id":9, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":14, "methodname":"de.java_chess.javaChess.GameController.setBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nfinal void setBoard(Board board) {\r\n    _board = board;\r\n}"},
 {"id":10, "parametername":"ChessBoardRenderer renderer", "parametertype":"de.java_chess.javaChess.renderer.ChessBoardRenderer", "parameterclass":82, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":19, "methodname":"de.java_chess.javaChess.GameController.setRenderer(de.java_chess.javaChess.renderer.ChessBoardRenderer)", "isreturn":0, "sourcecode":"/**\r\n * Set a new renderer.\r\n *\r\n * @param renderer\r\n * \t\tThe new renderer.\r\n */\r\nfinal void setRenderer(ChessBoardRenderer renderer) {\r\n    _renderer = renderer;\r\n}"},
 {"id":11, "parametername":"GameTimer timer", "parametertype":"de.java_chess.javaChess.timer.GameTimer", "parameterclass":99, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":18, "methodname":"de.java_chess.javaChess.GameController.setGameTimer(de.java_chess.javaChess.timer.GameTimer)", "isreturn":0, "sourcecode":"/**\r\n * Set a new game timer.\r\n *\r\n * @param timer\r\n * \t\tThe new game timer.\r\n */\r\nfinal void setGameTimer(GameTimer timer) {\r\n    _gameTimer = timer;\r\n    timer.addActionListener(this);\r\n}"},
 {"id":12, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":23, "methodname":"de.java_chess.javaChess.GameController.userPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * The user moved a piece.\r\n *\r\n * @param ply\r\n * \t\tThe ply of the user.\r\n */\r\npublic final void userPly(Ply ply) {\r\n    // Before any user ply can be applied, we have to stop\r\n    // the permanent brain, so the engine is free to process\r\n    // the user ply.\r\n    getEngine().stopPermanentBrain();\r\n    // plyInterpretation\r\n    ply = convertUserPly(ply);\r\n    // Check if the user has the right to move a piece\r\n    // and made a valid move.\r\n    if ((_moveRight) != (_computerIsWhite)) {\r\n        if ((((_gameState) != (GameState.CHECKMATE)) && ((_gameState) != (GameState.DRAW))) && ((_gameState) != (GameState.TIMEOUT))) {\r\n            if (getEngine().validateUserPly(ply)) {\r\n                doPly(ply);// Ok => move the piece.\r\n\r\n            } else {\r\n                // The user had to right to move or made an invalid move.\r\n                signalUserInputError(\"invalid move\");\r\n            }\r\n        } else {\r\n            signalUserInputError(\"game is already over\");\r\n        }\r\n    } else {\r\n        signalUserInputError(\"user is not about to move\");\r\n    }\r\n}"},
 {"id":13, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":4, "methodname":"de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}"},
 {"id":14, "parametername":"de.java_chess.javaChess.ply.Ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":4, "methodname":"de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}"},
 {"id":15, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":5, "methodname":"de.java_chess.javaChess.GameController.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to do.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    // If the game is over, stop here.\r\n    if ((_gameState) == (GameState.TIMEOUT)) {\r\n        return;\r\n    }\r\n    // Store the ply notation to set the check flags a bit later, since they are computed in the gameOver()\r\n    // call in the move right toggle.\r\n    PlyNotation plyNotation = new PlyNotationImpl(ply, getBoard().getPiece(ply.getSource()));\r\n    getGame().doPly(ply);\r\n    getBoard().doPly(ply);\r\n    getRenderer().doPly(ply);\r\n    // Now try to get some info on the current game state.\r\n    boolean gameOver = gameOver((!(_moveRight)));\r\n    // Set check info for this ply.\r\n    if ((_gameState) == (GameState.CHECKMATE)) {\r\n        plyNotation.setCheckMate(true);\r\n    } else {\r\n        if ((_gameState) == (GameState.CHECK)) {\r\n            plyNotation.setCheck(true);\r\n        }\r\n    }\r\n    // Add the ply to the notation.\r\n    getGameNotation().addPly(plyNotation);\r\n    if (gameOver) {\r\n        getGameTimer().stop();// The game has ended.\r\n\r\n        if ((_gameState) == (GameState.DRAW)) {\r\n            signalGameOver(\"Draw! Use File -> Reset to play again!\");\r\n        } else {\r\n            signalGameOver(((_moveRight) == (_computerIsWhite) ? \"Checkmate! I win! :-)\" : \"Checkmate! I lose... :-(\"));\r\n        }\r\n    } else {\r\n        toggleMoveRight();\r\n    }\r\n}"},
 {"id":16, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":6, "methodname":"de.java_chess.javaChess.GameController.gameOver(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Check if the game is over.\r\n *\r\n * @param white\r\n * \t\tTrue, if white is about to move.\r\n * @return true, if the game is over.\r\n */\r\nprivate final boolean gameOver(boolean white) {\r\n    _gameState = getEngine().getCurrentGameState(white);\r\n    return ((_gameState) == (GameState.CHECKMATE)) || ((_gameState) == (GameState.DRAW));\r\n}"},
 {"id":17, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":2, "methodname":"de.java_chess.javaChess.GameController.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * Process a event, that we are listening to.\r\n *\r\n * @param event\r\n * \t\tThe event.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    System.out.println((\"Got event \" + (event.getActionCommand())));\r\n    // If the timer fired the event, check for timeout.\r\n    if ((event.getSource()) == (getGameTimer())) {\r\n        String command = event.getActionCommand();\r\n        if (\"timeout white\".equals(command)) {\r\n            _gameState = GameState.TIMEOUT;\r\n            signalGameOver(\"Timeout for you! I win!\");\r\n        }\r\n        if (\"timeout black\".equals(command)) {\r\n            System.out.println(\"Black timeout!\");\r\n            _gameState = GameState.TIMEOUT;\r\n            signalGameOver(\"Timeout for me! You win!\");\r\n        }\r\n    }\r\n}"},
 {"id":18, "parametername":"String errorMessage", "parametertype":"java.lang.String", "parameterclass":0, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":21, "methodname":"de.java_chess.javaChess.GameController.signalUserInputError(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Signal a input error to the user.\r\n *\r\n * @param errorMessage\r\n * \t\tMore information on the error.\r\n */\r\npublic final void signalUserInputError(String errorMessage) {\r\n    System.out.print(((char) (7)));\r\n    JOptionPane.showMessageDialog(null, errorMessage, \"Error\", JOptionPane.ERROR_MESSAGE);\r\n}"},
 {"id":19, "parametername":"String gameOverMessage", "parametertype":"java.lang.String", "parameterclass":0, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":20, "methodname":"de.java_chess.javaChess.GameController.signalGameOver(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Signal the end if the game.\r\n *\r\n * @param gameOverMessage\r\n * \t\tSome info how and why the game has ended.\r\n */\r\npublic final void signalGameOver(String gameOverMessage) {\r\n    System.out.print(((char) (7)));\r\n    JOptionPane.showMessageDialog(null, gameOverMessage, \"Game over\", JOptionPane.INFORMATION_MESSAGE);\r\n}"},
 {"id":20, "parametername":"String[] args", "parametertype":"java.lang.String[]", "parameterclass":0, "classid":3, "classname":"de.java_chess.javaChess.JavaChess", "methodid":31, "methodname":"de.java_chess.javaChess.JavaChess.main(java.lang.String[])", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * The main method.\r\n *\r\n * @param args\r\n * \t\tThe commandline arguments.\r\n */\r\npublic static void main(String[] args) {\r\n    JavaChess._instance = new JavaChess();\r\n}"},
 {"id":21, "parametername":"JavaChessAction action", "parametertype":"de.java_chess.javaChess.action.JavaChessAction", "parameterclass":6, "classid":3, "classname":"de.java_chess.javaChess.JavaChess", "methodid":29, "methodname":"de.java_chess.javaChess.JavaChess.getMenuItem(de.java_chess.javaChess.action.JavaChessAction)", "isreturn":0, "sourcecode":"/**\r\n * Create a return a menu item for a given action.\r\n *\r\n * @param action\r\n * \t\tThe action.\r\n * @return The menu item for this action.\r\n */\r\nprivate JMenuItem getMenuItem(JavaChessAction action) {\r\n    JMenuItem item = new JMenuItem(action.getName());\r\n    item.addActionListener(action);\r\n    return item;\r\n}"},
 {"id":22, "parametername":"Dimension screenSize", "parametertype":"java.awt.Dimension", "parameterclass":0, "classid":3, "classname":"de.java_chess.javaChess.JavaChess", "methodid":33, "methodname":"de.java_chess.javaChess.JavaChess.placeFrame(java.awt.Dimension,java.awt.Dimension)", "isreturn":0, "sourcecode":"private void placeFrame(Dimension screenSize, Dimension frameSize) {\r\n    setLocation((((screenSize.width) - (frameSize.width)) / 2), (((screenSize.height) - (frameSize.height)) / 2));\r\n}"},
 {"id":23, "parametername":"Dimension frameSize", "parametertype":"java.awt.Dimension", "parameterclass":0, "classid":3, "classname":"de.java_chess.javaChess.JavaChess", "methodid":33, "methodname":"de.java_chess.javaChess.JavaChess.placeFrame(java.awt.Dimension,java.awt.Dimension)", "isreturn":0, "sourcecode":"private void placeFrame(Dimension screenSize, Dimension frameSize) {\r\n    setLocation((((screenSize.width) - (frameSize.width)) / 2), (((screenSize.height) - (frameSize.height)) / 2));\r\n}"},
 {"id":24, "parametername":"Dimension screenSize", "parametertype":"java.awt.Dimension", "parameterclass":0, "classid":3, "classname":"de.java_chess.javaChess.JavaChess", "methodid":36, "methodname":"de.java_chess.javaChess.JavaChess.setFrameSize(java.awt.Dimension,java.awt.Dimension)", "isreturn":0, "sourcecode":"private void setFrameSize(Dimension screenSize, Dimension frameSize) {\r\n    if ((frameSize.height) > (screenSize.height)) {\r\n        frameSize.height = screenSize.height;\r\n    }\r\n    if ((frameSize.width) > (screenSize.width)) {\r\n        frameSize.width = screenSize.width;\r\n    }\r\n}"},
 {"id":25, "parametername":"Dimension frameSize", "parametertype":"java.awt.Dimension", "parameterclass":0, "classid":3, "classname":"de.java_chess.javaChess.JavaChess", "methodid":36, "methodname":"de.java_chess.javaChess.JavaChess.setFrameSize(java.awt.Dimension,java.awt.Dimension)", "isreturn":0, "sourcecode":"private void setFrameSize(Dimension screenSize, Dimension frameSize) {\r\n    if ((frameSize.height) > (screenSize.height)) {\r\n        frameSize.height = screenSize.height;\r\n    }\r\n    if ((frameSize.width) > (screenSize.width)) {\r\n        frameSize.width = screenSize.width;\r\n    }\r\n}"},
 {"id":26, "parametername":"WindowEvent e", "parametertype":"java.awt.event.WindowEvent", "parameterclass":0, "classid":3, "classname":"de.java_chess.javaChess.JavaChess", "methodid":37, "methodname":"de.java_chess.javaChess.JavaChess.this_windowClosing(java.awt.event.WindowEvent)", "isreturn":0, "sourcecode":"/**\r\n * If Java-Chess is closed over the X and not via File-Exit, a process\r\n * would be still running\r\n *\r\n * @param e\r\n * \t\tThe Window event\r\n */\r\nvoid this_windowClosing(WindowEvent e) {\r\n    System.exit(0);\r\n}"},
 {"id":27, "parametername":"ChessEngineImpl engine", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":3, "classname":"de.java_chess.javaChess.JavaChess", "methodid":26, "methodname":"de.java_chess.javaChess.JavaChess.engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)", "isreturn":0, "sourcecode":"public void engineStatusChanged(ChessEngineImpl engine) {\r\n    if ((this.jpStatus) != null) {\r\n        this.jpStatus.setActionText(engine.getStatusDisplayString());\r\n    }\r\n}"},
 {"id":28, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":4, "classname":"de.java_chess.javaChess.action.AboutAction", "methodid":39, "methodname":"de.java_chess.javaChess.action.AboutAction.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * \t\tThe event, that triggered the action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    DialogAbout dialog = DialogAbout.getInstance();\r\n    if (dialog != null) {\r\n        Tools.setDialogToCenter(dialog);\r\n        dialog.show();\r\n    }\r\n}"},
 {"id":29, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":5, "classname":"de.java_chess.javaChess.action.HelpAction", "methodid":41, "methodname":"de.java_chess.javaChess.action.HelpAction.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * The action action.\r\n *\r\n * @param event\r\n * \t\tThe event, that triggered the action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Just a dummy so far...\r\n}"},
 {"id":30, "parametername":"String name", "parametertype":"java.lang.String", "parameterclass":0, "classid":6, "classname":"de.java_chess.javaChess.action.JavaChessAction", "methodid":42, "methodname":"de.java_chess.javaChess.action.JavaChessAction.-init-(java.lang.String)", "isreturn":0, "sourcecode":"// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new Java-Chess action.\r\n *\r\n * @param name\r\n * \t\tThe name of the action.\r\n */\r\npublic JavaChessAction(String name) {\r\n    super(name);\r\n    putValue(Action.SHORT_DESCRIPTION, name);\r\n}"},
 {"id":31, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":7, "classname":"de.java_chess.javaChess.action.LoadGameAction", "methodid":46, "methodname":"de.java_chess.javaChess.action.LoadGameAction.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * \t\tThe event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Missing: save current project?\r\n    JFileChooser chooser = new JFileChooser();\r\n    chooser.setDialogTitle(\"Load pgn file\");\r\n    chooser.setFileFilter(SaveGameAsAction.getPGNFileFilter());\r\n    int retval = chooser.showOpenDialog(null);\r\n    if (retval == (JFileChooser.APPROVE_OPTION)) {\r\n        File file = chooser.getSelectedFile();\r\n        try {\r\n            PGNFile pgnFile = new PGNFile(new BufferedReader(new FileReader(file)));\r\n            GameNotation notation = pgnFile.readGame();\r\n        } catch (FileNotFoundException fe) {\r\n            JOptionPane.showMessageDialog(null, ((\"File \" + (file.getName())) + \" not found!\"), \"File not found\", JOptionPane.ERROR_MESSAGE);\r\n        } catch (RecognitionException re) {\r\n        } catch (TokenStreamException te) {\r\n        }\r\n    }\r\n}"},
 {"id":32, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":8, "classname":"de.java_chess.javaChess.action.ResetGameAction", "methodid":48, "methodname":"de.java_chess.javaChess.action.ResetGameAction.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * \t\tThe event, that caused the action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    JavaChess.getInstance().reset();\r\n}"},
 {"id":33, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":9, "classname":"de.java_chess.javaChess.action.SaveGameAction", "methodid":49, "methodname":"de.java_chess.javaChess.action.SaveGameAction.-init-(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param gameNotation\r\n * \t\tThe game notation.\r\n */\r\npublic SaveGameAction(GameNotation gameNotation) {\r\n    super(\"Save game\");\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":34, "parametername":"String name", "parametertype":"java.lang.String", "parameterclass":0, "classid":9, "classname":"de.java_chess.javaChess.action.SaveGameAction", "methodid":50, "methodname":"de.java_chess.javaChess.action.SaveGameAction.-init-(java.lang.String,de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"/**\r\n * Create a new action instance.\r\n *\r\n * @param name\r\n * \t\tThe name of the action.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n */\r\nSaveGameAction(String name, GameNotation gameNotation) {\r\n    super(\"Save Game as...\");\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":35, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":9, "classname":"de.java_chess.javaChess.action.SaveGameAction", "methodid":50, "methodname":"de.java_chess.javaChess.action.SaveGameAction.-init-(java.lang.String,de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"/**\r\n * Create a new action instance.\r\n *\r\n * @param name\r\n * \t\tThe name of the action.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n */\r\nSaveGameAction(String name, GameNotation gameNotation) {\r\n    super(\"Save Game as...\");\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":36, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":9, "classname":"de.java_chess.javaChess.action.SaveGameAction", "methodid":51, "methodname":"de.java_chess.javaChess.action.SaveGameAction.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * \t\tThe event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n}"},
 {"id":37, "parametername":"File file", "parametertype":"java.io.File", "parameterclass":0, "classid":9, "classname":"de.java_chess.javaChess.action.SaveGameAction", "methodid":52, "methodname":"de.java_chess.javaChess.action.SaveGameAction.trySave(java.io.File)", "isreturn":0, "sourcecode":"/**\r\n * Try to save the game into the given file.\r\n *\r\n * @param file\r\n * \t\tThe file to write into.\r\n */\r\npublic void trySave(File file) {\r\n    try {\r\n        PGNOutputStream PGNOutput = new PGNOutputStream(file);\r\n        // Write the notation of the game.\r\n        PGNOutput.write(_gameNotation);\r\n    } catch (IOException exception) {\r\n        JOptionPane.showMessageDialog(null, (\"Error while writing file: \" + (file.getName())), \"Error\", JOptionPane.ERROR_MESSAGE);\r\n    }\r\n}"},
 {"id":38, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":10, "classname":"de.java_chess.javaChess.action.SaveGameAsAction", "methodid":53, "methodname":"de.java_chess.javaChess.action.SaveGameAsAction.-init-(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n */\r\npublic SaveGameAsAction(GameNotation gameNotation) {\r\n    super(\"Save game as...\", gameNotation);\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":39, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":10, "classname":"de.java_chess.javaChess.action.SaveGameAsAction", "methodid":54, "methodname":"de.java_chess.javaChess.action.SaveGameAsAction.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * \t\tThe event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Create a new filechooser\r\n    JFileChooser chooser = new JFileChooser();\r\n    chooser.setDialogTitle(\"Saving game as pgn file\");\r\n    chooser.setFileFilter(SaveGameAsAction.getPGNFileFilter());\r\n    int retval = chooser.showSaveDialog(null);\r\n    if (retval == (JFileChooser.APPROVE_OPTION)) {\r\n        trySave(chooser.getSelectedFile());\r\n    }\r\n}"},
 {"id":40, "parametername":"int pieceTypeColor", "parametertype":"int", "parameterclass":0, "classid":11, "classname":"de.java_chess.javaChess.bitboard.BitBoard", "methodid":59, "methodname":"de.java_chess.javaChess.bitboard.BitBoard.getPositionOfPieces(int)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Get the position of some pieces as a long (64 bit wide) bitmask.\r\n *\r\n * @param pieceTypeColor\r\n * \t\tThe color and type of the pieces.\r\n * @return A bitmask with the positions of these pieces.\r\n */\r\nlong getPositionOfPieces(int pieceTypeColor);"},
 {"id":41, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":11, "classname":"de.java_chess.javaChess.bitboard.BitBoard", "methodid":56, "methodname":"de.java_chess.javaChess.bitboard.BitBoard.getAllPiecesForColor(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get all white or black pieces.\r\n *\r\n * @param white\r\n * \t\ttrue, if the white pieces are requested,\r\n * \t\tfalse for the black pieces.\r\n */\r\nlong getAllPiecesForColor(boolean white);"},
 {"id":42, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":68, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getPiece(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Get the piece of a given position, or null of the square is empty.\r\n *\r\n * @param position\r\n * \t\tThe position of the piece.\r\n * @return The piece of the square or null, of the square is empty.\r\n */\r\npublic final Piece getPiece(Position position) {\r\n    int bitpos = position.getSquareIndex();\r\n    int pieceType = ((((int) ((_boardLayer[1]) >> bitpos)) & 1) | ((((int) ((_boardLayer[2]) >> bitpos)) & 1) << 1)) | ((((int) ((_boardLayer[3]) >> bitpos)) & 1) << 2);\r\n    return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))));\r\n}"},
 {"id":43, "parametername":"de.java_chess.javaChess.piece.Piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":68, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getPiece(de.java_chess.javaChess.position.Position)", "isreturn":1, "sourcecode":"/**\r\n * Get the piece of a given position, or null of the square is empty.\r\n *\r\n * @param position\r\n * \t\tThe position of the piece.\r\n * @return The piece of the square or null, of the square is empty.\r\n */\r\npublic final Piece getPiece(Position position) {\r\n    int bitpos = position.getSquareIndex();\r\n    int pieceType = ((((int) ((_boardLayer[1]) >> bitpos)) & 1) | ((((int) ((_boardLayer[2]) >> bitpos)) & 1) << 1)) | ((((int) ((_boardLayer[3]) >> bitpos)) & 1) << 2);\r\n    return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))));\r\n}"},
 {"id":44, "parametername":"Piece piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":71, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set a piece on a given square.\r\n *\r\n * @param piece\r\n * \t\tThe piece to set, or null to empty the square.\r\n * @param position\r\n * \t\tThe position of the square.\r\n */\r\npublic final void setPiece(Piece piece, Position position) {\r\n    byte pieceCodeColor = (piece == null) ? 0 : piece.getTypeAndColor();\r\n    long bitmask = 1L << (position.getSquareIndex());\r\n    long bitFilter = ~bitmask;\r\n    for (int i = 0; i < 4; i++) {\r\n        if ((pieceCodeColor & 1) != 0) {\r\n            _boardLayer[i] |= bitmask;// Set this bit to 1.\r\n\r\n        } else {\r\n            _boardLayer[i] &= bitFilter;// Set this bit to 0.\r\n\r\n        }\r\n        pieceCodeColor >>= 1;\r\n    }\r\n}"},
 {"id":45, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":71, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set a piece on a given square.\r\n *\r\n * @param piece\r\n * \t\tThe piece to set, or null to empty the square.\r\n * @param position\r\n * \t\tThe position of the square.\r\n */\r\npublic final void setPiece(Piece piece, Position position) {\r\n    byte pieceCodeColor = (piece == null) ? 0 : piece.getTypeAndColor();\r\n    long bitmask = 1L << (position.getSquareIndex());\r\n    long bitFilter = ~bitmask;\r\n    for (int i = 0; i < 4; i++) {\r\n        if ((pieceCodeColor & 1) != 0) {\r\n            _boardLayer[i] |= bitmask;// Set this bit to 1.\r\n\r\n        } else {\r\n            _boardLayer[i] &= bitFilter;// Set this bit to 0.\r\n\r\n        }\r\n        pieceCodeColor >>= 1;\r\n    }\r\n}"},
 {"id":46, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":62, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Move a piece from one square to another.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    Piece movedPiece = getPiece(ply.getSource());\r\n    // Check, if it was a castling\r\n    if (ply instanceof CastlingPly) {\r\n        int offset = (movedPiece.isWhite()) ? 0 : 56;\r\n        if (((CastlingPly) (ply)).isLeftCastling()) {\r\n            setPiece(movedPiece, new PositionImpl((2 + offset)));\r\n            // Move the rook to the right\r\n            doPly(new PlyImpl(new PositionImpl((0 + offset)), new PositionImpl((3 + offset)), false));\r\n        } else {\r\n            setPiece(movedPiece, new PositionImpl((6 + offset)));\r\n            // Move the rook to the left\r\n            doPly(new PlyImpl(new PositionImpl((7 + offset)), new PositionImpl((5 + offset)), false));\r\n        }\r\n    } else {\r\n        // If a pawn has just reached the last row\r\n        if (ply instanceof TransformationPly) {\r\n            // Set a piece of the new type on the destination square.\r\n            setPiece(new PieceImpl(((TransformationPly) (ply)).getTypeAfterTransformation(), movedPiece.getColor()), ply.getDestination());\r\n        } else {\r\n            // Copy the piece from source square to destination square.\r\n            setPiece(movedPiece, ply.getDestination());\r\n            // If its a en passant ply, remove the attacked pawn.\r\n            if (ply instanceof EnPassantPly) {\r\n                setPiece(null, ((EnPassantPly) (ply)).getAttackedPosition());\r\n            }\r\n        }\r\n    }\r\n    // Empty the source square.\r\n    setPiece(null, ply.getSource());\r\n}"},
 {"id":47, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":65, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\npublic final Board getBoardAfterPly(Ply ply) {\r\n    BitBoard newBoard = ((BitBoard) (clone()));\r\n    newBoard.doPly(ply);\r\n    return newBoard;\r\n}"},
 {"id":48, "parametername":"de.java_chess.javaChess.board.Board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":65, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\npublic final Board getBoardAfterPly(Ply ply) {\r\n    BitBoard newBoard = ((BitBoard) (clone()));\r\n    newBoard.doPly(ply);\r\n    return newBoard;\r\n}"},
 {"id":49, "parametername":"int pieceTypeColor", "parametertype":"int", "parameterclass":0, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":69, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getPositionOfPieces(int)", "isreturn":0, "sourcecode":"/**\r\n * Get the positions of some pieces as a long (64 bit wide) bitmask.\r\n *\r\n * @param pieceTypeColor\r\n * \t\tThe color and type of the pieces.\r\n */\r\npublic final long getPositionOfPieces(int pieceTypeColor) {\r\n    return ((((pieceTypeColor & 1) != 0 ? _boardLayer[0] : ~(_boardLayer[0])) & ((pieceTypeColor & 2) != 0 ? _boardLayer[1] : ~(_boardLayer[1]))) & ((pieceTypeColor & 4) != 0 ? _boardLayer[2] : ~(_boardLayer[2]))) & ((pieceTypeColor & 8) != 0 ? _boardLayer[3] : ~(_boardLayer[3]));\r\n}"},
 {"id":50, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":64, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getAllPiecesForColor(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get all white or black pieces.\r\n *\r\n * @param white\r\n * \t\ttrue, if the white pieces are requested,\r\n * \t\tfalse for the black pieces.\r\n */\r\npublic final long getAllPiecesForColor(boolean white) {\r\n    return (((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3])) & (white ? _boardLayer[0] : ~(_boardLayer[0]));\r\n}"},
 {"id":51, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":76, "methodname":"de.java_chess.javaChess.board.Board.getPiece(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Get the piece of a given position.\r\n *\r\n * @param position\r\n * \t\tThe position of the piece.\r\n * @return The piece on that position, or null if the\r\nsquare is empty.\r\n */\r\nPiece getPiece(Position position);"},
 {"id":52, "parametername":"de.java_chess.javaChess.piece.Piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":76, "methodname":"de.java_chess.javaChess.board.Board.getPiece(de.java_chess.javaChess.position.Position)", "isreturn":1, "sourcecode":"/**\r\n * Get the piece of a given position.\r\n *\r\n * @param position\r\n * \t\tThe position of the piece.\r\n * @return The piece on that position, or null if the\r\nsquare is empty.\r\n */\r\nPiece getPiece(Position position);"},
 {"id":53, "parametername":"Piece piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":78, "methodname":"de.java_chess.javaChess.board.Board.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set a piece on a given position.\r\n *\r\n * @param piece\r\n * \t\tThe piece to set.\r\n * @param position\r\n * \t\tThe position to set the piece on.\r\n */\r\nvoid setPiece(Piece piece, Position position);"},
 {"id":54, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":78, "methodname":"de.java_chess.javaChess.board.Board.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set a piece on a given position.\r\n *\r\n * @param piece\r\n * \t\tThe piece to set.\r\n * @param position\r\n * \t\tThe position to set the piece on.\r\n */\r\nvoid setPiece(Piece piece, Position position);"},
 {"id":55, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":73, "methodname":"de.java_chess.javaChess.board.Board.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Move a piece from one square to another.\r\n *\r\n * @param ply\r\n * \t\tThe move to perform.\r\n */\r\nvoid doPly(Ply ply);"},
 {"id":56, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":75, "methodname":"de.java_chess.javaChess.board.Board.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\nBoard getBoardAfterPly(Ply ply);"},
 {"id":57, "parametername":"de.java_chess.javaChess.board.Board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":13, "classname":"de.java_chess.javaChess.board.Board", "methodid":75, "methodname":"de.java_chess.javaChess.board.Board.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\nBoard getBoardAfterPly(Ply ply);"},
 {"id":58, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":14, "classname":"de.java_chess.javaChess.dialogs.DialogAbout", "methodid":81, "methodname":"de.java_chess.javaChess.dialogs.DialogAbout.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"public void actionPerformed(ActionEvent event) {\r\n    this.setVisible(false);\r\n}"},
 {"id":59, "parametername":"KeyEvent e", "parametertype":"java.awt.event.KeyEvent", "parameterclass":0, "classid":14, "classname":"de.java_chess.javaChess.dialogs.DialogAbout", "methodid":80, "methodname":"de.java_chess.javaChess.dialogs.DialogAbout.CloseButton_keyReleased(java.awt.event.KeyEvent)", "isreturn":0, "sourcecode":"void CloseButton_keyReleased(KeyEvent e) {\r\n    if ((e.getKeyCode()) == (KeyEvent.VK_ENTER))\r\n        this.hide();\r\n\r\n}"},
 {"id":60, "parametername":"JTextArea textArea", "parametertype":"javax.swing.JTextArea", "parameterclass":0, "classid":14, "classname":"de.java_chess.javaChess.dialogs.DialogAbout", "methodid":85, "methodname":"de.java_chess.javaChess.dialogs.DialogAbout.setRegister(javax.swing.JTextArea,java.io.Reader)", "isreturn":0, "sourcecode":"void setRegister(JTextArea textArea, Reader in) {\r\n    try {\r\n        char[] buffer = new char[4096];\r\n        int len;\r\n        textArea.setText(\"\");\r\n        while ((len = in.read(buffer)) != (-1)) {\r\n            String s = new String(buffer, 0, len);\r\n            textArea.append(s);\r\n        } \r\n        textArea.setCaretPosition(0);\r\n    } catch (IOException e) {\r\n        textArea.setText((((e.getClass().getName()) + \": \") + (e.getMessage())));\r\n    }\r\n}"},
 {"id":61, "parametername":"Reader in", "parametertype":"java.io.Reader", "parameterclass":0, "classid":14, "classname":"de.java_chess.javaChess.dialogs.DialogAbout", "methodid":85, "methodname":"de.java_chess.javaChess.dialogs.DialogAbout.setRegister(javax.swing.JTextArea,java.io.Reader)", "isreturn":0, "sourcecode":"void setRegister(JTextArea textArea, Reader in) {\r\n    try {\r\n        char[] buffer = new char[4096];\r\n        int len;\r\n        textArea.setText(\"\");\r\n        while ((len = in.read(buffer)) != (-1)) {\r\n            String s = new String(buffer, 0, len);\r\n            textArea.append(s);\r\n        } \r\n        textArea.setCaretPosition(0);\r\n    } catch (IOException e) {\r\n        textArea.setText((((e.getClass().getName()) + \": \") + (e.getMessage())));\r\n    }\r\n}"},
 {"id":62, "parametername":"String resourceName", "parametertype":"java.lang.String", "parameterclass":0, "classid":14, "classname":"de.java_chess.javaChess.dialogs.DialogAbout", "methodid":82, "methodname":"de.java_chess.javaChess.dialogs.DialogAbout.getDialogResource(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Get a dialog resource as a reader.\r\n *\r\n * @param resourceName\r\n * \t\tThe name of the resource.\r\n * @return A reader to read from.\r\n */\r\nprivate final Reader getDialogResource(String resourceName) {\r\n    try {\r\n        // Create a URL into the jar.\r\n        URL resourceURL = new URL((\"jar:file:javaChess.jar!/de/java_chess/javaChess/dialogs/resources/\" + resourceName));\r\n        return new BufferedReader(new InputStreamReader(resourceURL.openStream()));\r\n    } catch (IOException ie) {\r\n        // Ugly! But the same behaviour than before...\r\n        return new StringReader(ie.getMessage());\r\n    }\r\n}"},
 {"id":63, "parametername":"DialogAbout adaptee", "parametertype":"de.java_chess.javaChess.dialogs.DialogAbout", "parameterclass":14, "classid":15, "classname":"de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter", "methodid":86, "methodname":"de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter.-init-(de.java_chess.javaChess.dialogs.DialogAbout)", "isreturn":0, "sourcecode":"DialogAbout_CloseButton_keyAdapter(DialogAbout adaptee) {\r\n    this.adaptee = adaptee;\r\n}"},
 {"id":64, "parametername":"KeyEvent e", "parametertype":"java.awt.event.KeyEvent", "parameterclass":0, "classid":15, "classname":"de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter", "methodid":87, "methodname":"de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter.keyReleased(java.awt.event.KeyEvent)", "isreturn":0, "sourcecode":"public void keyReleased(KeyEvent e) {\r\n    adaptee.CloseButton_keyReleased(e);\r\n}"},
 {"id":65, "parametername":"SetupBoardDialog dialog", "parametertype":"de.java_chess.javaChess.dialogs.SetupBoardDialog", "parameterclass":18, "classid":16, "classname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel", "methodid":96, "methodname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.setCallingDialog(de.java_chess.javaChess.dialogs.SetupBoardDialog)", "isreturn":0, "sourcecode":"public void setCallingDialog(SetupBoardDialog dialog) {\r\n    this.setupBoardDialog = dialog;\r\n}"},
 {"id":66, "parametername":"ActionEvent e", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":16, "classname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel", "methodid":89, "methodname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"public void actionPerformed(ActionEvent e) {\r\n    for (byte col = 0; col <= 1; col++) {\r\n        for (byte type = 1; type <= 6; type++) {\r\n            if ((_pieceButton[col][type]) == (e.getSource())) {\r\n                this.setType(type);\r\n                this.setColor(col);\r\n                this.jlSelectedPieceImage.setIcon(_pieceIcon[col][type]);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}"},
 {"id":67, "parametername":"byte type", "parametertype":"byte", "parameterclass":0, "classid":16, "classname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel", "methodid":98, "methodname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.setType(byte)", "isreturn":0, "sourcecode":"/**\r\n * Set the type of this piece.\r\n *\r\n * @param type\r\n * \t\tThe type of this piece as defined as\r\n * \t\tconstants in the Piece interface.\r\n */\r\npublic void setType(byte type) {\r\n    pieceColor &= ((byte) (1));\r\n    pieceColor |= type << 1;\r\n}"},
 {"id":68, "parametername":"byte color", "parametertype":"byte", "parameterclass":0, "classid":16, "classname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel", "methodid":97, "methodname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.setColor(byte)", "isreturn":0, "sourcecode":"/**\r\n * Set the color of this piece.\r\n *\r\n * @param The\r\n * \t\tnew color of this piece.\r\n */\r\npublic void setColor(byte color) {\r\n    pieceColor &= ((byte) (14));\r\n    pieceColor |= color;\r\n}"},
 {"id":69, "parametername":"int iWhiteBlack", "parametertype":"int", "parameterclass":0, "classid":17, "classname":"de.java_chess.javaChess.dialogs.PlayerDialog", "methodid":100, "methodname":"de.java_chess.javaChess.dialogs.PlayerDialog.-init-(int,java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n *\r\n *\r\n * @param iWhiteBlack\r\n * \t\t1 = edit white players name\r\n * @param currentString\r\n * \t\tThe string which already is displayed above the notation panel\r\n */\r\npublic PlayerDialog(int iWhiteBlack, String currentString) {\r\n    this.iWhite = iWhiteBlack;\r\n    this.sCurrentString = currentString;\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":70, "parametername":"String currentString", "parametertype":"java.lang.String", "parameterclass":0, "classid":17, "classname":"de.java_chess.javaChess.dialogs.PlayerDialog", "methodid":100, "methodname":"de.java_chess.javaChess.dialogs.PlayerDialog.-init-(int,java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n *\r\n *\r\n * @param iWhiteBlack\r\n * \t\t1 = edit white players name\r\n * @param currentString\r\n * \t\tThe string which already is displayed above the notation panel\r\n */\r\npublic PlayerDialog(int iWhiteBlack, String currentString) {\r\n    this.iWhite = iWhiteBlack;\r\n    this.sCurrentString = currentString;\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":71, "parametername":"ActionEvent e", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":17, "classname":"de.java_chess.javaChess.dialogs.PlayerDialog", "methodid":101, "methodname":"de.java_chess.javaChess.dialogs.PlayerDialog.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * Interface method; handles the mouse click on the OK-button\r\n *\r\n * @param e\r\n * \t\tThe action event\r\n */\r\npublic void actionPerformed(ActionEvent e) {\r\n    if (e.getSource().equals(jbOK)) {\r\n        this.hide();\r\n    }\r\n}"},
 {"id":72, "parametername":"WindowEvent e", "parametertype":"java.awt.event.WindowEvent", "parameterclass":0, "classid":18, "classname":"de.java_chess.javaChess.dialogs.SetupBoardDialog", "methodid":112, "methodname":"de.java_chess.javaChess.dialogs.SetupBoardDialog.this_windowClosing(java.awt.event.WindowEvent)", "isreturn":0, "sourcecode":"/**\r\n * If this dialog is closed over the X and not via File-Exit, a process\r\n * would be still running\r\n *\r\n * @param e\r\n * \t\tThe Window event\r\n */\r\nprivate void this_windowClosing(WindowEvent e) {\r\n    System.exit(0);\r\n}"},
 {"id":73, "parametername":"ActionEvent e", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":18, "classname":"de.java_chess.javaChess.dialogs.SetupBoardDialog", "methodid":105, "methodname":"de.java_chess.javaChess.dialogs.SetupBoardDialog.jbCancel_actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * Button Cancel pressed\r\n *\r\n * @param e\r\n * \t\tThe event\r\n */\r\nprivate void jbCancel_actionPerformed(ActionEvent e) {\r\n    this.dispose();\r\n}"},
 {"id":74, "parametername":"ActionEvent e", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":18, "classname":"de.java_chess.javaChess.dialogs.SetupBoardDialog", "methodid":108, "methodname":"de.java_chess.javaChess.dialogs.SetupBoardDialog.jbOk_actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * Button Ok pressed\r\n *\r\n * @param e\r\n * \t\tThe event\r\n */\r\nprivate void jbOk_actionPerformed(ActionEvent e) {\r\n    this.hide();\r\n}"},
 {"id":75, "parametername":"MouseEvent e", "parametertype":"java.awt.event.MouseEvent", "parameterclass":0, "classid":18, "classname":"de.java_chess.javaChess.dialogs.SetupBoardDialog", "methodid":110, "methodname":"de.java_chess.javaChess.dialogs.SetupBoardDialog.jpBoard_mouseEntered(java.awt.event.MouseEvent)", "isreturn":0, "sourcecode":"/**\r\n * Mouse cursor entered the board: Use piece as mouse pointer over the board\r\n *\r\n * @param e\r\n * \t\tThe event\r\n */\r\nvoid jpBoard_mouseEntered(MouseEvent e) {\r\n    Image imageCursor;\r\n    oldCursor = this.getCursor();\r\n    // byte typeAndColor = ((Piece)jpPieces).getTypeAndColor();\r\n    // URL url = getClass().getResource(\"BP.gif\");\r\n    // Image image = Toolkit.getDefaultToolkit().getImage( url );\r\n    // Cursor myCursor = Toolkit.getDefaultToolkit().createCustomCursor(((Piece)jpPieces).getSelectedPieceImage(), new Point(20, 20), \"Piece\");\r\n    imageCursor = ((PieceSelectionPanel) (jpPieces)).getSelectedPieceImage();\r\n    ((PieceSelectionPanel) (jpPieces)).initializeSelectedIconLabel();\r\n    if (imageCursor != null) {\r\n        Cursor myCursor = Toolkit.getDefaultToolkit().createCustomCursor(imageCursor, new Point(20, 20), \"Piece\");\r\n        jpBoard.setCursor(myCursor);\r\n    }\r\n}"},
 {"id":76, "parametername":"MouseEvent e", "parametertype":"java.awt.event.MouseEvent", "parameterclass":0, "classid":18, "classname":"de.java_chess.javaChess.dialogs.SetupBoardDialog", "methodid":111, "methodname":"de.java_chess.javaChess.dialogs.SetupBoardDialog.jpBoard_mouseExited(java.awt.event.MouseEvent)", "isreturn":0, "sourcecode":"/**\r\n * Mouse cursor left the board: Use normal mouse pointer again\r\n *\r\n * @param e\r\n * \t\tThe event\r\n */\r\nvoid jpBoard_mouseExited(MouseEvent e) {\r\n    jpBoard.setCursor(oldCursor);\r\n}"},
 {"id":77, "parametername":"ActionEvent e", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":18, "classname":"de.java_chess.javaChess.dialogs.SetupBoardDialog", "methodid":106, "methodname":"de.java_chess.javaChess.dialogs.SetupBoardDialog.jbClearBoard_actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * Button Clear board pressed; self-explaining\r\n *\r\n * @param e\r\n * \t\tThe event\r\n */\r\nvoid jbClearBoard_actionPerformed(ActionEvent e) {\r\n    this.boardRenderer.clearBoard();\r\n}"},
 {"id":78, "parametername":"ActionEvent e", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":18, "classname":"de.java_chess.javaChess.dialogs.SetupBoardDialog", "methodid":109, "methodname":"de.java_chess.javaChess.dialogs.SetupBoardDialog.jbStartPosition_actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * Button Start position pressed; self-explaining\r\n *\r\n * @param e\r\n * \t\tThe event\r\n */\r\nvoid jbStartPosition_actionPerformed(ActionEvent e) {\r\n    bitBoard.initialPosition();\r\n    this.boardRenderer.reset();\r\n    this.validate();\r\n}"},
 {"id":79, "parametername":"JFrame parent", "parametertype":"javax.swing.JFrame", "parameterclass":0, "classid":19, "classname":"de.java_chess.javaChess.dialogs.TransformationDialog", "methodid":113, "methodname":"de.java_chess.javaChess.dialogs.TransformationDialog.-init-(javax.swing.JFrame,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new transformation dialog.\r\n *\r\n * @param parent\r\n * \t\tThe parent frame.\r\n * @param modal\r\n * \t\tFlag, if the dialog is modal.\r\n */\r\nprivate TransformationDialog(JFrame parent, boolean modal) {\r\n    super(parent, modal);\r\n    _pieceType = Piece.QUEEN;// Set the piece type to the default value.\r\n\r\n    setTitle(\"Chose a piece type\");// Set the title of the dialog.\r\n\r\n    // Set a new layout with bigger gaps.\r\n    getContentPane().setLayout(new BorderLayout(16, 16));\r\n    // Add a panel with the options.\r\n    JPanel choserPanel = new JPanel();\r\n    choserPanel.setLayout(new GridLayout(4, 1));\r\n    // Create a group for the piece types to handle the selection\r\n    // of the radio buttons.\r\n    ButtonGroup buttonGroup = new ButtonGroup();\r\n    // Add the buttons for piece types\r\n    _queenButton = new JRadioButton(\"Queen\");\r\n    _queenButton.setSelected(true);\r\n    // Queen is the default choice.\r\n    buttonGroup.add(_queenButton);\r\n    _queenButton.addActionListener(this);\r\n    choserPanel.add(_queenButton);\r\n    _rookButton = new JRadioButton(\"Rook\");\r\n    buttonGroup.add(_rookButton);\r\n    _rookButton.addActionListener(this);\r\n    choserPanel.add(_rookButton);\r\n    _knightButton = new JRadioButton(\"Knight\");\r\n    buttonGroup.add(_knightButton);\r\n    _knightButton.addActionListener(this);\r\n    choserPanel.add(_knightButton);\r\n    _bishopButton = new JRadioButton(\"Bishop\");\r\n    buttonGroup.add(_bishopButton);\r\n    _bishopButton.addActionListener(this);\r\n    choserPanel.add(_bishopButton);\r\n    getContentPane().add(choserPanel, BorderLayout.CENTER);\r\n    // Add a button to hide the dialog.\r\n    _okButton = new JButton(\"Ok\");\r\n    _okButton.addActionListener(this);\r\n    getContentPane().add(_okButton, BorderLayout.SOUTH);\r\n    pack();\r\n    // Get the screen size and place the dialog in the middle of the screen.\r\n    Dimension size = getSize();\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    setLocation((((screenSize.width) / 2) - ((size.width) / 2)), (((screenSize.height) / 2) - ((size.height) / 2)));\r\n}"},
 {"id":80, "parametername":"boolean modal", "parametertype":"boolean", "parameterclass":0, "classid":19, "classname":"de.java_chess.javaChess.dialogs.TransformationDialog", "methodid":113, "methodname":"de.java_chess.javaChess.dialogs.TransformationDialog.-init-(javax.swing.JFrame,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new transformation dialog.\r\n *\r\n * @param parent\r\n * \t\tThe parent frame.\r\n * @param modal\r\n * \t\tFlag, if the dialog is modal.\r\n */\r\nprivate TransformationDialog(JFrame parent, boolean modal) {\r\n    super(parent, modal);\r\n    _pieceType = Piece.QUEEN;// Set the piece type to the default value.\r\n\r\n    setTitle(\"Chose a piece type\");// Set the title of the dialog.\r\n\r\n    // Set a new layout with bigger gaps.\r\n    getContentPane().setLayout(new BorderLayout(16, 16));\r\n    // Add a panel with the options.\r\n    JPanel choserPanel = new JPanel();\r\n    choserPanel.setLayout(new GridLayout(4, 1));\r\n    // Create a group for the piece types to handle the selection\r\n    // of the radio buttons.\r\n    ButtonGroup buttonGroup = new ButtonGroup();\r\n    // Add the buttons for piece types\r\n    _queenButton = new JRadioButton(\"Queen\");\r\n    _queenButton.setSelected(true);\r\n    // Queen is the default choice.\r\n    buttonGroup.add(_queenButton);\r\n    _queenButton.addActionListener(this);\r\n    choserPanel.add(_queenButton);\r\n    _rookButton = new JRadioButton(\"Rook\");\r\n    buttonGroup.add(_rookButton);\r\n    _rookButton.addActionListener(this);\r\n    choserPanel.add(_rookButton);\r\n    _knightButton = new JRadioButton(\"Knight\");\r\n    buttonGroup.add(_knightButton);\r\n    _knightButton.addActionListener(this);\r\n    choserPanel.add(_knightButton);\r\n    _bishopButton = new JRadioButton(\"Bishop\");\r\n    buttonGroup.add(_bishopButton);\r\n    _bishopButton.addActionListener(this);\r\n    choserPanel.add(_bishopButton);\r\n    getContentPane().add(choserPanel, BorderLayout.CENTER);\r\n    // Add a button to hide the dialog.\r\n    _okButton = new JButton(\"Ok\");\r\n    _okButton.addActionListener(this);\r\n    getContentPane().add(_okButton, BorderLayout.SOUTH);\r\n    pack();\r\n    // Get the screen size and place the dialog in the middle of the screen.\r\n    Dimension size = getSize();\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    setLocation((((screenSize.width) / 2) - ((size.width) / 2)), (((screenSize.height) / 2) - ((size.height) / 2)));\r\n}"},
 {"id":81, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":19, "classname":"de.java_chess.javaChess.dialogs.TransformationDialog", "methodid":114, "methodname":"de.java_chess.javaChess.dialogs.TransformationDialog.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * A method to handle action events coming from the dialog.\r\n *\r\n * @param event\r\n * \t\tThe event that triggered this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Get the source of the event.\r\n    Object eventSource = event.getSource();\r\n    // If the user closed the dialog.\r\n    if (eventSource == (_okButton)) {\r\n        setVisible(false);\r\n        return;\r\n    }\r\n    // Check for the radio buttons.\r\n    if (eventSource == (_queenButton)) {\r\n        _pieceType = Piece.QUEEN;\r\n    } else\r\n        if (eventSource == (_rookButton)) {\r\n            _pieceType = Piece.ROOK;\r\n        } else\r\n            if (eventSource == (_knightButton)) {\r\n                _pieceType = Piece.KNIGHT;\r\n            } else\r\n                if (eventSource == (_bishopButton)) {\r\n                    _pieceType = Piece.BISHOP;\r\n                }\r\n\r\n\r\n\r\n}"},
 {"id":82, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":20, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "methodid":122, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzer.setBoard(de.java_chess.javaChess.bitboard.BitBoard)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board to be analyzed.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nvoid setBoard(BitBoard board);"},
 {"id":83, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":20, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "methodid":123, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzer.setMoveRight(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the flag, if white is about to move.\r\n *\r\n * @param white\r\n * \t\tFlag to indicate, if white has the\r\n * \t\tnext move.\r\n */\r\nvoid setMoveRight(boolean white);"},
 {"id":84, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":20, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "methodid":120, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzer.isInCheck(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Test if a king is in check.\r\n *\r\n * @param white\r\n * \t\ttrue, if the white king is checked, false otherwise.\r\n */\r\nboolean isInCheck(boolean white);"},
 {"id":85, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":20, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "methodid":121, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzer.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * \t\tThe board to test.\r\n * @param white\r\n * \t\ttrue, if the white king is checked, false otherwise.\r\n */\r\nboolean isInCheck(BitBoard board, boolean white);"},
 {"id":86, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":20, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "methodid":121, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzer.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * \t\tThe board to test.\r\n * @param white\r\n * \t\ttrue, if the white king is checked, false otherwise.\r\n */\r\nboolean isInCheck(BitBoard board, boolean white);"},
 {"id":87, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":20, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "methodid":118, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzer.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board to analyze.\r\n * @param white\r\n * \t\tFlag to indicate, if white has the next move.\r\n */\r\nshort analyze(BitBoard board, boolean white);"},
 {"id":88, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":20, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "methodid":118, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzer.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board to analyze.\r\n * @param white\r\n * \t\tFlag to indicate, if white has the next move.\r\n */\r\nshort analyze(BitBoard board, boolean white);"},
 {"id":89, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":124, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.PlyGenerator)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new bitboard analyzer.\r\n *\r\n * @param plyGenerator\r\n * \t\tA PlyGenerator instance to simulate moves.\r\n */\r\npublic BitBoardAnalyzerImpl(Game game, PlyGenerator plyGenerator) {\r\n    setGame(game);\r\n    setPlyGenerator(plyGenerator);\r\n}"},
 {"id":90, "parametername":"PlyGenerator plyGenerator", "parametertype":"de.java_chess.javaChess.engine.PlyGenerator", "parameterclass":25, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":124, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.PlyGenerator)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new bitboard analyzer.\r\n *\r\n * @param plyGenerator\r\n * \t\tA PlyGenerator instance to simulate moves.\r\n */\r\npublic BitBoardAnalyzerImpl(Game game, PlyGenerator plyGenerator) {\r\n    setGame(game);\r\n    setPlyGenerator(plyGenerator);\r\n}"},
 {"id":91, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":132, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setBoard(de.java_chess.javaChess.bitboard.BitBoard)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board to be analyzed.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\npublic final void setBoard(BitBoard board) {\r\n    _board = board;\r\n}"},
 {"id":92, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":133, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setGame(de.java_chess.javaChess.game.Game)", "isreturn":0, "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}"},
 {"id":93, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":134, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setMoveRight(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the flag, if white is about to move.\r\n *\r\n * @param white\r\n * \t\tFlag to indicate, if white has the\r\n * \t\tnext move.\r\n */\r\npublic final void setMoveRight(boolean white) {\r\n    _whiteMoves = white;\r\n}"},
 {"id":94, "parametername":"PlyGenerator plyGenerator", "parametertype":"de.java_chess.javaChess.engine.PlyGenerator", "parameterclass":25, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":135, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setPlyGenerator(de.java_chess.javaChess.engine.PlyGenerator)", "isreturn":0, "sourcecode":"/**\r\n * Set a new PlyGenerator instance.\r\n *\r\n * @param plyGenerator\r\n * \t\tThe new PlyGenerator instance.\r\n */\r\nprivate final void setPlyGenerator(PlyGenerator plyGenerator) {\r\n    _plyGenerator = plyGenerator;\r\n}"},
 {"id":95, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":130, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * \t\tFlag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}"},
 {"id":96, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":131, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * \t\tThe board to test.\r\n * @param white\r\n * \t\ttrue, if the white king is checked, false otherwise.\r\n */\r\npublic final boolean isInCheck(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return isInCheck(white);\r\n}"},
 {"id":97, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":131, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * \t\tThe board to test.\r\n * @param white\r\n * \t\ttrue, if the white king is checked, false otherwise.\r\n */\r\npublic final boolean isInCheck(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return isInCheck(white);\r\n}"},
 {"id":98, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":126, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board to analyze.\r\n * @param white\r\n * \t\tFlag to indicate, if white has the next move.\r\n */\r\npublic final short analyze(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    setMoveRight(white);\r\n    return analyze();\r\n}"},
 {"id":99, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":126, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board to analyze.\r\n * @param white\r\n * \t\tFlag to indicate, if white has the next move.\r\n */\r\npublic final short analyze(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    setMoveRight(white);\r\n    return analyze();\r\n}"},
 {"id":100, "parametername":"long bitmask", "parametertype":"long", "parameterclass":0, "classid":22, "classname":"de.java_chess.javaChess.engine.BitUtils", "methodid":138, "methodname":"de.java_chess.javaChess.engine.BitUtils.getHighestBit(long)", "isreturn":0, "sourcecode":"/**\r\n * Find the index of highest set bit in a long bitmask.\r\n *\r\n * @param bitmask\r\n * \t\tThe bitmask to operate on.\r\n * @return The index of the highest set bit or 0, if no bits are set.\r\n */\r\npublic static final int getHighestBit(long bitmask) {\r\n    int highestBit = 0;\r\n    // The following 3 statements split the 64 bit word down to\r\n    // a byte.\r\n    int dwordPart = ((int) (bitmask >>> 32));\r\n    if (dwordPart != 0) {\r\n        highestBit += 32;\r\n    } else {\r\n        dwordPart = ((int) (bitmask));\r\n    }\r\n    int wordPart = (dwordPart >>> 16) & 65535;\r\n    if (wordPart != 0) {\r\n        highestBit += 16;\r\n    } else {\r\n        wordPart = dwordPart & 65535;\r\n    }\r\n    int bytePart = (wordPart >>> 8) & 255;\r\n    if (bytePart != 0) {\r\n        highestBit += 8;\r\n    } else {\r\n        bytePart = wordPart & 255;\r\n    }\r\n    // Use the byte as a index for a precomputed array\r\n    // of bit indexes.\r\n    return highestBit + (BitUtils._highestBit[bytePart]);\r\n}"},
 {"id":101, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":23, "classname":"de.java_chess.javaChess.engine.ChessEngine", "methodid":148, "methodname":"de.java_chess.javaChess.engine.ChessEngine.setGame(de.java_chess.javaChess.game.Game)", "isreturn":0, "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\nvoid setGame(Game game);"},
 {"id":102, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":23, "classname":"de.java_chess.javaChess.engine.ChessEngine", "methodid":147, "methodname":"de.java_chess.javaChess.engine.ChessEngine.setBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Set the board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nvoid setBoard(Board board);"},
 {"id":103, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":23, "classname":"de.java_chess.javaChess.engine.ChessEngine", "methodid":149, "methodname":"de.java_chess.javaChess.engine.ChessEngine.setWhite(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the color of the engine.\r\n *\r\n * @param white\r\n * \t\tflag to indicate if the engine operates on the white pieces.\r\n */\r\nvoid setWhite(boolean white);"},
 {"id":104, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":23, "classname":"de.java_chess.javaChess.engine.ChessEngine", "methodid":152, "methodname":"de.java_chess.javaChess.engine.ChessEngine.validateUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\nboolean validateUserPly(Ply ply);"},
 {"id":105, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":23, "classname":"de.java_chess.javaChess.engine.ChessEngine", "methodid":141, "methodname":"de.java_chess.javaChess.engine.ChessEngine.getCurrentGameState(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the current game state for a given color.\r\n *\r\n * @param white\r\n * \t\tTrue, if the state of the white player is requested.\r\n * @return The current game state.\r\n */\r\nbyte getCurrentGameState(boolean white);"},
 {"id":106, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":153, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param notation\r\n * \t\tThe current notation.\r\n * @param board\r\n * \t\tThe new board.\r\n * @param white\r\n * \t\tFlag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}"},
 {"id":107, "parametername":"GameNotation notation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":153, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param notation\r\n * \t\tThe current notation.\r\n * @param board\r\n * \t\tThe new board.\r\n * @param white\r\n * \t\tFlag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}"},
 {"id":108, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":153, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param notation\r\n * \t\tThe current notation.\r\n * @param board\r\n * \t\tThe new board.\r\n * @param white\r\n * \t\tFlag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}"},
 {"id":109, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":153, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param notation\r\n * \t\tThe current notation.\r\n * @param board\r\n * \t\tThe new board.\r\n * @param white\r\n * \t\tFlag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}"},
 {"id":110, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":188, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setGame(de.java_chess.javaChess.game.Game)", "isreturn":0, "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}"},
 {"id":111, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":186, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Set the board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\npublic void setBoard(Board board) {\r\n    _board = board;\r\n}"},
 {"id":112, "parametername":"PlyHashtable hashtable", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "parameterclass":26, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":189, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"/**\r\n * Set a new hashtable for this ply generator.\r\n *\r\n * @param hashtable\r\n * \t\tThe new hashtable for this ply generator.\r\n */\r\npublic final void setHashtable(PlyHashtable hashtable) {\r\n    _hashtable = hashtable;\r\n}"},
 {"id":113, "parametername":"PermanentBrain permanentBrain", "parametertype":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "parameterclass":34, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":193, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setPermanentBrain(de.java_chess.javaChess.engine.permanent_brain.PermanentBrain)", "isreturn":0, "sourcecode":"/**\r\n * Set a new permanent brain.\r\n *\r\n * @param permanentBrain\r\n * \t\tThe new permanent brain.\r\n */\r\nprivate final void setPermanentBrain(PermanentBrain permanentBrain) {\r\n    _permanentBrain = permanentBrain;\r\n}"},
 {"id":114, "parametername":"boolean active", "parametertype":"boolean", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":155, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.activatePermanentBrain(boolean)", "isreturn":0, "sourcecode":"/**\r\n * (De-)activate the permanent brain function.\r\n *\r\n * @param active\r\n * \t\tFlag to indicate, if the permanent brain function should be used.\r\n */\r\nprivate final void activatePermanentBrain(boolean active) {\r\n    _usePermanentBrain = active;\r\n    // Since the permanent brain is eventually active already, stop it now.\r\n    if (!(usePermanentBrain())) {\r\n        stopPermanentBrain();\r\n    }\r\n    // If the permanent brain is activated, it will be use for the next(!) move.\r\n}"},
 {"id":115, "parametername":"int time", "parametertype":"int", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":191, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setMaximumSearchTime(int)", "isreturn":0, "sourcecode":"/**\r\n * Set the maximum search time.\r\n *\r\n * @param depth\r\n * \t\tThe new search time.\r\n */\r\npublic final void setMaximumSearchTime(int time) {\r\n    _maxSearchTime = time;\r\n}"},
 {"id":116, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":197, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setWhite(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the color of the engine.\r\n *\r\n * @param white\r\n * \t\tflag to indicate if the engine operates on the white pieces.\r\n */\r\npublic void setWhite(boolean white) {\r\n    _white = white;\r\n}"},
 {"id":117, "parametername":"OpeningBook book", "parametertype":"de.java_chess.javaChess.engine.opening_book.OpeningBook", "parameterclass":31, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":192, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)", "isreturn":0, "sourcecode":"/**\r\n * Set a new opening book.\r\n *\r\n * @param book\r\n * \t\tThe new opening book.\r\n */\r\nprivate final void setOpeningBook(OpeningBook book) {\r\n    _openingBook = book;\r\n}"},
 {"id":118, "parametername":"boolean inBook", "parametertype":"boolean", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":190, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setInOpeningBook(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the flag to indicate, if we are still in the opening book.\r\n *\r\n * @param inBook\r\n * \t\ttrue, if we are still in the opening book. False otherwise.\r\n */\r\nprivate final void setInOpeningBook(boolean inBook) {\r\n    _inOpeningBook = inBook;\r\n}"},
 {"id":119, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":199, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * \t\tFlag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}"},
 {"id":120, "parametername":"de.java_chess.javaChess.ply.AnalyzedPly", "parametertype":"de.java_chess.javaChess.ply.AnalyzedPly", "parameterclass":69, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":199, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * \t\tFlag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}"},
 {"id":121, "parametername":"Ply lastPly", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":0, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":122, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":0, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":123, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":0, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":124, "parametername":"int searchLevel", "parametertype":"int", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":0, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":125, "parametername":"short alpha", "parametertype":"short", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":0, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":126, "parametername":"short beta", "parametertype":"short", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":0, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":127, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":158, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.analyzeBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Compute a score for a game position.\r\n *\r\n * @return A score for the current game position.\r\n */\r\npublic final short analyzeBoard(Board board) {\r\n    return _analyzer.analyze(((BitBoard) (board)), isWhite());\r\n}"},
 {"id":128, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":203, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.validateUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\npublic final boolean validateUserPly(Ply ply) {\r\n    // Get the user plies from the permanent brain, where they\r\n    // were hopefully already computed (if the PB is actually active).\r\n    Ply[] plies = getPermanentBrain().getUserPlies();\r\n    // If the permanent brain is not activated at the moment, remove the\r\n    // computed plies immediately, so they are recomputed for the next move!\r\n    if (!(usePermanentBrain())) {\r\n        getPermanentBrain().resetUserPlies();\r\n    }\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        if (plies[p].equals(ply)) {\r\n            // if the user ply equals this computed\r\n            // Perform this ply in the opening book\r\n            getOpeningBook().doUserPly(ply);\r\n            // Store the last user ply in a instance variable.\r\n            _lastUserPly = ply;\r\n            return true;// ply, it seems to be valid.\r\n\r\n        }\r\n    }\r\n    // The computer could not compute the ply, the user has made,\r\n    // so we assume, that it is not valid.\r\n    System.out.println((\"Invalid move \" + (ply.toString())));\r\n    System.out.println((\"Piecetype on source square \" + ((getBoard().getPiece(ply.getSource())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getSource()).getType()))));\r\n    System.out.println((\"Piecetype on destination square \" + ((getBoard().getPiece(ply.getDestination())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getDestination()).getType()))));\r\n    System.out.println(\"Valid moves are:\");\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        System.out.print(((plies[p].toString()) + \" \"));\r\n    }\r\n    System.out.println();\r\n    return false;\r\n}"},
 {"id":129, "parametername":"boolean stopFlag", "parametertype":"boolean", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":195, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setSearchStop(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the the stop flag for the search.\r\n *\r\n * @param stopFlag\r\n * \t\tThe flag to stop the search engine.\r\n */\r\npublic final void setSearchStop(boolean stopFlag) {\r\n    _stopSearch = stopFlag;\r\n}"},
 {"id":130, "parametername":"long analyzedBoards", "parametertype":"long", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":185, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setAnalyzedBoards(long)", "isreturn":0, "sourcecode":"/**\r\n * Set the number of analyzed boards.\r\n *\r\n * @param analyzedBoards\r\n * \t\tThe new number of analyzed boards.\r\n */\r\npublic final void setAnalyzedBoards(long analyzedBoards) {\r\n    _analyzedBoards = analyzedBoards;\r\n}"},
 {"id":131, "parametername":"int searchDepth", "parametertype":"int", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":194, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setSearchDepth(int)", "isreturn":0, "sourcecode":"/**\r\n * Set a new search depth.\r\n *\r\n * @param searchDepth\r\n * \t\tThe new search depth.\r\n */\r\npublic final void setSearchDepth(int searchDepth) {\r\n    _searchDepth = searchDepth;\r\n}"},
 {"id":132, "parametername":"ActionEvent actionEvent", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":154, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * Perform a action (could be a menu related action).\r\n *\r\n * @param actionEvent\r\n * \t\tThe event.\r\n */\r\npublic final void actionPerformed(ActionEvent actionEvent) {\r\n    // Check, if the user (de-)activated the permanent brain.\r\n    if (actionEvent.getSource().equals(_permanentBrainMenuItem)) {\r\n        activatePermanentBrain(_permanentBrainMenuItem.isSelected());\r\n        this.notifyListeners();\r\n        return;\r\n    }\r\n    // Check if the user has requested a new search time\r\n    for (int st = 0; st < (_searchTime.length); st++) {\r\n        if (actionEvent.getSource().equals(_avSearchTimeMenuItem[st])) {\r\n            setMaximumSearchTime(((_searchTime[st]) * 1000));\r\n            this.bFixedTime = false;\r\n        }\r\n        if (actionEvent.getSource().equals(_fixSearchTimeMenuItem[st])) {\r\n            setMaximumSearchTime(((_searchTime[st]) * 1000));\r\n            this.bFixedTime = true;\r\n        }\r\n    }\r\n    // Check, if the user has requested a different hashtable size.\r\n    for (int hts = 0; hts < (_hashtableSizes.length); hts++) {\r\n        if (actionEvent.getSource().equals(_hashtableSizeMenuItem[hts])) {\r\n            getHashtable().setMaximumSize(_hashtableSizes[hts]);\r\n        }\r\n    }\r\n    this.notifyListeners();\r\n}"},
 {"id":133, "parametername":"EnginePanel panel", "parametertype":"de.java_chess.javaChess.renderer2d.EnginePanel", "parameterclass":89, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":187, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setEnginePanel(de.java_chess.javaChess.renderer2d.EnginePanel)", "isreturn":0, "sourcecode":"/**\r\n * Sets the EnginePanel to be able to output in the panel and not only with\r\n * System.out.println(...)\r\n *\r\n * @param panel\r\n * \t\tThe EnginePanel to set\r\n */\r\npublic void setEnginePanel(EnginePanel panel) {\r\n    this._enginePanel = panel;\r\n}"},
 {"id":134, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":164, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getCurrentGameState(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the current game state.\r\n *\r\n * @param white\r\n * \t\tTrue, if the state of the white player is requested.\r\n * @return The current game state.\r\n */\r\npublic final byte getCurrentGameState(boolean white) {\r\n    // Test if the given player is in check.\r\n    boolean inCheck = _analyzer.isInCheck(((BitBoard) (getBoard())), white);\r\n    // Test if the player has valid plies available.\r\n    // The following computation of the available plies is not really efficient,\r\n    // since they are done anyway (either to compute the next computer ply or to\r\n    // check if a user ply is valid). So maybe the plygenerator or the engine should\r\n    // cache the computed plies.\r\n    boolean validPliesAvailable = (_plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white).length) > 0;\r\n    if (inCheck) {\r\n        return validPliesAvailable ? GameState.CHECK : GameState.CHECKMATE;\r\n    } else {\r\n        return validPliesAvailable ? GameState.ONGOING : GameState.DRAW;\r\n    }\r\n}"},
 {"id":135, "parametername":"StatusPanel myPanel", "parametertype":"de.java_chess.javaChess.renderer2d.StatusPanel", "parameterclass":96, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":196, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.setStatusPanel(de.java_chess.javaChess.renderer2d.StatusPanel)", "isreturn":0, "sourcecode":"public void setStatusPanel(StatusPanel myPanel) {\r\n    if ((this._statusPanel) != myPanel)\r\n        this._statusPanel = myPanel;\r\n\r\n}"},
 {"id":136, "parametername":"String text", "parametertype":"java.lang.String", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":157, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.addLogEntry(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Ads a log entry into the JavaChess logfile\r\n *\r\n * @param text\r\n * \t\tThe text to append\r\n */\r\nprivate void addLogEntry(String text) {\r\n    if ((f) != null) {\r\n        try {\r\n            // First read the existing lines into vBuffer\r\n            BufferedReader bfrIniFile = new BufferedReader(new FileReader(f));\r\n            String strOrgLine = bfrIniFile.readLine();\r\n            vBuffer = new Vector();\r\n            String strLine;\r\n            while (strOrgLine != null) {\r\n                strLine = strOrgLine.trim();\r\n                this.vBuffer.addElement(strLine);\r\n                strOrgLine = bfrIniFile.readLine();\r\n            } \r\n            // now create file new but with same filename\r\n            FileWriter fileWriter = new FileWriter(f);\r\n            PrintWriter printWriter = new PrintWriter(fileWriter);\r\n            // insert former existing text:\r\n            String[] strWrite = new String[vBuffer.size()];\r\n            vBuffer.copyInto(strWrite);\r\n            for (int i = 0; i < (vBuffer.size()); i++) {\r\n                printWriter.println(strWrite[i]);\r\n            }\r\n            // add the new text now:\r\n            printWriter.println(text);\r\n            printWriter.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}"},
 {"id":137, "parametername":"EngineStatusListener listener", "parametertype":"de.java_chess.javaChess.listener.EngineStatusListener", "parameterclass":53, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":156, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.addEngineStatusListener(de.java_chess.javaChess.listener.EngineStatusListener)", "isreturn":0, "sourcecode":"/**\r\n * Registers an object for notification.\r\n *\r\n * @param listener\r\n * \t\tThe object to be registered.\r\n */\r\npublic void addEngineStatusListener(EngineStatusListener listener) {\r\n    listeners.add(listener);\r\n}"},
 {"id":138, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":204, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of a ply generator.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param hashtable\r\n * \t\tA hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, PlyHashtable hashtable) {\r\n    setGame(game);\r\n    setHashtable(hashtable);\r\n    precomputeKnightPlies();\r\n    precomputeKingPlies();\r\n}"},
 {"id":139, "parametername":"PlyHashtable hashtable", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "parameterclass":26, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":204, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of a ply generator.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param hashtable\r\n * \t\tA hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, PlyHashtable hashtable) {\r\n    setGame(game);\r\n    setHashtable(hashtable);\r\n    precomputeKnightPlies();\r\n    precomputeKingPlies();\r\n}"},
 {"id":140, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":205, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param board\r\n * \t\tThe board to operate on.\r\n * @param hashtable\r\n * \t\tA hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}"},
 {"id":141, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":205, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param board\r\n * \t\tThe board to operate on.\r\n * @param hashtable\r\n * \t\tA hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}"},
 {"id":142, "parametername":"PlyHashtable hashtable", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "parameterclass":26, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":205, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param board\r\n * \t\tThe board to operate on.\r\n * @param hashtable\r\n * \t\tA hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}"},
 {"id":143, "parametername":"Game game", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":237, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.setGame(de.java_chess.javaChess.game.Game)", "isreturn":0, "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}"},
 {"id":144, "parametername":"PlyHashtable hashtable", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "parameterclass":26, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":238, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "isreturn":0, "sourcecode":"/**\r\n * Set a new hashtable for this ply generator.\r\n *\r\n * @param hashtable\r\n * \t\tThe new hashtable for this ply generator.\r\n */\r\npublic final void setHashtable(PlyHashtable hashtable) {\r\n    _hashtable = hashtable;\r\n}"},
 {"id":145, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":229, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the plies for a given board and color.\r\n * Passing the last ply is suboptimal, since its slower than\r\n * accessing the game history.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that lead to the given board.\r\n * @param board\r\n * \t\tThe board with the game position.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return getPliesForColor(white);\r\n}"},
 {"id":146, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":229, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the plies for a given board and color.\r\n * Passing the last ply is suboptimal, since its slower than\r\n * accessing the game history.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that lead to the given board.\r\n * @param board\r\n * \t\tThe board with the game position.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return getPliesForColor(white);\r\n}"},
 {"id":147, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":228, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the plies for a given game position and color.\r\n *\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(boolean white) {\r\n    resetPlies();\r\n    _white = white;// Store the color of the current player.\r\n\r\n    // Compute some bitmasks, so we dont have to compute them again for each piece type.\r\n    _emptySquares = getBoard().getEmptySquares();// Get the positions of the empty squares.\r\n\r\n    _attackablePieces = (getBoard().getAllPiecesForColor((!(_white)))) & (~(getBoard().getPositionOfPieces((((Piece.KING) << 1) | (_white ? 0 : 1)))));\r\n    // Add the possible plies for all piece types.\r\n    // I tried to sort this list according to the probality for a check, so\r\n    // the analyzer has a better chance to find it early.\r\n    addPliesForKnights();\r\n    addPliesForBishops();\r\n    addPliesForRooks();\r\n    addPliesForQueens();\r\n    addPliesForPawns();\r\n    addPliesForKing();\r\n    // Check, if theres a good ply for this board in the hash table.\r\n    Ply hashtablePly = getHashtable().getPly(getBoard(), _white);\r\n    if (hashtablePly != null) {\r\n        // If so, increase the score of this ply.\r\n        for (int index = 0; index < (_plyCounter); index++) {\r\n            if (_currentPlies[index].getPly().equals(hashtablePly)) {\r\n                _currentPlies[index].setScore(HASHTABLE_PLY);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // Presort the plies\r\n    presortPlies();\r\n    // Convert the plies to a array of the correct size\r\n    Ply[] plies = new Ply[_plyCounter];\r\n    int destIndex = 0;\r\n    for (int sourceIndex = (_plyCounter) - 1; sourceIndex >= 0;) {\r\n        plies[(destIndex++)] = _currentPlies[(sourceIndex--)].getPly();\r\n    }\r\n    return plies;\r\n}"},
 {"id":148, "parametername":"int square", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":208, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addPliesForBishopPos(int)", "isreturn":0, "sourcecode":"/**\r\n * Add the plies for a bishop position.\r\n *\r\n * @param square\r\n * \t\tThe square index of the bishop pos.\r\n */\r\nprivate final void addPliesForBishopPos(int square) {\r\n    int orgPos = square;// Save the original position.\r\n\r\n    int squareRow = square >> 3;\r\n    int squareLine = square & 7;\r\n    long bitmask;\r\n    if (squareRow > 0) {\r\n        // If we are not on row 1\r\n        if (squareLine < 7) {\r\n            // Compute plies to the lower right.\r\n            square -= 7;\r\n            bitmask = 1L << square;\r\n            while ((square >= 0) && ((square & 7) > 0)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square -= 7;\r\n                bitmask >>>= 7;\r\n            } \r\n        }\r\n        if (squareLine > 0) {\r\n            // Compute plies to the lower left.\r\n            square = orgPos - 9;\r\n            bitmask = 1L << square;\r\n            while ((square >= 0) && ((square & 7) != 7)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square -= 9;\r\n                bitmask >>>= 9;\r\n            } \r\n        }\r\n    }\r\n    if (squareRow < 7) {\r\n        if (squareLine > 0) {\r\n            // Compute plies to the upper left.\r\n            square = orgPos + 7;\r\n            bitmask = 1L << square;\r\n            while ((square < 64) && ((square & 7) != 7)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square += 7;\r\n                bitmask <<= 7;\r\n            } \r\n        }\r\n        if (squareLine < 7) {\r\n            // Compute plies to the upper right.\r\n            square = orgPos + 9;\r\n            bitmask = 1L << square;\r\n            while ((square < 64) && ((square & 7) > 0)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square += 9;\r\n                bitmask <<= 9;\r\n            } \r\n        }\r\n    }\r\n}"},
 {"id":149, "parametername":"int square", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":215, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addPliesForRookPos(int)", "isreturn":0, "sourcecode":"/**\r\n * Add the plies for one rook position.\r\n *\r\n * @param square\r\n * \t\tThe square index of the rook pos.\r\n */\r\nprivate final void addPliesForRookPos(int square) {\r\n    int orgPos = square;// Save the original position.\r\n\r\n    long bitmask;\r\n    // Compute plies to the left.\r\n    bitmask = 1L << square;\r\n    while ((square & 7) > 0) {\r\n        square -= 1;\r\n        bitmask >>>= 1;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n    // Compute plies downwards.\r\n    square = orgPos;\r\n    bitmask = 1L << square;\r\n    while (square > 8) {\r\n        square -= 8;\r\n        bitmask >>>= 8;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n    // Compute plies to the right.\r\n    square = orgPos;\r\n    bitmask = 1L << square;\r\n    while ((square & 7) < 7) {\r\n        square += 1;\r\n        bitmask <<= 1;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n    // Compute plies upwards.\r\n    square = orgPos;\r\n    bitmask = 1L << square;\r\n    while (square < 56) {\r\n        square += 8;\r\n        bitmask <<= 8;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n}"},
 {"id":150, "parametername":"int square", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":213, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addPliesForQueenPos(int)", "isreturn":0, "sourcecode":"/**\r\n * Add the plies for one queen position.\r\n *\r\n * @param square\r\n * \t\tThe square index of the queen position.\r\n */\r\nprivate final void addPliesForQueenPos(int square) {\r\n    // Since a queen can move like a bishop or rook,\r\n    // I simply add the plies of both for this position.\r\n    addPliesForBishopPos(square);\r\n    addPliesForRookPos(square);\r\n}"},
 {"id":151, "parametername":"long destinationPos", "parametertype":"long", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":220, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesUpward(long,int,int,int)", "isreturn":0, "sourcecode":"/**\r\n * Convert a bitmask to a series of relative plies.\r\n * We pass the destination fields here along with a offset to compute the source square.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesUpward(long destinationPos, int startBit, int endBit, int offset) {\r\n    // Compute a bitmask to mask the bits in the destination bitfield.\r\n    long bitmask = 1L << startBit;\r\n    // End the loop also if the bitmask is 0, so there are no more destination fields\r\n    // in the bitmask (so we dont have to check the entire chessboard for plies).\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        // If the bit of the destination square is set, its the destination for a ply.\r\n        if ((destinationPos & bitmask) != 0) {\r\n            // Add the ply to the buffer.\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // Remove the bit, so we can check if there are more plies to find.\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}"},
 {"id":152, "parametername":"int startBit", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":220, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesUpward(long,int,int,int)", "isreturn":0, "sourcecode":"/**\r\n * Convert a bitmask to a series of relative plies.\r\n * We pass the destination fields here along with a offset to compute the source square.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesUpward(long destinationPos, int startBit, int endBit, int offset) {\r\n    // Compute a bitmask to mask the bits in the destination bitfield.\r\n    long bitmask = 1L << startBit;\r\n    // End the loop also if the bitmask is 0, so there are no more destination fields\r\n    // in the bitmask (so we dont have to check the entire chessboard for plies).\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        // If the bit of the destination square is set, its the destination for a ply.\r\n        if ((destinationPos & bitmask) != 0) {\r\n            // Add the ply to the buffer.\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // Remove the bit, so we can check if there are more plies to find.\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}"},
 {"id":153, "parametername":"int endBit", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":220, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesUpward(long,int,int,int)", "isreturn":0, "sourcecode":"/**\r\n * Convert a bitmask to a series of relative plies.\r\n * We pass the destination fields here along with a offset to compute the source square.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesUpward(long destinationPos, int startBit, int endBit, int offset) {\r\n    // Compute a bitmask to mask the bits in the destination bitfield.\r\n    long bitmask = 1L << startBit;\r\n    // End the loop also if the bitmask is 0, so there are no more destination fields\r\n    // in the bitmask (so we dont have to check the entire chessboard for plies).\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        // If the bit of the destination square is set, its the destination for a ply.\r\n        if ((destinationPos & bitmask) != 0) {\r\n            // Add the ply to the buffer.\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // Remove the bit, so we can check if there are more plies to find.\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}"},
 {"id":154, "parametername":"int offset", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":220, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesUpward(long,int,int,int)", "isreturn":0, "sourcecode":"/**\r\n * Convert a bitmask to a series of relative plies.\r\n * We pass the destination fields here along with a offset to compute the source square.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesUpward(long destinationPos, int startBit, int endBit, int offset) {\r\n    // Compute a bitmask to mask the bits in the destination bitfield.\r\n    long bitmask = 1L << startBit;\r\n    // End the loop also if the bitmask is 0, so there are no more destination fields\r\n    // in the bitmask (so we dont have to check the entire chessboard for plies).\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        // If the bit of the destination square is set, its the destination for a ply.\r\n        if ((destinationPos & bitmask) != 0) {\r\n            // Add the ply to the buffer.\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // Remove the bit, so we can check if there are more plies to find.\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}"},
 {"id":155, "parametername":"long destinationPos", "parametertype":"long", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":219, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesDownward(long,int,int,int)", "isreturn":0, "sourcecode":"/**\r\n * Convert a bitmask to a series of relative plies.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesDownward(long destinationPos, int startBit, int endBit, int offset) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit >= endBit) && (destinationPos != 0); currentBit--) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask >>>= 1;\r\n    }\r\n}"},
 {"id":156, "parametername":"int startBit", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":219, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesDownward(long,int,int,int)", "isreturn":0, "sourcecode":"/**\r\n * Convert a bitmask to a series of relative plies.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesDownward(long destinationPos, int startBit, int endBit, int offset) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit >= endBit) && (destinationPos != 0); currentBit--) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask >>>= 1;\r\n    }\r\n}"},
 {"id":157, "parametername":"int endBit", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":219, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesDownward(long,int,int,int)", "isreturn":0, "sourcecode":"/**\r\n * Convert a bitmask to a series of relative plies.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesDownward(long destinationPos, int startBit, int endBit, int offset) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit >= endBit) && (destinationPos != 0); currentBit--) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask >>>= 1;\r\n    }\r\n}"},
 {"id":158, "parametername":"int offset", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":219, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesDownward(long,int,int,int)", "isreturn":0, "sourcecode":"/**\r\n * Convert a bitmask to a series of relative plies.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesDownward(long destinationPos, int startBit, int endBit, int offset) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit >= endBit) && (destinationPos != 0); currentBit--) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask >>>= 1;\r\n    }\r\n}"},
 {"id":159, "parametername":"long destinationPos", "parametertype":"long", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":206, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addAbsolutePlies(long,int,int,int)", "isreturn":0, "sourcecode":"/**\r\n * Convert a bitmask to a series of absolute plies.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint pos The source for each ply.\r\n */\r\nprivate final void addAbsolutePlies(long destinationPos, int startBit, int endBit, int pos) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(pos, currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}"},
 {"id":160, "parametername":"int startBit", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":206, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addAbsolutePlies(long,int,int,int)", "isreturn":0, "sourcecode":"/**\r\n * Convert a bitmask to a series of absolute plies.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint pos The source for each ply.\r\n */\r\nprivate final void addAbsolutePlies(long destinationPos, int startBit, int endBit, int pos) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(pos, currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}"},
 {"id":161, "parametername":"int endBit", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":206, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addAbsolutePlies(long,int,int,int)", "isreturn":0, "sourcecode":"/**\r\n * Convert a bitmask to a series of absolute plies.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint pos The source for each ply.\r\n */\r\nprivate final void addAbsolutePlies(long destinationPos, int startBit, int endBit, int pos) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(pos, currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}"},
 {"id":162, "parametername":"int pos", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":206, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addAbsolutePlies(long,int,int,int)", "isreturn":0, "sourcecode":"/**\r\n * Convert a bitmask to a series of absolute plies.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint pos The source for each ply.\r\n */\r\nprivate final void addAbsolutePlies(long destinationPos, int startBit, int endBit, int pos) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(pos, currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}"},
 {"id":163, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":236, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.setBoard(de.java_chess.javaChess.bitboard.BitBoard)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nfinal void setBoard(BitBoard board) {\r\n    _board = board;\r\n}"},
 {"id":164, "parametername":"BitBoardAnalyzer analyzer", "parametertype":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "parameterclass":20, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":235, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.setAnalyzer(de.java_chess.javaChess.engine.BitBoardAnalyzer)", "isreturn":0, "sourcecode":"/**\r\n * Set the last ply.\r\n *\r\n * @param lastPly\r\n * \t\tThe last ply.\r\n */\r\n/* final void setLastPly( Ply lastPly) {\n// _lastPly = lastPly;\n}\n */\r\n/**\r\n * Set a analyzer for check tests.\r\n *\r\n * @param analyzer\r\n * \t\tThe new analyzer to set.\r\n */\r\npublic final void setAnalyzer(BitBoardAnalyzer analyzer) {\r\n    _analyzer = analyzer;\r\n}"},
 {"id":165, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":217, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addPly(de.java_chess.javaChess.ply.Ply,short)", "isreturn":0, "sourcecode":"/**\r\n * Add a ply to the buffer, if the own king is not in check after the ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to add.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addPly(Ply ply, short score) {\r\n    // Test if the own king is in check, before adding the ply\r\n    if (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(ply))), _white))) {\r\n        _currentPlies[((_plyCounter)++)] = new AnalyzedPlyImpl(ply, score);\r\n    }\r\n}"},
 {"id":166, "parametername":"short score", "parametertype":"short", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":217, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addPly(de.java_chess.javaChess.ply.Ply,short)", "isreturn":0, "sourcecode":"/**\r\n * Add a ply to the buffer, if the own king is not in check after the ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to add.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addPly(Ply ply, short score) {\r\n    // Test if the own king is in check, before adding the ply\r\n    if (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(ply))), _white))) {\r\n        _currentPlies[((_plyCounter)++)] = new AnalyzedPlyImpl(ply, score);\r\n    }\r\n}"},
 {"id":167, "parametername":"int source", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":218, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addRegularPly(int,int,boolean,short)", "isreturn":0, "sourcecode":"/**\r\n * Add a regular ply.\r\n *\r\n * @param source\r\n * \t\tThe source square.\r\n * @param destination\r\n * \t\tThe destination square.\r\n * @param capture\r\n * \t\tFlag to indicate if another piece is captured.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addRegularPly(int source, int destination, boolean capture, short score) {\r\n    addPly(new PlyImpl(new PositionImpl(source), new PositionImpl(destination), capture), score);\r\n}"},
 {"id":168, "parametername":"int destination", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":218, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addRegularPly(int,int,boolean,short)", "isreturn":0, "sourcecode":"/**\r\n * Add a regular ply.\r\n *\r\n * @param source\r\n * \t\tThe source square.\r\n * @param destination\r\n * \t\tThe destination square.\r\n * @param capture\r\n * \t\tFlag to indicate if another piece is captured.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addRegularPly(int source, int destination, boolean capture, short score) {\r\n    addPly(new PlyImpl(new PositionImpl(source), new PositionImpl(destination), capture), score);\r\n}"},
 {"id":169, "parametername":"boolean capture", "parametertype":"boolean", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":218, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addRegularPly(int,int,boolean,short)", "isreturn":0, "sourcecode":"/**\r\n * Add a regular ply.\r\n *\r\n * @param source\r\n * \t\tThe source square.\r\n * @param destination\r\n * \t\tThe destination square.\r\n * @param capture\r\n * \t\tFlag to indicate if another piece is captured.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addRegularPly(int source, int destination, boolean capture, short score) {\r\n    addPly(new PlyImpl(new PositionImpl(source), new PositionImpl(destination), capture), score);\r\n}"},
 {"id":170, "parametername":"short score", "parametertype":"short", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":218, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addRegularPly(int,int,boolean,short)", "isreturn":0, "sourcecode":"/**\r\n * Add a regular ply.\r\n *\r\n * @param source\r\n * \t\tThe source square.\r\n * @param destination\r\n * \t\tThe destination square.\r\n * @param capture\r\n * \t\tFlag to indicate if another piece is captured.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addRegularPly(int source, int destination, boolean capture, short score) {\r\n    addPly(new PlyImpl(new PositionImpl(source), new PositionImpl(destination), capture), score);\r\n}"},
 {"id":171, "parametername":"int source", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":207, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addCastlingPly(int,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Add a castling ply.\r\n *\r\n * @param source\r\n * \t\tThe position square of the king.\r\n * @param goesLeft\r\n * \t\tThe flag that indicates if the castling goes to the left.\r\n */\r\nprivate final void addCastlingPly(int source, boolean goesLeft) {\r\n    addPly(new CastlingPlyImpl(new PositionImpl(source), goesLeft), REGULAR_PLY);\r\n}"},
 {"id":172, "parametername":"boolean goesLeft", "parametertype":"boolean", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":207, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addCastlingPly(int,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Add a castling ply.\r\n *\r\n * @param source\r\n * \t\tThe position square of the king.\r\n * @param goesLeft\r\n * \t\tThe flag that indicates if the castling goes to the left.\r\n */\r\nprivate final void addCastlingPly(int source, boolean goesLeft) {\r\n    addPly(new CastlingPlyImpl(new PositionImpl(source), goesLeft), REGULAR_PLY);\r\n}"},
 {"id":173, "parametername":"int source", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":221, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addTransformationPly(int,int,byte,boolean,short)", "isreturn":0, "sourcecode":"/**\r\n * Add a transformation ply.\r\n *\r\n * @param source\r\n * \t\tThe source square of the old piece.\r\n * @param destination\r\n * \t\tThe destination square of the piece.\r\n * @param pieceType\r\n * \t\tThe new piece type after the ply.\r\n * @param capture\r\n * \t\tFlag to indicate if another piece is captured.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addTransformationPly(int source, int destination, byte pieceType, boolean capture, short score) {\r\n    addPly(new TransformationPlyImpl(new PositionImpl(source), new PositionImpl(destination), pieceType, capture), score);\r\n}"},
 {"id":174, "parametername":"int destination", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":221, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addTransformationPly(int,int,byte,boolean,short)", "isreturn":0, "sourcecode":"/**\r\n * Add a transformation ply.\r\n *\r\n * @param source\r\n * \t\tThe source square of the old piece.\r\n * @param destination\r\n * \t\tThe destination square of the piece.\r\n * @param pieceType\r\n * \t\tThe new piece type after the ply.\r\n * @param capture\r\n * \t\tFlag to indicate if another piece is captured.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addTransformationPly(int source, int destination, byte pieceType, boolean capture, short score) {\r\n    addPly(new TransformationPlyImpl(new PositionImpl(source), new PositionImpl(destination), pieceType, capture), score);\r\n}"},
 {"id":175, "parametername":"byte pieceType", "parametertype":"byte", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":221, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addTransformationPly(int,int,byte,boolean,short)", "isreturn":0, "sourcecode":"/**\r\n * Add a transformation ply.\r\n *\r\n * @param source\r\n * \t\tThe source square of the old piece.\r\n * @param destination\r\n * \t\tThe destination square of the piece.\r\n * @param pieceType\r\n * \t\tThe new piece type after the ply.\r\n * @param capture\r\n * \t\tFlag to indicate if another piece is captured.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addTransformationPly(int source, int destination, byte pieceType, boolean capture, short score) {\r\n    addPly(new TransformationPlyImpl(new PositionImpl(source), new PositionImpl(destination), pieceType, capture), score);\r\n}"},
 {"id":176, "parametername":"boolean capture", "parametertype":"boolean", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":221, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addTransformationPly(int,int,byte,boolean,short)", "isreturn":0, "sourcecode":"/**\r\n * Add a transformation ply.\r\n *\r\n * @param source\r\n * \t\tThe source square of the old piece.\r\n * @param destination\r\n * \t\tThe destination square of the piece.\r\n * @param pieceType\r\n * \t\tThe new piece type after the ply.\r\n * @param capture\r\n * \t\tFlag to indicate if another piece is captured.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addTransformationPly(int source, int destination, byte pieceType, boolean capture, short score) {\r\n    addPly(new TransformationPlyImpl(new PositionImpl(source), new PositionImpl(destination), pieceType, capture), score);\r\n}"},
 {"id":177, "parametername":"short score", "parametertype":"short", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":221, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.addTransformationPly(int,int,byte,boolean,short)", "isreturn":0, "sourcecode":"/**\r\n * Add a transformation ply.\r\n *\r\n * @param source\r\n * \t\tThe source square of the old piece.\r\n * @param destination\r\n * \t\tThe destination square of the piece.\r\n * @param pieceType\r\n * \t\tThe new piece type after the ply.\r\n * @param capture\r\n * \t\tFlag to indicate if another piece is captured.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addTransformationPly(int source, int destination, byte pieceType, boolean capture, short score) {\r\n    addPly(new TransformationPlyImpl(new PositionImpl(source), new PositionImpl(destination), pieceType, capture), score);\r\n}"},
 {"id":178, "parametername":"int square", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":226, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.getKnightPlies(int)", "isreturn":0, "sourcecode":"/**\r\n * Get the knight plies for a given knight square.\r\n *\r\n * @param square\r\n * \t\tThe square, where the knight is located.\r\n * @return All the knight plies as a 64 bit bitmask.\r\n */\r\npublic final long getKnightPlies(int square) {\r\n    return _knightMask[square];\r\n}"},
 {"id":179, "parametername":"int l", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":233, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.quickersort(int,int)", "isreturn":0, "sourcecode":"/**\r\n * Perform a combined quick-/shakersort on a ply partition.\r\n *\r\n * @param l\r\n * \t\tThe left bound of the array partition.\r\n * @param r\r\n * \t\tThe right bound of the array partition.\r\n */\r\nprivate final void quickersort(int l, int r) {\r\n    int i = l;\r\n    int j = r;\r\n    AnalyzedPly x = _currentPlies[((l + r) / 2)];\r\n    do {\r\n        while ((_currentPlies[i].getScore()) > (x.getScore())) {\r\n            i++;\r\n        } \r\n        while ((x.getScore()) > (_currentPlies[j].getScore())) {\r\n            j--;\r\n        } \r\n        if (i <= j) {\r\n            AnalyzedPly w = _currentPlies[i];\r\n            _currentPlies[(i++)] = _currentPlies[j];\r\n            _currentPlies[(j--)] = w;\r\n        }\r\n    } while (i <= j );\r\n    if (l < j) {\r\n        if ((l - j) > 7) {\r\n            quickersort(l, j);\r\n        } else {\r\n            shakersort(l, j);\r\n        }\r\n    }\r\n    if (i < r) {\r\n        if ((r - i) > 7) {\r\n            quickersort(i, r);\r\n        } else {\r\n            shakersort(i, r);\r\n        }\r\n    }\r\n}"},
 {"id":180, "parametername":"int r", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":233, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.quickersort(int,int)", "isreturn":0, "sourcecode":"/**\r\n * Perform a combined quick-/shakersort on a ply partition.\r\n *\r\n * @param l\r\n * \t\tThe left bound of the array partition.\r\n * @param r\r\n * \t\tThe right bound of the array partition.\r\n */\r\nprivate final void quickersort(int l, int r) {\r\n    int i = l;\r\n    int j = r;\r\n    AnalyzedPly x = _currentPlies[((l + r) / 2)];\r\n    do {\r\n        while ((_currentPlies[i].getScore()) > (x.getScore())) {\r\n            i++;\r\n        } \r\n        while ((x.getScore()) > (_currentPlies[j].getScore())) {\r\n            j--;\r\n        } \r\n        if (i <= j) {\r\n            AnalyzedPly w = _currentPlies[i];\r\n            _currentPlies[(i++)] = _currentPlies[j];\r\n            _currentPlies[(j--)] = w;\r\n        }\r\n    } while (i <= j );\r\n    if (l < j) {\r\n        if ((l - j) > 7) {\r\n            quickersort(l, j);\r\n        } else {\r\n            shakersort(l, j);\r\n        }\r\n    }\r\n    if (i < r) {\r\n        if ((r - i) > 7) {\r\n            quickersort(i, r);\r\n        } else {\r\n            shakersort(i, r);\r\n        }\r\n    }\r\n}"},
 {"id":181, "parametername":"int l", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":239, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.shakersort(int,int)", "isreturn":0, "sourcecode":"/**\r\n * Perform a shakersort on a ply partition.\r\n *\r\n * @param l\r\n * \t\tThe left bound of the ply partition.\r\n * @param r\r\n * \t\tThe right bound of the ply partition.\r\n */\r\nprivate final void shakersort(int l, int r) {\r\n    int i = l + 1;\r\n    int j = r;\r\n    int k = r;\r\n    do {\r\n        for (int h = j; h >= i; h--) {\r\n            if ((_currentPlies[(h - 1)].getScore()) < (_currentPlies[h].getScore())) {\r\n                AnalyzedPly w = _currentPlies[(h - 1)];\r\n                _currentPlies[(h - 1)] = _currentPlies[h];\r\n                _currentPlies[h] = w;\r\n                k = h;\r\n            }\r\n        }\r\n        i = k + 1;\r\n        for (int h = i; h <= j; h++) {\r\n            if ((_currentPlies[(h - 1)].getScore()) < (_currentPlies[h].getScore())) {\r\n                AnalyzedPly w = _currentPlies[(h - 1)];\r\n                _currentPlies[(h - 1)] = _currentPlies[h];\r\n                _currentPlies[h] = w;\r\n                k = h;\r\n            }\r\n        }\r\n        j = k - 1;\r\n    } while (i <= j );\r\n}"},
 {"id":182, "parametername":"int r", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":239, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.shakersort(int,int)", "isreturn":0, "sourcecode":"/**\r\n * Perform a shakersort on a ply partition.\r\n *\r\n * @param l\r\n * \t\tThe left bound of the ply partition.\r\n * @param r\r\n * \t\tThe right bound of the ply partition.\r\n */\r\nprivate final void shakersort(int l, int r) {\r\n    int i = l + 1;\r\n    int j = r;\r\n    int k = r;\r\n    do {\r\n        for (int h = j; h >= i; h--) {\r\n            if ((_currentPlies[(h - 1)].getScore()) < (_currentPlies[h].getScore())) {\r\n                AnalyzedPly w = _currentPlies[(h - 1)];\r\n                _currentPlies[(h - 1)] = _currentPlies[h];\r\n                _currentPlies[h] = w;\r\n                k = h;\r\n            }\r\n        }\r\n        i = k + 1;\r\n        for (int h = i; h <= j; h++) {\r\n            if ((_currentPlies[(h - 1)].getScore()) < (_currentPlies[h].getScore())) {\r\n                AnalyzedPly w = _currentPlies[(h - 1)];\r\n                _currentPlies[(h - 1)] = _currentPlies[h];\r\n                _currentPlies[h] = w;\r\n                k = h;\r\n            }\r\n        }\r\n        j = k - 1;\r\n    } while (i <= j );\r\n}"},
 {"id":183, "parametername":"int maximumEntries", "parametertype":"int", "parameterclass":0, "classid":26, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "methodid":246, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.setMaximumSize(int)", "isreturn":0, "sourcecode":"/**\r\n * Set the maximum number of entries in the hashtable.\r\n *\r\n * @param maximumEntries\r\n * \t\tThe new maximum number of entries.\r\n */\r\nvoid setMaximumSize(int maximumEntries);"},
 {"id":184, "parametername":"PlyHashtableEntry ply", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry", "parameterclass":27, "classid":26, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "methodid":243, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)", "isreturn":0, "sourcecode":"/**\r\n * Try to push a new entry into the hashtable.\r\n *\r\n * @param entry\r\n * \t\tThe new entry, that the hashtable might store.\r\n */\r\nvoid pushEntry(PlyHashtableEntry ply);"},
 {"id":185, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":26, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "methodid":241, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.getPly(de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe board before the move.\r\n * @param white\r\n * \t\tFlag to indicate, if we want a move with the white pieces.\r\n */\r\nPly getPly(Board board, boolean white);"},
 {"id":186, "parametername":"de.java_chess.javaChess.ply.Ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":26, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "methodid":241, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.getPly(de.java_chess.javaChess.board.Board,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe board before the move.\r\n * @param white\r\n * \t\tFlag to indicate, if we want a move with the white pieces.\r\n */\r\nPly getPly(Board board, boolean white);"},
 {"id":187, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":26, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable", "methodid":241, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.getPly(de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe board before the move.\r\n * @param white\r\n * \t\tFlag to indicate, if we want a move with the white pieces.\r\n */\r\nPly getPly(Board board, boolean white);"},
 {"id":188, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":252, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new hashtable entry.\r\n *\r\n * @param board\r\n * \t\tThe board before the ply.\r\n * @param ply\r\n * \t\tThe ply to store.\r\n * @param searchDepth\r\n * \t\tThe search depth, that was used to compute the ply.\r\n */\r\npublic PlyHashtableEntryImpl(Board board, Ply ply, int searchDepth) {\r\n    setBoard(board);\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}"},
 {"id":189, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":252, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new hashtable entry.\r\n *\r\n * @param board\r\n * \t\tThe board before the ply.\r\n * @param ply\r\n * \t\tThe ply to store.\r\n * @param searchDepth\r\n * \t\tThe search depth, that was used to compute the ply.\r\n */\r\npublic PlyHashtableEntryImpl(Board board, Ply ply, int searchDepth) {\r\n    setBoard(board);\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}"},
 {"id":190, "parametername":"int searchDepth", "parametertype":"int", "parameterclass":0, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":252, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new hashtable entry.\r\n *\r\n * @param board\r\n * \t\tThe board before the ply.\r\n * @param ply\r\n * \t\tThe ply to store.\r\n * @param searchDepth\r\n * \t\tThe search depth, that was used to compute the ply.\r\n */\r\npublic PlyHashtableEntryImpl(Board board, Ply ply, int searchDepth) {\r\n    setBoard(board);\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}"},
 {"id":191, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":259, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board for this entry.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\npublic final void setBoard(Board board) {\r\n    _board = board;\r\n}"},
 {"id":192, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":260, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Set the ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to set.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":193, "parametername":"int searchDepth", "parametertype":"int", "parameterclass":0, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":261, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setSearchDepth(int)", "isreturn":0, "sourcecode":"/**\r\n * Set the search depth for the computed ply.\r\n *\r\n * @param searchDepth\r\n * \t\tThe search depth.\r\n */\r\npublic final void setSearchDepth(int searchDepth) {\r\n    _searchDepth = searchDepth;\r\n}"},
 {"id":194, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":257, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey(de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get a hashcode for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\ttrue, if its a ply with the white pieces.\r\n * @return A hashcode for the given board and color.\r\n */\r\npublic static long hashKey(Board board, boolean white) {\r\n    return ZobristKeyImpl.getInstance().computeKey(((BitBoard) (board)), white);\r\n}"},
 {"id":195, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":257, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey(de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get a hashcode for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\ttrue, if its a ply with the white pieces.\r\n * @return A hashcode for the given board and color.\r\n */\r\npublic static long hashKey(Board board, boolean white) {\r\n    return ZobristKeyImpl.getInstance().computeKey(((BitBoard) (board)), white);\r\n}"},
 {"id":196, "parametername":"int maxSize", "parametertype":"int", "parameterclass":0, "classid":29, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "methodid":262, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.-init-(int)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new hashtable instance with a given maximum size.\r\n *\r\n * @param maxSize\r\n * \t\tThe maximum number of entries.\r\n */\r\npublic PlyHashtableImpl(int maxSize) {\r\n    _hashtable = new Hashtable();\r\n    _orderedList = new LinkedList();\r\n    setMaximumSize(maxSize);\r\n}"},
 {"id":197, "parametername":"int maximumEntries", "parametertype":"int", "parameterclass":0, "classid":29, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "methodid":269, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.setMaximumSize(int)", "isreturn":0, "sourcecode":"/**\r\n * Set the maximum number of entries in the hashtable.\r\n *\r\n * @param maximumEntries\r\n * \t\tThe new maximum number of entries.\r\n */\r\npublic final void setMaximumSize(int maximumEntries) {\r\n    _maxSize = maximumEntries;\r\n    // Remove the oldest entries, if the current size\r\n    // is bigger than the new maximum size.\r\n    while ((getSize()) > (getMaximumSize())) {\r\n        removeOldestEntry();\r\n    } \r\n}"},
 {"id":198, "parametername":"PlyHashtableEntry ply", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry", "parameterclass":27, "classid":29, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "methodid":266, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)", "isreturn":0, "sourcecode":"/**\r\n * Try to push a new entry into the hashtable.\r\n *\r\n * @param entry\r\n * \t\tThe new entry, that the hashtable might store.\r\n */\r\npublic final void pushEntry(PlyHashtableEntry ply) {\r\n    // Compute and store the key for this ply.\r\n    Long hashKey = new Long(ply.hashKey());\r\n    // Check if this ply is not already in the hashtable\r\n    PlyHashtableEntry oldEntry = ((PlyHashtableEntry) (_hashtable.get(hashKey)));\r\n    if (oldEntry != null) {\r\n        // There is a entry with the same key\r\n        if ((oldEntry.getSearchDepth()) >= (ply.getSearchDepth())) {\r\n            return;// This entry shouldnt be replaced.\r\n\r\n        }\r\n    } else {\r\n        // Now we actually add a new entry to the table.\r\n        // Check, if the hashtable has not exceeded its maximum capacity\r\n        // and remove older entries, if necessary.\r\n        while ((getSize()) >= (getMaximumSize())) {\r\n            removeOldestEntry();\r\n        } \r\n    }\r\n    // Put the new ply into the hashtable\r\n    _hashtable.put(hashKey, ply);\r\n    // Append the new ply at the end of the list of plies.\r\n    // ATTENTION: this will only work, if theres only _one_\r\n    // ply for each key!\r\n    _orderedList.add(hashKey);\r\n}"},
 {"id":199, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":29, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "methodid":264, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\ttrue, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}"},
 {"id":200, "parametername":"de.java_chess.javaChess.ply.Ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":29, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "methodid":264, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\ttrue, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}"},
 {"id":201, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":29, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "methodid":264, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\ttrue, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}"},
 {"id":202, "parametername":"BitBoard board", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":30, "classname":"de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl", "methodid":271, "methodname":"de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.computeKey(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Compute a key for a board and a color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\tFlag to indicate if white moves.\r\n * @return The zobrist key.\r\n */\r\npublic long computeKey(BitBoard board, boolean white) {\r\n    long val = 0L;\r\n    // Get a bitmask of the empty squares to speedup the\r\n    // test for a piece on the square.\r\n    long emptySquareMask = board.getEmptySquares();\r\n    // Reuse the same position object for each square.\r\n    Position curPosition = new PositionImpl(0);\r\n    for (int square = 0; square < 64; square++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            curPosition.setSquareIndex(square);\r\n            Piece p = board.getPiece(curPosition);\r\n            if (p != null) {\r\n                val ^= _factors[p.getColor()][((p.getType()) - 1)][square];\r\n            }\r\n        }\r\n        emptySquareMask >>>= 1;// Shift the mask to test for the next square.\r\n\r\n    }\r\n    if (!white) {\r\n        val ^= _blackMoves;\r\n    }\r\n    return val;\r\n}"},
 {"id":203, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":30, "classname":"de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl", "methodid":271, "methodname":"de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.computeKey(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Compute a key for a board and a color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\tFlag to indicate if white moves.\r\n * @return The zobrist key.\r\n */\r\npublic long computeKey(BitBoard board, boolean white) {\r\n    long val = 0L;\r\n    // Get a bitmask of the empty squares to speedup the\r\n    // test for a piece on the square.\r\n    long emptySquareMask = board.getEmptySquares();\r\n    // Reuse the same position object for each square.\r\n    Position curPosition = new PositionImpl(0);\r\n    for (int square = 0; square < 64; square++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            curPosition.setSquareIndex(square);\r\n            Piece p = board.getPiece(curPosition);\r\n            if (p != null) {\r\n                val ^= _factors[p.getColor()][((p.getType()) - 1)][square];\r\n            }\r\n        }\r\n        emptySquareMask >>>= 1;// Shift the mask to test for the next square.\r\n\r\n    }\r\n    if (!white) {\r\n        val ^= _blackMoves;\r\n    }\r\n    return val;\r\n}"},
 {"id":204, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":31, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBook", "methodid":274, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBook.doUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Advance the game by one user ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply from the user.\r\n */\r\nvoid doUserPly(Ply ply);"},
 {"id":205, "parametername":"File file", "parametertype":"java.io.File", "parameterclass":0, "classid":31, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBook", "methodid":273, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBook.addPGNopening(java.io.File)", "isreturn":0, "sourcecode":"/**\r\n * Add a opening in PGN format to the opening book and return\r\n * the error status.\r\n *\r\n * @param file\r\n * \t\tThe File to add to the opening book.\r\n */\r\nvoid addPGNopening(File file);"},
 {"id":206, "parametername":"GameNotation notation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":277, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.-init-(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this class.\r\n *\r\n * @param notation\r\n * \t\tThe notation of the current game.\r\n */\r\npublic OpeningBookImpl(GameNotation notation) {\r\n    setNotation(notation);\r\n    // Create a new dynamic array for the openings.\r\n    _openings = new ArrayList();\r\n    // Reset the opening book.\r\n    reset();\r\n}"},
 {"id":207, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":279, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.doUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * The user just did a ply.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n */\r\npublic final void doUserPly(Ply ply) {\r\n    // If we are already in a opening, check if the current user\r\n    // move doesnt lead us out of the opening line.\r\n    if ((_currentOpening) != (-1)) {\r\n        if (!(isInOpening(_currentOpening))) {\r\n            _currentOpening = -1;\r\n        }\r\n    }\r\n}"},
 {"id":208, "parametername":"File file", "parametertype":"java.io.File", "parameterclass":0, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":278, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.addPGNopening(java.io.File)", "isreturn":0, "sourcecode":"/**\r\n * Add a opening in PGN format to the opening book and return\r\n * the error status.\r\n *\r\n * @param file\r\n * \t\tThe File to add to the opening book.\r\n */\r\npublic final void addPGNopening(File file) {\r\n    try {\r\n        PGNFile pgnFile = new PGNFile(new BufferedReader(new FileReader(file)));\r\n        GameNotation notation = pgnFile.readGame();\r\n        _openings.add(notation);\r\n        // System.out.println( \"DEBUG: added opening \n\" + notation.toString());\r\n    } catch (FileNotFoundException fe) {\r\n        JOptionPane.showMessageDialog(null, ((\"File \" + (file.getName())) + \" not found!\"), \"File not found\", JOptionPane.ERROR_MESSAGE);\r\n    } catch (IOException ioe) {\r\n        JOptionPane.showMessageDialog(null, ((\"IO error while parsing file \" + (file.getName())) + \"!\"), \"IO error\", JOptionPane.ERROR_MESSAGE);\r\n    } catch (RecognitionException re) {\r\n        JOptionPane.showMessageDialog(null, ((\"Error while parsing file \" + (file.getName())) + \"!\"), \"Error in PGN file\", JOptionPane.ERROR_MESSAGE);\r\n    } catch (TokenStreamException te) {\r\n        System.err.print(\"Tokenstream exception\");\r\n    }\r\n}"},
 {"id":209, "parametername":"int openingIndex", "parametertype":"int", "parameterclass":0, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":283, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.isInOpening(int)", "isreturn":0, "sourcecode":"/**\r\n * Check, if the current game notation is part of a given opening.\r\n *\r\n * @param openingIndex\r\n * \t\tThe index of the opening to test.\r\n */\r\nprivate final boolean isInOpening(int openingIndex) {\r\n    GameNotation notation = ((GameNotation) (_openings.get(openingIndex)));\r\n    // If the current game has more plies, than the opening, we can return\r\n    // false.\r\n    if ((_notation.size()) > (notation.size())) {\r\n        return false;\r\n    }\r\n    // Compare the notation ply by ply, which is rather slow, but should work\r\n    // for now.\r\n    for (int i = 0; i < (_notation.size()); i++) {\r\n        if (!(_notation.getPlyNotation(i).getPly().equals(notation.getPlyNotation(i).getPly()))) {\r\n            return false;\r\n        }\r\n    }\r\n    // The current game uses the given opening.\r\n    return true;\r\n}"},
 {"id":210, "parametername":"GameNotation notation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":285, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.setNotation(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"/**\r\n * Set the notation of the current game.\r\n *\r\n * @param notation\r\n * \t\tThe notation of the current game.\r\n */\r\nprivate final void setNotation(GameNotation notation) {\r\n    _notation = notation;\r\n}"},
 {"id":211, "parametername":"OpeningBook book", "parametertype":"de.java_chess.javaChess.engine.opening_book.OpeningBook", "parameterclass":31, "classid":33, "classname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction", "methodid":286, "methodname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.-init-(de.java_chess.javaChess.engine.opening_book.OpeningBook)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param book\r\n * \t\tThe opening book, we are operating on.\r\n */\r\npublic LoadOpeningsAction(OpeningBook book) {\r\n    super(\"Load openings from PGN...\");\r\n    setOpeningBook(book);\r\n}"},
 {"id":212, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":33, "classname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction", "methodid":287, "methodname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * \t\tThe event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    JFileChooser chooser = new JFileChooser();\r\n    chooser.setDialogTitle(\"Load opening from pgn files\");\r\n    chooser.setFileFilter(SaveGameAsAction.getPGNFileFilter());\r\n    // Allow the user to select directories.\r\n    chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);\r\n    int retval = chooser.showOpenDialog(null);\r\n    if (retval == (JFileChooser.APPROVE_OPTION)) {\r\n        File file = chooser.getSelectedFile();\r\n        processFileOrDirectory(file);\r\n    }\r\n}"},
 {"id":213, "parametername":"File file", "parametertype":"java.io.File", "parameterclass":0, "classid":33, "classname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction", "methodid":289, "methodname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.processFileOrDirectory(java.io.File)", "isreturn":0, "sourcecode":"/**\r\n * Process a file or directory.\r\n *\r\n * @param file\r\n * \t\tThe file to process.\r\n */\r\nprivate final void processFileOrDirectory(File file) {\r\n    // If this file is a directory, read all the files in it.\r\n    if (file.isDirectory()) {\r\n        String[] files = file.list();// Get the content of the directory\r\n\r\n        // Now create an absolute file from each name and process it.\r\n        for (int i = 0; i < (files.length); i++) {\r\n            processFileOrDirectory(new File(file, files[i]));\r\n        }\r\n    } else {\r\n        // This is a single file, so\r\n        // check, if it might be a PGN file.\r\n        if (SaveGameAsAction.getPGNFileFilter().accept(file)) {\r\n            processPGNfile(file);\r\n        }\r\n    }\r\n}"},
 {"id":214, "parametername":"File file", "parametertype":"java.io.File", "parameterclass":0, "classid":33, "classname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction", "methodid":290, "methodname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.processPGNfile(java.io.File)", "isreturn":0, "sourcecode":"/**\r\n * Process a single PGN file.\r\n *\r\n * @param file\r\n * \t\tThe PGN file to process.\r\n */\r\nprivate final void processPGNfile(File file) {\r\n    getOpeningBook().addPGNopening(file);\r\n}"},
 {"id":215, "parametername":"OpeningBook book", "parametertype":"de.java_chess.javaChess.engine.opening_book.OpeningBook", "parameterclass":31, "classid":33, "classname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction", "methodid":291, "methodname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)", "isreturn":0, "sourcecode":"/**\r\n * Set the opening book, we are operating on.\r\n *\r\n * @param book\r\n * \t\tThe new opening book.\r\n */\r\nprivate final void setOpeningBook(OpeningBook book) {\r\n    _openingBook = book;\r\n}"},
 {"id":216, "parametername":"ChessEngine engine", "parametertype":"de.java_chess.javaChess.engine.ChessEngine", "parameterclass":23, "classid":34, "classname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "methodid":292, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.-init-(de.java_chess.javaChess.engine.ChessEngine)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new PermanentBrain instance.\r\n *\r\n * @param engine\r\n * \t\tThe used chess engine.\r\n */\r\npublic PermanentBrain(ChessEngine engine) {\r\n    setEngine(engine);\r\n}"},
 {"id":217, "parametername":"ChessEngine engine", "parametertype":"de.java_chess.javaChess.engine.ChessEngine", "parameterclass":23, "classid":34, "classname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "methodid":298, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.setEngine(de.java_chess.javaChess.engine.ChessEngine)", "isreturn":0, "sourcecode":"/**\r\n * Set a new chess engine.\r\n *\r\n * @param engine\r\n * \t\tThe new chess engine.\r\n */\r\nprivate final void setEngine(ChessEngine engine) {\r\n    _engine = engine;\r\n}"},
 {"id":218, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":34, "classname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "methodid":294, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"},
 {"id":219, "parametername":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPly", "parametertype":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPly", "parameterclass":35, "classid":34, "classname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "methodid":294, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"},
 {"id":220, "parametername":"AnalyzedPly ply", "parametertype":"de.java_chess.javaChess.ply.AnalyzedPly", "parameterclass":69, "classid":36, "classname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl", "methodid":303, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.-init-(de.java_chess.javaChess.ply.AnalyzedPly,int)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of a computed ply.\r\n *\r\n * @param ply\r\n * \t\tThe computed ply.\r\n * @param searchDepth\r\n * \t\tThe used search depth.\r\n */\r\npublic PreComputedPlyImpl(AnalyzedPly ply, int searchDepth) {\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}"},
 {"id":221, "parametername":"int searchDepth", "parametertype":"int", "parameterclass":0, "classid":36, "classname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl", "methodid":303, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.-init-(de.java_chess.javaChess.ply.AnalyzedPly,int)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of a computed ply.\r\n *\r\n * @param ply\r\n * \t\tThe computed ply.\r\n * @param searchDepth\r\n * \t\tThe used search depth.\r\n */\r\npublic PreComputedPlyImpl(AnalyzedPly ply, int searchDepth) {\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}"},
 {"id":222, "parametername":"AnalyzedPly ply", "parametertype":"de.java_chess.javaChess.ply.AnalyzedPly", "parameterclass":69, "classid":36, "classname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl", "methodid":306, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.setPly(de.java_chess.javaChess.ply.AnalyzedPly)", "isreturn":0, "sourcecode":"/**\r\n * Set the computed ply.\r\n *\r\n * @param ply\r\n * \t\tThe computed ply.\r\n */\r\nprivate final void setPly(AnalyzedPly ply) {\r\n    _ply = ply;\r\n}"},
 {"id":223, "parametername":"int searchDepth", "parametertype":"int", "parameterclass":0, "classid":36, "classname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl", "methodid":307, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.setSearchDepth(int)", "isreturn":0, "sourcecode":"/**\r\n * Set the used search depth.\r\n *\r\n * @param searchDepth\r\n * \t\tThe used search depth.\r\n */\r\nprivate final void setSearchDepth(int searchDepth) {\r\n    _searchDepth = searchDepth;\r\n}"},
 {"id":224, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":38, "classname":"de.java_chess.javaChess.engine.test.AnalyzerTest2", "methodid":314, "methodname":"de.java_chess.javaChess.engine.test.AnalyzerTest2.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":225, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":39, "classname":"de.java_chess.javaChess.engine.test.BoardConsistencyTest1", "methodid":321, "methodname":"de.java_chess.javaChess.engine.test.BoardConsistencyTest1.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":226, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":42, "classname":"de.java_chess.javaChess.engine.test.MinimaxTest1", "methodid":331, "methodname":"de.java_chess.javaChess.engine.test.MinimaxTest1.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":227, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":43, "classname":"de.java_chess.javaChess.engine.test.MinimaxTest2", "methodid":336, "methodname":"de.java_chess.javaChess.engine.test.MinimaxTest2.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":228, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":44, "classname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest1", "methodid":341, "methodname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest1.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":229, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":45, "classname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest2", "methodid":346, "methodname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest2.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":230, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":46, "classname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest3", "methodid":351, "methodname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest3.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":231, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":47, "classname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest4", "methodid":356, "methodname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest4.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":232, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":48, "classname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest5", "methodid":361, "methodname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest5.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":233, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":49, "classname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest6", "methodid":366, "methodname":"de.java_chess.javaChess.engine.test.PlyGeneratorTest6.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":234, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":50, "classname":"de.java_chess.javaChess.game.Game", "methodid":370, "methodname":"de.java_chess.javaChess.game.Game.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Add a new ply to the game.\r\n *\r\n * @unknown The new ply.\r\n */\r\nvoid doPly(Ply ply);"},
 {"id":235, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":50, "classname":"de.java_chess.javaChess.game.Game", "methodid":373, "methodname":"de.java_chess.javaChess.game.Game.hasBeenMoved(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * \t\tThe position to check.\r\n */\r\nboolean hasBeenMoved(Position position);"},
 {"id":236, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":388, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,long)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a game status from a ply and a moved pieces bitmask.\r\n *\r\n * @param ply\r\n * \t\tThe ply for this game status.\r\n * @param bitmask\r\n * \t\tThe moved pieces _before_ this ply.\r\n */\r\nGameStatus(Ply ply, long bitmask) {\r\n    // Store the ply in an instance variable.\r\n    setPly(ply);\r\n    // Store the moved pieces of the previous game status.\r\n    setMovedPieces(bitmask);\r\n    // And store the moved piece of the current ply.\r\n    setMoved(ply.getSource());\r\n}"},
 {"id":237, "parametername":"long bitmask", "parametertype":"long", "parameterclass":0, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":388, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,long)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a game status from a ply and a moved pieces bitmask.\r\n *\r\n * @param ply\r\n * \t\tThe ply for this game status.\r\n * @param bitmask\r\n * \t\tThe moved pieces _before_ this ply.\r\n */\r\nGameStatus(Ply ply, long bitmask) {\r\n    // Store the ply in an instance variable.\r\n    setPly(ply);\r\n    // Store the moved pieces of the previous game status.\r\n    setMovedPieces(bitmask);\r\n    // And store the moved piece of the current ply.\r\n    setMoved(ply.getSource());\r\n}"},
 {"id":238, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":389, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Create a first game status.\r\n *\r\n * @param ply\r\n * \t\tThe first ply of this game.\r\n */\r\nGameStatus(Ply ply) {\r\n    // Construct a new instance from this ply and all\r\n    // pieces on their initial positions.\r\n    this(ply, 0L);\r\n}"},
 {"id":239, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":390, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)", "isreturn":0, "sourcecode":"/**\r\n * Create a new game status from a preceeding status and a ply.\r\n *\r\n * @param status\r\n * \t\tThe previous game status.\r\n */\r\nGameStatus(Ply ply, GameImpl.GameStatus previousStatus) {\r\n    // Create a new instance from this ply and the\r\n    // previous game status.\r\n    this(ply, previousStatus.getMovedPieces());\r\n}"},
 {"id":240, "parametername":"GameImpl.GameStatus previousStatus", "parametertype":"de.java_chess.javaChess.game.GameImpl$GameStatus", "parameterclass":51, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":390, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)", "isreturn":0, "sourcecode":"/**\r\n * Create a new game status from a preceeding status and a ply.\r\n *\r\n * @param status\r\n * \t\tThe previous game status.\r\n */\r\nGameStatus(Ply ply, GameImpl.GameStatus previousStatus) {\r\n    // Create a new instance from this ply and the\r\n    // previous game status.\r\n    this(ply, previousStatus.getMovedPieces());\r\n}"},
 {"id":241, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":396, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.setPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Set the ply, that lead to this game status.\r\n *\r\n * @param ply\r\n * \t\tThe ply, that lead to this game status.\r\n */\r\nfinal void setPly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":242, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":394, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.setMoved(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Mark a piece moved from its initial position.\r\n *\r\n * @param position\r\n * \t\tThe position of the moved piece.\r\n */\r\nprivate final void setMoved(Position position) {\r\n    _movedPieces |= 1L << (position.getSquareIndex());\r\n}"},
 {"id":243, "parametername":"long bitmask", "parametertype":"long", "parameterclass":0, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":395, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.setMovedPieces(long)", "isreturn":0, "sourcecode":"/**\r\n * Set the bitmask for the moved pieces.\r\n *\r\n * @param bitmask\r\n * \t\tThe new bitmask for the moved pieces.\r\n */\r\nprivate final void setMovedPieces(long bitmask) {\r\n    _movedPieces = bitmask;\r\n}"},
 {"id":244, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":393, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.hasBeenMoved(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Check if a piece on a given initial position\r\n * has been moved.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    return ((_movedPieces) & (1L << (position.getSquareIndex()))) != 0L;\r\n}"},
 {"id":245, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":52, "classname":"de.java_chess.javaChess.game.GameImpl", "methodid":380, "methodname":"de.java_chess.javaChess.game.GameImpl.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Do a new ply in this game.\r\n *\r\n * @param ply\r\n * \t\tThe next ply.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    // Add a new game status, that derives from the previous status.\r\n    _gameStatus.push(((getLastGameStatus()) == null ? new GameImpl.GameStatus(ply) : new GameImpl.GameStatus(ply, getLastGameStatus())));\r\n}"},
 {"id":246, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":52, "classname":"de.java_chess.javaChess.game.GameImpl", "methodid":384, "methodname":"de.java_chess.javaChess.game.GameImpl.hasBeenMoved(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * \t\tThe position to check.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    GameImpl.GameStatus lastStatus = getLastGameStatus();\r\n    return lastStatus == null ? false : lastStatus.hasBeenMoved(position);\r\n}"},
 {"id":247, "parametername":"ChessEngineImpl engine", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":53, "classname":"de.java_chess.javaChess.listener.EngineStatusListener", "methodid":397, "methodname":"de.java_chess.javaChess.listener.EngineStatusListener.engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)", "isreturn":0, "sourcecode":"public void engineStatusChanged(ChessEngineImpl engine);"},
 {"id":248, "parametername":"ActionEvent e", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":54, "classname":"de.java_chess.javaChess.menu.EditMenu", "methodid":399, "methodname":"de.java_chess.javaChess.menu.EditMenu.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * Interface method. Currently displays input dialogs to edit white and black player\r\n * names\r\n *\r\n * @param e\r\n * \t\tThe action event\r\n */\r\npublic void actionPerformed(ActionEvent e) {\r\n    if (e.getSource().equals(jmiEditPosition)) {\r\n        SetupBoardDialog setupBoardDialog = new SetupBoardDialog();\r\n        Tools.setDialogToCenter(setupBoardDialog);\r\n        setupBoardDialog.setModal(true);\r\n        setupBoardDialog.show();\r\n    } else {\r\n        if ((notationPanel) != null) {\r\n            PlayerDialog playerDialog = null;\r\n            boolean bWhiteOrBlack = true;\r\n            if (e.getSource().equals(jmiWhitePlayerName)) {\r\n                playerDialog = new PlayerDialog(1, notationPanel.getWhitePlayerName());\r\n                bWhiteOrBlack = true;\r\n            } else\r\n                if (e.getSource().equals(jmiBlackPlayerName)) {\r\n                    playerDialog = new PlayerDialog(2, notationPanel.getBlackPlayerName());\r\n                    bWhiteOrBlack = false;\r\n                }\r\n\r\n            if (playerDialog != null) {\r\n                Tools.setDialogToCenter(playerDialog);\r\n                playerDialog.show();\r\n                String sNewName = playerDialog.getNewName();\r\n                if (bWhiteOrBlack == true) {\r\n                    notationPanel.setWhitePlayerName(sNewName);\r\n                } else {\r\n                    notationPanel.setBlackPlayerName(sNewName);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"},
 {"id":249, "parametername":"NotationPanel panel", "parametertype":"de.java_chess.javaChess.renderer2d.NotationPanel", "parameterclass":92, "classid":54, "classname":"de.java_chess.javaChess.menu.EditMenu", "methodid":401, "methodname":"de.java_chess.javaChess.menu.EditMenu.setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)", "isreturn":0, "sourcecode":"/**\r\n * Sets the NotationPanel to be able to perform some actions there\r\n *\r\n * @param panel\r\n * \t\tThe NotationPanel object\r\n */\r\npublic final void setNotationPanel(NotationPanel panel) {\r\n    this.notationPanel = panel;\r\n}"},
 {"id":250, "parametername":"int moveIndex", "parametertype":"int", "parameterclass":0, "classid":55, "classname":"de.java_chess.javaChess.notation.GameNotation", "methodid":403, "methodname":"de.java_chess.javaChess.notation.GameNotation.getMove(int,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * \t\tThe index of the move.\r\n * @param boolean\r\n * \t\twhite Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\nString getMove(int moveIndex, boolean white);"},
 {"id":251, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":55, "classname":"de.java_chess.javaChess.notation.GameNotation", "methodid":403, "methodname":"de.java_chess.javaChess.notation.GameNotation.getMove(int,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * \t\tThe index of the move.\r\n * @param boolean\r\n * \t\twhite Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\nString getMove(int moveIndex, boolean white);"},
 {"id":252, "parametername":"PlyNotation plyNotation", "parametertype":"de.java_chess.javaChess.notation.PlyNotation", "parameterclass":57, "classid":55, "classname":"de.java_chess.javaChess.notation.GameNotation", "methodid":402, "methodname":"de.java_chess.javaChess.notation.GameNotation.addPly(de.java_chess.javaChess.notation.PlyNotation)", "isreturn":0, "sourcecode":"/**\r\n * Add a new ply with its notation.\r\n *\r\n * @param plyNotation\r\n * \t\tThe notation of the new ply.\r\n */\r\npublic void addPly(PlyNotation plyNotation);"},
 {"id":253, "parametername":"int index", "parametertype":"int", "parameterclass":0, "classid":55, "classname":"de.java_chess.javaChess.notation.GameNotation", "methodid":407, "methodname":"de.java_chess.javaChess.notation.GameNotation.getPlyNotation(int)", "isreturn":0, "sourcecode":"/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * \t\tThe index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index);"},
 {"id":254, "parametername":"de.java_chess.javaChess.notation.PlyNotation", "parametertype":"de.java_chess.javaChess.notation.PlyNotation", "parameterclass":57, "classid":55, "classname":"de.java_chess.javaChess.notation.GameNotation", "methodid":407, "methodname":"de.java_chess.javaChess.notation.GameNotation.getPlyNotation(int)", "isreturn":1, "sourcecode":"/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * \t\tThe index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index);"},
 {"id":255, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":55, "classname":"de.java_chess.javaChess.notation.GameNotation", "methodid":406, "methodname":"de.java_chess.javaChess.notation.GameNotation.getPlayerInfo(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get some info on a player.\r\n *\r\n * @return Some info on a player.\r\n */\r\nString getPlayerInfo(boolean white);"},
 {"id":256, "parametername":"String playerInfo", "parametertype":"java.lang.String", "parameterclass":0, "classid":55, "classname":"de.java_chess.javaChess.notation.GameNotation", "methodid":410, "methodname":"de.java_chess.javaChess.notation.GameNotation.setPlayerInfo(java.lang.String,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the info on a player.\r\n *\r\n * @param playerInfo\r\n * \t\tThe player info.\r\n * @param white\r\n * \t\tFlag to indicate, if its the player\r\n * \t\twith the white pieces.\r\n */\r\nvoid setPlayerInfo(String playerInfo, boolean white);"},
 {"id":257, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":55, "classname":"de.java_chess.javaChess.notation.GameNotation", "methodid":410, "methodname":"de.java_chess.javaChess.notation.GameNotation.setPlayerInfo(java.lang.String,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the info on a player.\r\n *\r\n * @param playerInfo\r\n * \t\tThe player info.\r\n * @param white\r\n * \t\tFlag to indicate, if its the player\r\n * \t\twith the white pieces.\r\n */\r\nvoid setPlayerInfo(String playerInfo, boolean white);"},
 {"id":258, "parametername":"String name", "parametertype":"java.lang.String", "parameterclass":0, "classid":55, "classname":"de.java_chess.javaChess.notation.GameNotation", "methodid":409, "methodname":"de.java_chess.javaChess.notation.GameNotation.setOpeningInfo(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Set the info on the used opening.\r\n *\r\n * @param name\r\n * \t\tThe name of the opening.\r\n */\r\nvoid setOpeningInfo(String name);"},
 {"id":259, "parametername":"int moveIndex", "parametertype":"int", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":415, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.getMove(int,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * \t\tThe index of the move.\r\n * @param boolean\r\n * \t\twhite Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\npublic final String getMove(int moveIndex, boolean white) {\r\n    return getPly((white ? moveIndex << 1 : (moveIndex << 1) + 1));\r\n}"},
 {"id":260, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":415, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.getMove(int,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * \t\tThe index of the move.\r\n * @param boolean\r\n * \t\twhite Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\npublic final String getMove(int moveIndex, boolean white) {\r\n    return getPly((white ? moveIndex << 1 : (moveIndex << 1) + 1));\r\n}"},
 {"id":261, "parametername":"int plyIndex", "parametertype":"int", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":420, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.getPly(int)", "isreturn":0, "sourcecode":"/**\r\n * Get the ply with the given index.\r\n *\r\n * @param plyIndex\r\n * \t\tThe index of the ply.\r\n * @return The notation for the ply as a string.\r\n */\r\nprivate final String getPly(int plyIndex) {\r\n    return _plies.get(plyIndex).toString();\r\n}"},
 {"id":262, "parametername":"PlyNotation plyNotation", "parametertype":"de.java_chess.javaChess.notation.PlyNotation", "parameterclass":57, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":414, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.addPly(de.java_chess.javaChess.notation.PlyNotation)", "isreturn":0, "sourcecode":"/**\r\n * Add a new ply with its notation.\r\n *\r\n * @param plyNotation\r\n * \t\tThe notation of the new ply.\r\n */\r\npublic void addPly(PlyNotation plyNotation) {\r\n    _plies.add(plyNotation);\r\n    int nPlies = _plies.size();// Get the number of plies.\r\n\r\n    if ((nPlies & 1) != 0) {\r\n        if (nPlies > 1) {\r\n            // Start a new line\r\n            _notation.append(\"\n\");\r\n        }\r\n        _notation.append(((\"\" + ((nPlies >> 1) + 1)) + \". \"));\r\n    } else {\r\n        _notation.append(\" \");\r\n    }\r\n    _notation.append(plyNotation.toString());\r\n    // If theres a panel, display the current notation.\r\n    if (null != (getNotationPanel())) {\r\n        getNotationPanel().setText(toString());\r\n    }\r\n}"},
 {"id":263, "parametername":"int index", "parametertype":"int", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":421, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.getPlyNotation(int)", "isreturn":0, "sourcecode":"/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * \t\tThe index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index) {\r\n    return ((PlyNotation) (_plies.get(index)));\r\n}"},
 {"id":264, "parametername":"de.java_chess.javaChess.notation.PlyNotation", "parametertype":"de.java_chess.javaChess.notation.PlyNotation", "parameterclass":57, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":421, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.getPlyNotation(int)", "isreturn":1, "sourcecode":"/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * \t\tThe index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index) {\r\n    return ((PlyNotation) (_plies.get(index)));\r\n}"},
 {"id":265, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":419, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.getPlayerInfo(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Get some info on a player.\r\n *\r\n * @return Some info on a player.\r\n */\r\npublic final String getPlayerInfo(boolean white) {\r\n    return _playerInfo[(white ? 1 : 0)];\r\n}"},
 {"id":266, "parametername":"String playerInfo", "parametertype":"java.lang.String", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":425, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.setPlayerInfo(java.lang.String,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the info on a player.\r\n *\r\n * @param playerInfo\r\n * \t\tThe player info.\r\n * @param white\r\n * \t\tFlag to indicate, if its the player\r\n * \t\twith the white pieces.\r\n */\r\npublic final void setPlayerInfo(String playerInfo, boolean white) {\r\n    _playerInfo[(white ? 1 : 0)] = playerInfo;\r\n}"},
 {"id":267, "parametername":"boolean white", "parametertype":"boolean", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":425, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.setPlayerInfo(java.lang.String,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the info on a player.\r\n *\r\n * @param playerInfo\r\n * \t\tThe player info.\r\n * @param white\r\n * \t\tFlag to indicate, if its the player\r\n * \t\twith the white pieces.\r\n */\r\npublic final void setPlayerInfo(String playerInfo, boolean white) {\r\n    _playerInfo[(white ? 1 : 0)] = playerInfo;\r\n}"},
 {"id":268, "parametername":"String name", "parametertype":"java.lang.String", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":424, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.setOpeningInfo(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Set the info on the used opening.\r\n *\r\n * @param name\r\n * \t\tThe name of the opening.\r\n */\r\npublic final void setOpeningInfo(String name) {\r\n    _openingName = name;\r\n}"},
 {"id":269, "parametername":"NotationPanel notationPanel", "parametertype":"de.java_chess.javaChess.renderer2d.NotationPanel", "parameterclass":92, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":423, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)", "isreturn":0, "sourcecode":"/**\r\n * Set the panel for the notation output.\r\n *\r\n * @param notationPanel\r\n * \t\tThe panel for the output.\r\n */\r\npublic final void setNotationPanel(NotationPanel notationPanel) {\r\n    _notationPanel = notationPanel;\r\n}"},
 {"id":270, "parametername":"Piece piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":57, "classname":"de.java_chess.javaChess.notation.PlyNotation", "methodid":436, "methodname":"de.java_chess.javaChess.notation.PlyNotation.setPiece(de.java_chess.javaChess.piece.Piece)", "isreturn":0, "sourcecode":"/**\r\n * Set the piece, that is moved with this ply.\r\n *\r\n * @param ply\r\n * \t\tThe moved ply.\r\n */\r\nvoid setPiece(Piece piece);"},
 {"id":271, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":57, "classname":"de.java_chess.javaChess.notation.PlyNotation", "methodid":437, "methodname":"de.java_chess.javaChess.notation.PlyNotation.setPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Set the ply for this notation.\r\n *\r\n * @param ply\r\n * \t\tThe ply for this notation.\r\n */\r\nvoid setPly(Ply ply);"},
 {"id":272, "parametername":"boolean check", "parametertype":"boolean", "parameterclass":0, "classid":57, "classname":"de.java_chess.javaChess.notation.PlyNotation", "methodid":434, "methodname":"de.java_chess.javaChess.notation.PlyNotation.setCheck(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the flag for a check.\r\n *\r\n * @param check,\r\n * \t\ttrue if the oppenent is in check.\r\n */\r\nvoid setCheck(boolean check);"},
 {"id":273, "parametername":"boolean checkMate", "parametertype":"boolean", "parameterclass":0, "classid":57, "classname":"de.java_chess.javaChess.notation.PlyNotation", "methodid":435, "methodname":"de.java_chess.javaChess.notation.PlyNotation.setCheckMate(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the flag for a checkmate.\r\n *\r\n * @param check,\r\n * \t\ttrue if the oppenent is checkmate.\r\n */\r\nvoid setCheckMate(boolean checkMate);"},
 {"id":274, "parametername":"byte pieceType", "parametertype":"byte", "parameterclass":0, "classid":57, "classname":"de.java_chess.javaChess.notation.PlyNotation", "methodid":429, "methodname":"de.java_chess.javaChess.notation.PlyNotation.getPieceTypeNotation(byte)", "isreturn":0, "sourcecode":"/**\r\n * Get the notation for a piece type.\r\n *\r\n * @param pieceType\r\n * \t\tThe piece type.\r\n * @return The notation for a piece type.\r\n */\r\nString getPieceTypeNotation(byte pieceType);"},
 {"id":275, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":439, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.piece.Piece)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new ply notation instance.\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n * @param piece\r\n * \t\tThe moved piece.\r\n */\r\npublic PlyNotationImpl(Ply ply, Piece piece) {\r\n    setPly(ply);\r\n    setPiece(piece);\r\n    // Render the string representation only once and not during\r\n    // the toString() call.\r\n    computeStringRepresentation();\r\n}"},
 {"id":276, "parametername":"Piece piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":439, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.piece.Piece)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new ply notation instance.\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n * @param piece\r\n * \t\tThe moved piece.\r\n */\r\npublic PlyNotationImpl(Ply ply, Piece piece) {\r\n    setPly(ply);\r\n    setPiece(piece);\r\n    // Render the string representation only once and not during\r\n    // the toString() call.\r\n    computeStringRepresentation();\r\n}"},
 {"id":277, "parametername":"Piece piece", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":449, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.setPiece(de.java_chess.javaChess.piece.Piece)", "isreturn":0, "sourcecode":"/**\r\n * Set the piece, that is moved with this ply.\r\n *\r\n * @param ply\r\n * \t\tThe moved ply.\r\n */\r\npublic final void setPiece(Piece piece) {\r\n    _piece = piece;\r\n}"},
 {"id":278, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":450, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.setPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Set the ply for this notation.\r\n *\r\n * @param ply\r\n * \t\tThe ply for this notation.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":279, "parametername":"boolean check", "parametertype":"boolean", "parameterclass":0, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":447, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.setCheck(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the flag for a check.\r\n *\r\n * @param check,\r\n * \t\ttrue if the oppenent is in check.\r\n */\r\npublic final void setCheck(boolean check) {\r\n    _check = check;\r\n    // If we are not in check, we are also no checkmate.\r\n    if (check == false) {\r\n        setCheckMate(false);\r\n    }\r\n    // Recompute the string representation to make sure, that\r\n    // it is still correct.\r\n    computeStringRepresentation();\r\n}"},
 {"id":280, "parametername":"boolean checkMate", "parametertype":"boolean", "parameterclass":0, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":448, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.setCheckMate(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the flag for a checkmate.\r\n *\r\n * @param check,\r\n * \t\ttrue if the oppenent is checkmate.\r\n */\r\npublic final void setCheckMate(boolean checkMate) {\r\n    _checkMate = checkMate;\r\n    // If the opponent is checkmate, he is also in check.\r\n    if (checkMate == true) {\r\n        setCheck(true);\r\n    }\r\n}"},
 {"id":281, "parametername":"byte pieceType", "parametertype":"byte", "parameterclass":0, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":442, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.getPieceTypeNotation(byte)", "isreturn":0, "sourcecode":"/**\r\n * Get the notation for a piece type.\r\n *\r\n * @return The notation for a piece type.\r\n */\r\npublic final String getPieceTypeNotation(byte pieceType) {\r\n    String notation = \"\";// The result;\r\n\r\n    // Convert the piece type to a string.\r\n    switch (pieceType) {\r\n        case Piece.PAWN :\r\n            notation = \"P\";\r\n            break;\r\n        case Piece.KNIGHT :\r\n            notation = \"N\";\r\n            break;\r\n        case Piece.BISHOP :\r\n            notation = \"B\";\r\n            break;\r\n        case Piece.ROOK :\r\n            notation = \"R\";\r\n            break;\r\n        case Piece.QUEEN :\r\n            notation = \"Q\";\r\n            break;\r\n        case Piece.KING :\r\n            notation = \"K\";\r\n            break;\r\n    }\r\n    return notation;\r\n}"},
 {"id":282, "parametername":"PGNPlyFragment plyFragment", "parametertype":"de.java_chess.javaChess.pgn.PGNPlyFragment", "parameterclass":65, "classid":59, "classname":"de.java_chess.javaChess.pgn.GameLoader", "methodid":453, "methodname":"de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * \t\tThe info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}"},
 {"id":283, "parametername":"de.java_chess.javaChess.notation.PlyNotation", "parametertype":"de.java_chess.javaChess.notation.PlyNotation", "parameterclass":57, "classid":59, "classname":"de.java_chess.javaChess.pgn.GameLoader", "methodid":453, "methodname":"de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * \t\tThe info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}"},
 {"id":284, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":59, "classname":"de.java_chess.javaChess.pgn.GameLoader", "methodid":454, "methodname":"de.java_chess.javaChess.pgn.GameLoader.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Perform a ply, when it is completely loaded.\r\n *\r\n * param ply The ply to perform.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n    // The other color is about to move now.\r\n    _whiteMoves = !(_whiteMoves);\r\n}"},
 {"id":285, "parametername":"Reader reader", "parametertype":"java.io.Reader", "parameterclass":0, "classid":60, "classname":"de.java_chess.javaChess.pgn.PGNFile", "methodid":455, "methodname":"de.java_chess.javaChess.pgn.PGNFile.-init-(java.io.Reader)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance.\r\n *\r\n * @param reader\r\n * \t\tThe reader for the file.\r\n */\r\npublic PGNFile(Reader reader) {\r\n    setReader(reader);\r\n}"},
 {"id":286, "parametername":"Reader reader", "parametertype":"java.io.Reader", "parameterclass":0, "classid":60, "classname":"de.java_chess.javaChess.pgn.PGNFile", "methodid":460, "methodname":"de.java_chess.javaChess.pgn.PGNFile.setReader(java.io.Reader)", "isreturn":0, "sourcecode":"/**\r\n * Set a new reader for a file.\r\n *\r\n * @param reader\r\n * \t\tThe new reader.\r\n */\r\nprivate final void setReader(Reader reader) {\r\n    _reader = reader;\r\n}"},
 {"id":287, "parametername":"PGNParser parser", "parametertype":"de.java_chess.javaChess.pgn.PGNParser", "parameterclass":64, "classid":60, "classname":"de.java_chess.javaChess.pgn.PGNFile", "methodid":459, "methodname":"de.java_chess.javaChess.pgn.PGNFile.setPGNParser(de.java_chess.javaChess.pgn.PGNParser)", "isreturn":0, "sourcecode":"/**\r\n * Set the current parser.\r\n *\r\n * @param parser\r\n * \t\tThe new PGN parser.\r\n */\r\nprivate final void setPGNParser(PGNParser parser) {\r\n    _parser = parser;\r\n}"},
 {"id":288, "parametername":"File file", "parametertype":"java.io.File", "parameterclass":0, "classid":61, "classname":"de.java_chess.javaChess.pgn.PGNFileFilter", "methodid":462, "methodname":"de.java_chess.javaChess.pgn.PGNFileFilter.accept(java.io.File)", "isreturn":0, "sourcecode":"// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Check if the given file is a PGN file.\r\n *\r\n * @param file\r\n * \t\tThe file to check.\r\n * @return true, if the file is a PGN file, false otherwise.\r\n */\r\npublic boolean accept(File file) {\r\n    if (file == null) {\r\n        return false;\r\n    }\r\n    String filename = file.getName();\r\n    int i = filename.lastIndexOf(.);\r\n    if ((i > 0) && (i < ((filename.length()) - 1))) {\r\n        return \"pgn\".equalsIgnoreCase(filename.substring((i + 1)).toLowerCase());\r\n    }\r\n    return false;\r\n}"},
 {"id":289, "parametername":"InputStream in", "parametertype":"java.io.InputStream", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":464, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.-init-(java.io.InputStream)", "isreturn":0, "sourcecode":"public PGNLexer(InputStream in) {\r\n    this(new ByteBuffer(in));\r\n}"},
 {"id":290, "parametername":"Reader in", "parametertype":"java.io.Reader", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":465, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.-init-(java.io.Reader)", "isreturn":0, "sourcecode":"public PGNLexer(Reader in) {\r\n    this(new CharBuffer(in));\r\n}"},
 {"id":291, "parametername":"InputBuffer ib", "parametertype":"antlr.InputBuffer", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":466, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.-init-(antlr.InputBuffer)", "isreturn":0, "sourcecode":"public PGNLexer(InputBuffer ib) {\r\n    this(new antlr.LexerSharedInputState(ib));\r\n}"},
 {"id":292, "parametername":"LexerSharedInputState state", "parametertype":"antlr.LexerSharedInputState", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":467, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.-init-(antlr.LexerSharedInputState)", "isreturn":0, "sourcecode":"public PGNLexer(LexerSharedInputState state) {\r\n    super(state);\r\n    literals = new Hashtable();\r\n    caseSensitiveLiterals = true;\r\n    setCaseSensitive(true);\r\n}"},
 {"id":293, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":489, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mWS(boolean)", "isreturn":0, "sourcecode":"public final void mWS(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.WS;\r\n    int _saveIndex;\r\n    {\r\n        switch (LA(1)) {\r\n            case   :\r\n                {\r\n                    match( );\r\n                    break;\r\n                }\r\n            case \t :\r\n                {\r\n                    match(\t);\r\n                    break;\r\n                }\r\n            case f :\r\n                {\r\n                    match(f);\r\n                    break;\r\n                }\r\n            case \n :\r\n            case \r :\r\n                {\r\n                    {\r\n                        if (((LA(1)) == \r) && ((LA(2)) == \n)) {\r\n                            match(\"\r\n\");\r\n                        } else\r\n                            if (((LA(1)) == \r) && true) {\r\n                                match(\r);\r\n                            } else\r\n                                if ((LA(1)) == \n) {\r\n                                    match(\n);\r\n                                } else {\r\n                                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                                }\r\n\r\n\r\n                    }\r\n                    newline();\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                }\r\n        }\r\n    }\r\n    /* $setType(Token.SKIP); */\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":294, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":468, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mDOT(boolean)", "isreturn":0, "sourcecode":"public final void mDOT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.DOT;\r\n    int _saveIndex;\r\n    match(.);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":295, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":471, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mLBRACK(boolean)", "isreturn":0, "sourcecode":"public final void mLBRACK(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.LBRACK;\r\n    int _saveIndex;\r\n    match([);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":296, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":476, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mRBRACK(boolean)", "isreturn":0, "sourcecode":"public final void mRBRACK(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.RBRACK;\r\n    int _saveIndex;\r\n    match(]);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":297, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":478, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mSL_COMMENT(boolean)", "isreturn":0, "sourcecode":"public final void mSL_COMMENT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.SL_COMMENT;\r\n    int _saveIndex;\r\n    match(\";\");\r\n    {\r\n        _loop39 : do {\r\n            if (PGNLexer._tokenSet_2.member(LA(1))) {\r\n                {\r\n                    match(PGNLexer._tokenSet_2);\r\n                }\r\n            } else {\r\n                break _loop39;\r\n            }\r\n        } while (true );\r\n    }\r\n    {\r\n        if (((LA(1)) == \r) && ((LA(2)) == \n)) {\r\n            match(\"\r\n\");\r\n        } else\r\n            if ((LA(1)) == \n) {\r\n                match(\"\n\");\r\n            } else\r\n                if (((LA(1)) == \r) && true) {\r\n                    match(\"\r\");\r\n                } else {\r\n                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                }\r\n\r\n\r\n    }\r\n    _ttype = Token.SKIP;\r\n    newline();\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":298, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":480, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mSTRING_LITERAL(boolean)", "isreturn":0, "sourcecode":"public final void mSTRING_LITERAL(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.STRING_LITERAL;\r\n    int _saveIndex;\r\n    {\r\n        match(\");\r\n        {\r\n            _loop45 : do {\r\n                if (PGNLexer._tokenSet_3.member(LA(1))) {\r\n                    {\r\n                        match(PGNLexer._tokenSet_3);\r\n                    }\r\n                } else {\r\n                    break _loop45;\r\n                }\r\n            } while (true );\r\n        }\r\n        match(\");\r\n    }\r\n    // Remove the leadind and trailing quote.\r\n    String literal = new String(text.getBuffer(), _begin, ((text.length()) - _begin));\r\n    literal = ((literal.length()) == 2) ? \"\" : literal.substring(1, ((literal.length()) - 2));\r\n    text.setLength(_begin);\r\n    text.append(literal);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":299, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":479, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mSQUARE_NAME(boolean)", "isreturn":0, "sourcecode":"public final void mSQUARE_NAME(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.SQUARE_NAME;\r\n    int _saveIndex;\r\n    matchRange(a, h);\r\n    matchRange(1, 8);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":300, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":475, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mPIECE_MOVE(boolean)", "isreturn":0, "sourcecode":"public final void mPIECE_MOVE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.PIECE_MOVE;\r\n    int _saveIndex;\r\n    match(-);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":301, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":474, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mPIECE_CAPTURE(boolean)", "isreturn":0, "sourcecode":"public final void mPIECE_CAPTURE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.PIECE_CAPTURE;\r\n    int _saveIndex;\r\n    match(x);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":302, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":473, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mPAWN_PROMOTION(boolean)", "isreturn":0, "sourcecode":"public final void mPAWN_PROMOTION(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.PAWN_PROMOTION;\r\n    int _saveIndex;\r\n    match(=);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":303, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":469, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mFIGURINE_LETTER_CODE(boolean)", "isreturn":0, "sourcecode":"public final void mFIGURINE_LETTER_CODE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.FIGURINE_LETTER_CODE;\r\n    int _saveIndex;\r\n    {\r\n        switch (LA(1)) {\r\n            case P :\r\n                {\r\n                    match(P);\r\n                    break;\r\n                }\r\n            case N :\r\n                {\r\n                    match(N);\r\n                    break;\r\n                }\r\n            case B :\r\n                {\r\n                    match(B);\r\n                    break;\r\n                }\r\n            case R :\r\n                {\r\n                    match(R);\r\n                    break;\r\n                }\r\n            case Q :\r\n                {\r\n                    match(Q);\r\n                    break;\r\n                }\r\n            case K :\r\n                {\r\n                    match(K);\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                }\r\n        }\r\n    }\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":304, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":477, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mRIGHT_CASTLING(boolean)", "isreturn":0, "sourcecode":"public final void mRIGHT_CASTLING(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.RIGHT_CASTLING;\r\n    int _saveIndex;\r\n    match(\"O-O\");\r\n    {\r\n        if ((LA(1)) == -) {\r\n            match(\"-O\");\r\n            _ttype = PGNTokenTypes.LEFT_CASTLING;\r\n        } else {\r\n        }\r\n    }\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":305, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":472, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mMOVE_INDEX(boolean)", "isreturn":0, "sourcecode":"public final void mMOVE_INDEX(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.MOVE_INDEX;\r\n    int _saveIndex;\r\n    {\r\n        matchRange(1, 9);\r\n        {\r\n            _loop57 : do {\r\n                if (((LA(1)) >= 0) && ((LA(1)) <= 9)) {\r\n                    matchRange(0, 9);\r\n                } else {\r\n                    break _loop57;\r\n                }\r\n            } while (true );\r\n        }\r\n        mDOT(false);\r\n    }\r\n    // Remove the trailing dot.\r\n    String index = new String(text.getBuffer(), _begin, ((text.length()) - _begin));\r\n    index = index.substring(0, ((index.length()) - 1));\r\n    text.setLength(_begin);\r\n    text.append(index);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":306, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":488, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_WHITE(boolean)", "isreturn":0, "sourcecode":"public final void mTAG_WHITE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_WHITE;\r\n    int _saveIndex;\r\n    match(\"White\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":307, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":481, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_BLACK(boolean)", "isreturn":0, "sourcecode":"public final void mTAG_BLACK(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_BLACK;\r\n    int _saveIndex;\r\n    match(\"Black\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":308, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":482, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_DATE(boolean)", "isreturn":0, "sourcecode":"public final void mTAG_DATE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_DATE;\r\n    int _saveIndex;\r\n    match(\"Date\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":309, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":483, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_EVENT(boolean)", "isreturn":0, "sourcecode":"public final void mTAG_EVENT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_EVENT;\r\n    int _saveIndex;\r\n    match(\"Event\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":310, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":487, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_SITE(boolean)", "isreturn":0, "sourcecode":"public final void mTAG_SITE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_SITE;\r\n    int _saveIndex;\r\n    match(\"Site\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":311, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":486, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_ROUND(boolean)", "isreturn":0, "sourcecode":"public final void mTAG_ROUND(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_ROUND;\r\n    int _saveIndex;\r\n    match(\"Round\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":312, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":485, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_RESULT(boolean)", "isreturn":0, "sourcecode":"public final void mTAG_RESULT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_RESULT;\r\n    int _saveIndex;\r\n    match(\"Result\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":313, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":484, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_OPENING(boolean)", "isreturn":0, "sourcecode":"public final void mTAG_OPENING(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_OPENING;\r\n    int _saveIndex;\r\n    match(\"Opening\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":314, "parametername":"boolean _createToken", "parametertype":"boolean", "parameterclass":0, "classid":62, "classname":"de.java_chess.javaChess.pgn.PGNLexer", "methodid":470, "methodname":"de.java_chess.javaChess.pgn.PGNLexer.mGAME_TERMINATOR(boolean)", "isreturn":0, "sourcecode":"public final void mGAME_TERMINATOR(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.GAME_TERMINATOR;\r\n    int _saveIndex;\r\n    {\r\n        switch (LA(1)) {\r\n            case * :\r\n                {\r\n                    match(\"*\");\r\n                    break;\r\n                }\r\n            case 0 :\r\n                {\r\n                    match(\"0-1\");\r\n                    break;\r\n                }\r\n            default :\r\n                if (((LA(1)) == 1) && ((LA(2)) == -)) {\r\n                    match(\"1-0\");\r\n                } else\r\n                    if (((LA(1)) == 1) && ((LA(2)) == /)) {\r\n                        match(\"1/2-1/2\");\r\n                    } else {\r\n                        throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                    }\r\n\r\n        }\r\n    }\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":315, "parametername":"File file", "parametertype":"java.io.File", "parameterclass":0, "classid":63, "classname":"de.java_chess.javaChess.pgn.PGNOutputStream", "methodid":491, "methodname":"de.java_chess.javaChess.pgn.PGNOutputStream.-init-(java.io.File)", "isreturn":0, "sourcecode":"// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new PGNOutputStream instance.\r\n *\r\n * @param file\r\n * \t\tThe file to write into.\r\n */\r\npublic PGNOutputStream(File file) throws IOException {\r\n    super(file);\r\n}"},
 {"id":316, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":63, "classname":"de.java_chess.javaChess.pgn.PGNOutputStream", "methodid":492, "methodname":"de.java_chess.javaChess.pgn.PGNOutputStream.write(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Write the notation of a game.\r\n *\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n */\r\npublic final void write(GameNotation gameNotation) throws IOException {\r\n    // Check, if there is some header available.\r\n    String header = gameNotation.getPGNheader();\r\n    if (!(\"\".equals(header))) {\r\n        header += \"\n\";\r\n        write(header.getBytes());\r\n    }\r\n    write(gameNotation.toString().getBytes());\r\n}"},
 {"id":317, "parametername":"TokenBuffer tokenBuf", "parametertype":"antlr.TokenBuffer", "parameterclass":0, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":493, "methodname":"de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenBuffer,int)", "isreturn":0, "sourcecode":"protected PGNParser(TokenBuffer tokenBuf, int k) {\r\n    super(tokenBuf, k);\r\n    tokenNames = PGNParser._tokenNames;\r\n}"},
 {"id":318, "parametername":"int k", "parametertype":"int", "parameterclass":0, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":493, "methodname":"de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenBuffer,int)", "isreturn":0, "sourcecode":"protected PGNParser(TokenBuffer tokenBuf, int k) {\r\n    super(tokenBuf, k);\r\n    tokenNames = PGNParser._tokenNames;\r\n}"},
 {"id":319, "parametername":"TokenBuffer tokenBuf", "parametertype":"antlr.TokenBuffer", "parameterclass":0, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":494, "methodname":"de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenBuffer)", "isreturn":0, "sourcecode":"public PGNParser(TokenBuffer tokenBuf) {\r\n    this(tokenBuf, 2);\r\n}"},
 {"id":320, "parametername":"TokenStream lexer", "parametertype":"antlr.TokenStream", "parameterclass":0, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":495, "methodname":"de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenStream,int)", "isreturn":0, "sourcecode":"protected PGNParser(TokenStream lexer, int k) {\r\n    super(lexer, k);\r\n    tokenNames = PGNParser._tokenNames;\r\n}"},
 {"id":321, "parametername":"int k", "parametertype":"int", "parameterclass":0, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":495, "methodname":"de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenStream,int)", "isreturn":0, "sourcecode":"protected PGNParser(TokenStream lexer, int k) {\r\n    super(lexer, k);\r\n    tokenNames = PGNParser._tokenNames;\r\n}"},
 {"id":322, "parametername":"TokenStream lexer", "parametertype":"antlr.TokenStream", "parameterclass":0, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":496, "methodname":"de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenStream)", "isreturn":0, "sourcecode":"public PGNParser(TokenStream lexer) {\r\n    this(lexer, 2);\r\n}"},
 {"id":323, "parametername":"ParserSharedInputState state", "parametertype":"antlr.ParserSharedInputState", "parameterclass":0, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":497, "methodname":"de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.ParserSharedInputState)", "isreturn":0, "sourcecode":"public PGNParser(ParserSharedInputState state) {\r\n    super(state, 2);\r\n    tokenNames = PGNParser._tokenNames;\r\n}"},
 {"id":324, "parametername":"GameNotation notation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":511, "methodname":"de.java_chess.javaChess.pgn.PGNParser.setNotation(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"/**\r\n * Set a new buffer for the game notation.\r\n *\r\n * @param notation\r\n * \t\tThe new notation buffer.\r\n */\r\npublic final void setNotation(GameNotation notation) {\r\n    _notation = notation;\r\n}"},
 {"id":325, "parametername":"GameLoader loader", "parametertype":"de.java_chess.javaChess.pgn.GameLoader", "parameterclass":59, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":510, "methodname":"de.java_chess.javaChess.pgn.PGNParser.setGameLoader(de.java_chess.javaChess.pgn.GameLoader)", "isreturn":0, "sourcecode":"/**\r\n * Set a new game loader.\r\n *\r\n * @param loader\r\n * \t\tThe new game loader.\r\n */\r\nprivate final void setGameLoader(GameLoader loader) {\r\n    _gameLoader = loader;\r\n}"},
 {"id":326, "parametername":"GameNotation notationBuffer", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":506, "methodname":"de.java_chess.javaChess.pgn.PGNParser.pgnGame(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"public final void pgnGame(GameNotation notationBuffer) throws RecognitionException, TokenStreamException {\r\n    setNotation(notationBuffer);\r\n    setGameLoader(new GameLoader());\r\n    whiteSpaces();\r\n    tagPairSection();\r\n    moveTextSection();\r\n}"},
 {"id":327, "parametername":"char letter", "parametertype":"char", "parameterclass":0, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":534, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.setPieceTypeFromLetter(char)", "isreturn":0, "sourcecode":"// Constructors\r\n// Methods\r\n/**\r\n * Set the piece type from a figurine letter code.\r\n *\r\n * @param letter\r\n * \t\tThe figurine letter code.\r\n */\r\npublic final void setPieceTypeFromLetter(char letter) {\r\n    setPieceType(getPieceTypeFromLetter(letter));\r\n}"},
 {"id":328, "parametername":"String squareName", "parametertype":"java.lang.String", "parameterclass":0, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":531, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.setOrigin(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Set the name of the origin square.\r\n *\r\n * @param squareName\r\n * \t\tThe name of the origin square.\r\n */\r\npublic final void setOrigin(String squareName) {\r\n    // Create a new position implementation from the name and store it.\r\n    _origin = new PositionImpl(squareName);\r\n}"},
 {"id":329, "parametername":"Position position", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":530, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.setOrigin(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the name of the origin square.\r\n *\r\n * @param position\r\n * \t\tThe position of the origin square.\r\n */\r\npublic final void setOrigin(Position position) {\r\n    // Store the position.\r\n    _origin = position;\r\n}"},
 {"id":330, "parametername":"String squareName", "parametertype":"java.lang.String", "parameterclass":0, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":529, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.setDestination(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Set the name of the destination square.\r\n *\r\n * @param squareName\r\n * \t\tThe name of the destination square.\r\n */\r\npublic final void setDestination(String squareName) {\r\n    // Create a new position implementation from the name and store it.\r\n    _destination = new PositionImpl(squareName);\r\n}"},
 {"id":331, "parametername":"boolean capture", "parametertype":"boolean", "parameterclass":0, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":527, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.setCapture(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the flag, if this move captures a piece.\r\n *\r\n * @param capture\r\n * \t\ttrue, if this move capures a piece.\r\n */\r\npublic final void setCapture(boolean capture) {\r\n    _capture = capture;\r\n}"},
 {"id":332, "parametername":"char newPieceTypeLetter", "parametertype":"char", "parameterclass":0, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":532, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.setPawnPromotion(char)", "isreturn":0, "sourcecode":"/**\r\n * Make this ply a pawn promotion and set the piece type after the promotion.\r\n *\r\n * @param newPieceTypeLetter\r\n * \t\tThe piece type after the pawn promotion as a figurine letter code.\r\n */\r\npublic final void setPawnPromotion(char newPieceTypeLetter) {\r\n    _pawnPromotion = true;\r\n    _newPieceType = getPieceTypeFromLetter(newPieceTypeLetter);\r\n}"},
 {"id":333, "parametername":"boolean left", "parametertype":"boolean", "parameterclass":0, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":528, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.setCastling(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set this ply as a castling.\r\n *\r\n * @param goesLeft\r\n * \t\ttrue, if the castling goes to the left.\r\n */\r\npublic final void setCastling(boolean left) {\r\n    _castling = true;\r\n    _leftCastling = left;\r\n}"},
 {"id":334, "parametername":"byte type", "parametertype":"byte", "parameterclass":0, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":533, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.setPieceType(byte)", "isreturn":0, "sourcecode":"/**\r\n * Set the type of the moved piece.\r\n *\r\n * @param type\r\n * \t\tThe type of the moved piece.\r\n */\r\nprivate final void setPieceType(byte type) {\r\n    _pieceType = type;\r\n}"},
 {"id":335, "parametername":"char letter", "parametertype":"char", "parameterclass":0, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":522, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)", "isreturn":0, "sourcecode":"/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * \t\tThe figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}"},
 {"id":336, "parametername":"byte type", "parametertype":"byte", "parameterclass":0, "classid":67, "classname":"de.java_chess.javaChess.piece.Piece", "methodid":540, "methodname":"de.java_chess.javaChess.piece.Piece.setType(byte)", "isreturn":0, "sourcecode":"/**\r\n * Set the type of this piece.\r\n *\r\n * @param type\r\n * \t\tThe new type of this piece.\r\n */\r\npublic void setType(byte type);"},
 {"id":337, "parametername":"byte color", "parametertype":"byte", "parameterclass":0, "classid":67, "classname":"de.java_chess.javaChess.piece.Piece", "methodid":539, "methodname":"de.java_chess.javaChess.piece.Piece.setColor(byte)", "isreturn":0, "sourcecode":"/**\r\n * Set the color of this piece.\r\n *\r\n * @param The\r\n * \t\tnew color of this piece.\r\n */\r\npublic void setColor(byte color);"},
 {"id":338, "parametername":"byte typeColor", "parametertype":"byte", "parameterclass":0, "classid":68, "classname":"de.java_chess.javaChess.piece.PieceImpl", "methodid":541, "methodname":"de.java_chess.javaChess.piece.PieceImpl.-init-(byte)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new piece instance.\r\n *\r\n * @param typeColor\r\n * \t\tThe color and type of piece, with color in bit 0\r\n * \t\tand the type color in bit 1-3.\r\n */\r\npublic PieceImpl(byte typeColor) {\r\n    _typeColor = typeColor;\r\n}"},
 {"id":339, "parametername":"byte type", "parametertype":"byte", "parameterclass":0, "classid":68, "classname":"de.java_chess.javaChess.piece.PieceImpl", "methodid":542, "methodname":"de.java_chess.javaChess.piece.PieceImpl.-init-(byte,byte)", "isreturn":0, "sourcecode":"/**\r\n * Create a new Piece instance from type and color.\r\n *\r\n * @param type\r\n * \t\tThe type of the piece.\r\n * @param color\r\n * \t\tThe color of the piece.\r\n */\r\npublic PieceImpl(byte type, byte color) {\r\n    this(((byte) ((type << 1) + color)));\r\n}"},
 {"id":340, "parametername":"byte color", "parametertype":"byte", "parameterclass":0, "classid":68, "classname":"de.java_chess.javaChess.piece.PieceImpl", "methodid":542, "methodname":"de.java_chess.javaChess.piece.PieceImpl.-init-(byte,byte)", "isreturn":0, "sourcecode":"/**\r\n * Create a new Piece instance from type and color.\r\n *\r\n * @param type\r\n * \t\tThe type of the piece.\r\n * @param color\r\n * \t\tThe color of the piece.\r\n */\r\npublic PieceImpl(byte type, byte color) {\r\n    this(((byte) ((type << 1) + color)));\r\n}"},
 {"id":341, "parametername":"byte type", "parametertype":"byte", "parameterclass":0, "classid":68, "classname":"de.java_chess.javaChess.piece.PieceImpl", "methodid":548, "methodname":"de.java_chess.javaChess.piece.PieceImpl.setType(byte)", "isreturn":0, "sourcecode":"/**\r\n * Set the type of this piece.\r\n *\r\n * @param type\r\n * \t\tThe type of this piece as defined as\r\n * \t\tconstants in the Piece interface.\r\n */\r\npublic final void setType(byte type) {\r\n    _typeColor &= ((byte) (1));\r\n    _typeColor |= type << 1;\r\n}"},
 {"id":342, "parametername":"byte color", "parametertype":"byte", "parameterclass":0, "classid":68, "classname":"de.java_chess.javaChess.piece.PieceImpl", "methodid":547, "methodname":"de.java_chess.javaChess.piece.PieceImpl.setColor(byte)", "isreturn":0, "sourcecode":"/**\r\n * Set the color of this piece.\r\n *\r\n * @param The\r\n * \t\tnew color of this piece.\r\n */\r\npublic final void setColor(byte color) {\r\n    _typeColor &= ((byte) (14));\r\n    _typeColor |= color;\r\n}"},
 {"id":343, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":69, "classname":"de.java_chess.javaChess.ply.AnalyzedPly", "methodid":552, "methodname":"de.java_chess.javaChess.ply.AnalyzedPly.setPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Set a new ply.\r\n *\r\n * @param ply\r\n * \t\tThe new ply.\r\n */\r\nvoid setPly(Ply ply);"},
 {"id":344, "parametername":"short score", "parametertype":"short", "parameterclass":0, "classid":69, "classname":"de.java_chess.javaChess.ply.AnalyzedPly", "methodid":553, "methodname":"de.java_chess.javaChess.ply.AnalyzedPly.setScore(short)", "isreturn":0, "sourcecode":"/**\r\n * Set a new scrore for this ply.\r\n *\r\n * @param score\r\n * \t\tThe new score for this ply.\r\n */\r\nvoid setScore(short score);"},
 {"id":345, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":70, "classname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl", "methodid":554, "methodname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.-init-(de.java_chess.javaChess.ply.Ply,short)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new AnalyzedPly instance.\r\n */\r\npublic AnalyzedPlyImpl(Ply ply, short score) {\r\n    setPly(ply);\r\n    setScore(score);\r\n}"},
 {"id":346, "parametername":"short score", "parametertype":"short", "parameterclass":0, "classid":70, "classname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl", "methodid":554, "methodname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.-init-(de.java_chess.javaChess.ply.Ply,short)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new AnalyzedPly instance.\r\n */\r\npublic AnalyzedPlyImpl(Ply ply, short score) {\r\n    setPly(ply);\r\n    setScore(score);\r\n}"},
 {"id":347, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":70, "classname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl", "methodid":558, "methodname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.setPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Set a new ply.\r\n *\r\n * @param ply\r\n * \t\tThe new ply.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":348, "parametername":"short score", "parametertype":"short", "parameterclass":0, "classid":70, "classname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl", "methodid":559, "methodname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.setScore(short)", "isreturn":0, "sourcecode":"/**\r\n * Set a new scrore for this ply.\r\n *\r\n * @param score\r\n * \t\tThe new score for this ply.\r\n */\r\npublic final void setScore(short score) {\r\n    _score = score;\r\n}"},
 {"id":349, "parametername":"boolean goesLeft", "parametertype":"boolean", "parameterclass":0, "classid":71, "classname":"de.java_chess.javaChess.ply.CastlingPly", "methodid":561, "methodname":"de.java_chess.javaChess.ply.CastlingPly.setLeftCastling(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the flag, if the castling goes left.\r\n *\r\n * @param goesLeft\r\n * \t\tFlag to indicate if the castling goes left.\r\n */\r\nvoid setLeftCastling(boolean goesLeft);"},
 {"id":350, "parametername":"Position source", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":72, "classname":"de.java_chess.javaChess.ply.CastlingPlyImpl", "methodid":562, "methodname":"de.java_chess.javaChess.ply.CastlingPlyImpl.-init-(de.java_chess.javaChess.position.Position,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Construct a new castling ply from a source and a destination\r\n * and the direction.\r\n *\r\n * @param source\r\n * \t\tThe source of the ply.\r\n * @param destination\r\n * \t\tThe destination of the ply.\r\n * @param goesLeft\r\n * \t\tFlag to indicate if the castling goes left.\r\n */\r\npublic CastlingPlyImpl(Position source, boolean goesLeft) {\r\n    super(source, new PositionImpl((-1)), false);\r\n    setLeftCastling(goesLeft);\r\n}"},
 {"id":351, "parametername":"boolean goesLeft", "parametertype":"boolean", "parameterclass":0, "classid":72, "classname":"de.java_chess.javaChess.ply.CastlingPlyImpl", "methodid":562, "methodname":"de.java_chess.javaChess.ply.CastlingPlyImpl.-init-(de.java_chess.javaChess.position.Position,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Construct a new castling ply from a source and a destination\r\n * and the direction.\r\n *\r\n * @param source\r\n * \t\tThe source of the ply.\r\n * @param destination\r\n * \t\tThe destination of the ply.\r\n * @param goesLeft\r\n * \t\tFlag to indicate if the castling goes left.\r\n */\r\npublic CastlingPlyImpl(Position source, boolean goesLeft) {\r\n    super(source, new PositionImpl((-1)), false);\r\n    setLeftCastling(goesLeft);\r\n}"},
 {"id":352, "parametername":"boolean goesLeft", "parametertype":"boolean", "parameterclass":0, "classid":72, "classname":"de.java_chess.javaChess.ply.CastlingPlyImpl", "methodid":564, "methodname":"de.java_chess.javaChess.ply.CastlingPlyImpl.setLeftCastling(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the flag, if the castling goes left.\r\n *\r\n * @param goesLeft\r\n * \t\tFlag to indicate if the castling goes left.\r\n */\r\npublic final void setLeftCastling(boolean goesLeft) {\r\n    _goesLeft = goesLeft;\r\n}"},
 {"id":353, "parametername":"Position attackedPosition", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":73, "classname":"de.java_chess.javaChess.ply.EnPassantPly", "methodid":567, "methodname":"de.java_chess.javaChess.ply.EnPassantPly.setAttackedPosition(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the position of the attacked pawn.\r\n *\r\n * @param position\r\n * \t\tThe position of the attacked pawn.\r\n */\r\nvoid setAttackedPosition(Position attackedPosition);"},
 {"id":354, "parametername":"Position source", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":74, "classname":"de.java_chess.javaChess.ply.EnPassantPlyImpl", "methodid":568, "methodname":"de.java_chess.javaChess.ply.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square of the attacking pawn.\r\n * @param destination\r\n * \t\tThe destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * \t\tThe position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}"},
 {"id":355, "parametername":"Position destination", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":74, "classname":"de.java_chess.javaChess.ply.EnPassantPlyImpl", "methodid":568, "methodname":"de.java_chess.javaChess.ply.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square of the attacking pawn.\r\n * @param destination\r\n * \t\tThe destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * \t\tThe position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}"},
 {"id":356, "parametername":"Position attackedPosition", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":74, "classname":"de.java_chess.javaChess.ply.EnPassantPlyImpl", "methodid":568, "methodname":"de.java_chess.javaChess.ply.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square of the attacking pawn.\r\n * @param destination\r\n * \t\tThe destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * \t\tThe position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}"},
 {"id":357, "parametername":"Position attackedPosition", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":74, "classname":"de.java_chess.javaChess.ply.EnPassantPlyImpl", "methodid":570, "methodname":"de.java_chess.javaChess.ply.EnPassantPlyImpl.setAttackedPosition(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the position of the attacked pawn.\r\n *\r\n * @param position\r\n * \t\tThe position of the attacked pawn.\r\n */\r\npublic final void setAttackedPosition(Position attackedPosition) {\r\n    _attackedPosition = attackedPosition;\r\n}"},
 {"id":358, "parametername":"Position source", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":75, "classname":"de.java_chess.javaChess.ply.Ply", "methodid":576, "methodname":"de.java_chess.javaChess.ply.Ply.setSource(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the source of the ply.\r\n *\r\n * @param source\r\n * \t\tThe new source square for this ply.\r\n */\r\nvoid setSource(Position source);"},
 {"id":359, "parametername":"Position destination", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":75, "classname":"de.java_chess.javaChess.ply.Ply", "methodid":575, "methodname":"de.java_chess.javaChess.ply.Ply.setDestination(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the destination of the piece.\r\n *\r\n * @param destination\r\n * \t\tThe new destination square of this ply.\r\n */\r\nvoid setDestination(Position destination);"},
 {"id":360, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":75, "classname":"de.java_chess.javaChess.ply.Ply", "methodid":571, "methodname":"de.java_chess.javaChess.ply.Ply.equals(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * \t\tThe other ply.\r\n * @return true, if the 2 plies are equal. False otherwise.\r\n */\r\nboolean equals(Ply ply);"},
 {"id":361, "parametername":"Position source", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":577, "methodname":"de.java_chess.javaChess.ply.PlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Construct a new ply from a source and a destination.\r\n *\r\n * @param source\r\n * \t\tThe source of the ply.\r\n * @param destination\r\n * \t\tThe destination of the ply.\r\n * @param capture\r\n * \t\tFlag to indicate, if this ply captures another piece.\r\n */\r\npublic PlyImpl(Position source, Position destination, boolean capture) {\r\n    setSource(source);\r\n    setDestination(destination);\r\n    setCapture(capture);\r\n}"},
 {"id":362, "parametername":"Position destination", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":577, "methodname":"de.java_chess.javaChess.ply.PlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Construct a new ply from a source and a destination.\r\n *\r\n * @param source\r\n * \t\tThe source of the ply.\r\n * @param destination\r\n * \t\tThe destination of the ply.\r\n * @param capture\r\n * \t\tFlag to indicate, if this ply captures another piece.\r\n */\r\npublic PlyImpl(Position source, Position destination, boolean capture) {\r\n    setSource(source);\r\n    setDestination(destination);\r\n    setCapture(capture);\r\n}"},
 {"id":363, "parametername":"boolean capture", "parametertype":"boolean", "parameterclass":0, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":577, "methodname":"de.java_chess.javaChess.ply.PlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Construct a new ply from a source and a destination.\r\n *\r\n * @param source\r\n * \t\tThe source of the ply.\r\n * @param destination\r\n * \t\tThe destination of the ply.\r\n * @param capture\r\n * \t\tFlag to indicate, if this ply captures another piece.\r\n */\r\npublic PlyImpl(Position source, Position destination, boolean capture) {\r\n    setSource(source);\r\n    setDestination(destination);\r\n    setCapture(capture);\r\n}"},
 {"id":364, "parametername":"Position source", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":584, "methodname":"de.java_chess.javaChess.ply.PlyImpl.setSource(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the source of the ply.\r\n *\r\n * @param The\r\n * \t\tnew source of the piece.\r\n */\r\npublic final void setSource(Position source) {\r\n    _source = source;\r\n}"},
 {"id":365, "parametername":"Position destination", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":583, "methodname":"de.java_chess.javaChess.ply.PlyImpl.setDestination(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Set the destination of the piece.\r\n *\r\n * @param destination\r\n * \t\tThe new destination of the piece.\r\n */\r\npublic final void setDestination(Position destination) {\r\n    _destination = destination;\r\n}"},
 {"id":366, "parametername":"boolean capture", "parametertype":"boolean", "parameterclass":0, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":582, "methodname":"de.java_chess.javaChess.ply.PlyImpl.setCapture(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set a flag, if this ply captures another piece.\r\n *\r\n * @param capture\r\n * \t\tFlag to indicate if this ply captures another piece.\r\n */\r\npublic final void setCapture(boolean capture) {\r\n    _capture = capture;\r\n}"},
 {"id":367, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":578, "methodname":"de.java_chess.javaChess.ply.PlyImpl.equals(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * \t\tThe other ply.\r\n * @return true, if the 2 plies are equal.\r\n */\r\npublic final boolean equals(Ply ply) {\r\n    return (ply.getSource().equals(getSource())) && (ply.getDestination().equals(getDestination()));\r\n}"},
 {"id":368, "parametername":"byte pieceType", "parametertype":"byte", "parameterclass":0, "classid":77, "classname":"de.java_chess.javaChess.ply.TransformationPly", "methodid":587, "methodname":"de.java_chess.javaChess.ply.TransformationPly.setTypeAfterTransformation(byte)", "isreturn":0, "sourcecode":"/**\r\n * Set the new piece type after the transformation.\r\n *\r\n * @param pieceType\r\n * \t\tThe new piece type after the transformation.\r\n */\r\nvoid setTypeAfterTransformation(byte pieceType);"},
 {"id":369, "parametername":"Position source", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":78, "classname":"de.java_chess.javaChess.ply.TransformationPlyImpl", "methodid":588, "methodname":"de.java_chess.javaChess.ply.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square.\r\n * @param destination\r\n * \t\tThe destination square.\r\n * @param pieceType\r\n * \t\tThe piece type after the transformation.\r\n * @param capture\r\n * \t\tFlag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}"},
 {"id":370, "parametername":"Position destination", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":78, "classname":"de.java_chess.javaChess.ply.TransformationPlyImpl", "methodid":588, "methodname":"de.java_chess.javaChess.ply.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square.\r\n * @param destination\r\n * \t\tThe destination square.\r\n * @param pieceType\r\n * \t\tThe piece type after the transformation.\r\n * @param capture\r\n * \t\tFlag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}"},
 {"id":371, "parametername":"byte pieceType", "parametertype":"byte", "parameterclass":0, "classid":78, "classname":"de.java_chess.javaChess.ply.TransformationPlyImpl", "methodid":588, "methodname":"de.java_chess.javaChess.ply.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square.\r\n * @param destination\r\n * \t\tThe destination square.\r\n * @param pieceType\r\n * \t\tThe piece type after the transformation.\r\n * @param capture\r\n * \t\tFlag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}"},
 {"id":372, "parametername":"boolean capture", "parametertype":"boolean", "parameterclass":0, "classid":78, "classname":"de.java_chess.javaChess.ply.TransformationPlyImpl", "methodid":588, "methodname":"de.java_chess.javaChess.ply.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square.\r\n * @param destination\r\n * \t\tThe destination square.\r\n * @param pieceType\r\n * \t\tThe piece type after the transformation.\r\n * @param capture\r\n * \t\tFlag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}"},
 {"id":373, "parametername":"byte pieceType", "parametertype":"byte", "parameterclass":0, "classid":78, "classname":"de.java_chess.javaChess.ply.TransformationPlyImpl", "methodid":590, "methodname":"de.java_chess.javaChess.ply.TransformationPlyImpl.setTypeAfterTransformation(byte)", "isreturn":0, "sourcecode":"/**\r\n * Set the new piece type after the transformation.\r\n *\r\n * @param pieceType\r\n * \t\tThe new piece type after the transformation.\r\n */\r\npublic final void setTypeAfterTransformation(byte pieceType) {\r\n    _newPieceType = pieceType;\r\n}"},
 {"id":374, "parametername":"int index", "parametertype":"int", "parameterclass":0, "classid":80, "classname":"de.java_chess.javaChess.position.Position", "methodid":596, "methodname":"de.java_chess.javaChess.position.Position.setSquareIndex(int)", "isreturn":0, "sourcecode":"/**\r\n * The square index of this position instance.\r\n *\r\n * @param index\r\n * \t\tThe square index of this position (0-63).\r\n */\r\nvoid setSquareIndex(int index);"},
 {"id":375, "parametername":"Position pos", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":80, "classname":"de.java_chess.javaChess.position.Position", "methodid":592, "methodname":"de.java_chess.javaChess.position.Position.equals(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * \t\tposition.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\nboolean equals(Position pos);"},
 {"id":376, "parametername":"int squareIndex", "parametertype":"int", "parameterclass":0, "classid":81, "classname":"de.java_chess.javaChess.position.PositionImpl", "methodid":598, "methodname":"de.java_chess.javaChess.position.PositionImpl.-init-(int)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a position from a given square index.\r\n *\r\n * @param squareIndex\r\n * \t\tThe index of the square (0..63).\r\n */\r\npublic PositionImpl(int squareIndex) {\r\n    setSquareIndex(squareIndex);\r\n}"},
 {"id":377, "parametername":"String squareName", "parametertype":"java.lang.String", "parameterclass":0, "classid":81, "classname":"de.java_chess.javaChess.position.PositionImpl", "methodid":599, "methodname":"de.java_chess.javaChess.position.PositionImpl.-init-(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Create a position from a given square name (i.e. d4).\r\n *\r\n * @param squareName\r\n * \t\tThe name of the square.\r\n * @throws IllegalPositionException\r\n * \t\tIf the argument is not a valid square name.\r\n */\r\npublic PositionImpl(String squareName) throws IllegalPositionException {\r\n    // -1 indicates an error here.\r\n    int squareIndex = -1;\r\n    // Trim and convert the name to lower case.\r\n    squareName = squareName.trim().toLowerCase();\r\n    // Check if the name has no extra characters\r\n    if ((squareName.length()) != 2) {\r\n        throw new IllegalPositionException();\r\n    } else {\r\n        // Get the line.\r\n        char lineLetter = squareName.charAt(0);\r\n        if ((lineLetter < a) || (lineLetter > h)) {\r\n            throw new IllegalPositionException();\r\n        } else {\r\n            // Compute the index of the line.\r\n            int lineIndex = lineLetter - a;\r\n            // Get the name of the row.\r\n            char rowLetter = squareName.charAt(1);\r\n            if ((rowLetter < 1) || (rowLetter > 8)) {\r\n                throw new IllegalPositionException();\r\n            } else {\r\n                int rowIndex = rowLetter - 1;\r\n                // The square index is 8 * row + line.\r\n                squareIndex = (rowIndex << 3) + lineIndex;\r\n            }\r\n        }\r\n    }\r\n    // Set the computed square index.\r\n    setSquareIndex(squareIndex);\r\n}"},
 {"id":378, "parametername":"int squareIndex", "parametertype":"int", "parameterclass":0, "classid":81, "classname":"de.java_chess.javaChess.position.PositionImpl", "methodid":604, "methodname":"de.java_chess.javaChess.position.PositionImpl.setSquareIndex(int)", "isreturn":0, "sourcecode":"/**\r\n * Set the square index of this position.\r\n *\r\n * @param squareIndex\r\n * \t\tThe new square index of this position.\r\n */\r\npublic final void setSquareIndex(int squareIndex) {\r\n    _squareIndex = squareIndex;\r\n}"},
 {"id":379, "parametername":"Position pos", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":81, "classname":"de.java_chess.javaChess.position.PositionImpl", "methodid":600, "methodname":"de.java_chess.javaChess.position.PositionImpl.equals(de.java_chess.javaChess.position.Position)", "isreturn":0, "sourcecode":"/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * \t\tposition.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\npublic final boolean equals(Position pos) {\r\n    return (pos.getSquareIndex()) == (getSquareIndex());\r\n}"},
 {"id":380, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":82, "classname":"de.java_chess.javaChess.renderer.ChessBoardRenderer", "methodid":610, "methodname":"de.java_chess.javaChess.renderer.ChessBoardRenderer.setBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nvoid setBoard(Board board);"},
 {"id":381, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":82, "classname":"de.java_chess.javaChess.renderer.ChessBoardRenderer", "methodid":606, "methodname":"de.java_chess.javaChess.renderer.ChessBoardRenderer.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Render a piece move.\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n */\r\nvoid doPly(Ply ply);"},
 {"id":382, "parametername":"PiecesLayer piecesLayer", "parametertype":"de.java_chess.javaChess.renderer2d.PiecesLayer", "parameterclass":94, "classid":83, "classname":"de.java_chess.javaChess.renderer2d.AnimationLayer", "methodid":611, "methodname":"de.java_chess.javaChess.renderer2d.AnimationLayer.-init-(de.java_chess.javaChess.renderer2d.PiecesLayer)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new AnimationLayer instance.\r\n *\r\n * @param piecesLayer\r\n * \t\tThe layer with the pieces.\r\n */\r\nAnimationLayer(PiecesLayer piecesLayer) {\r\n    setPiecesLayer(piecesLayer);\r\n}"},
 {"id":383, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":83, "classname":"de.java_chess.javaChess.renderer2d.AnimationLayer", "methodid":612, "methodname":"de.java_chess.javaChess.renderer2d.AnimationLayer.animatePly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Animate the move of a piece.\r\n */\r\nvoid animatePly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":384, "parametername":"PiecesLayer piecesLayer", "parametertype":"de.java_chess.javaChess.renderer2d.PiecesLayer", "parameterclass":94, "classid":83, "classname":"de.java_chess.javaChess.renderer2d.AnimationLayer", "methodid":615, "methodname":"de.java_chess.javaChess.renderer2d.AnimationLayer.setPiecesLayer(de.java_chess.javaChess.renderer2d.PiecesLayer)", "isreturn":0, "sourcecode":"/**\r\n * Set a new pieces layer.\r\n *\r\n * @param piecesLayer\r\n * \t\tThe new pieces layer.\r\n */\r\nvoid setPiecesLayer(PiecesLayer piecesLayer) {\r\n    _piecesLayer = piecesLayer;\r\n}"},
 {"id":385, "parametername":"Graphics g", "parametertype":"java.awt.Graphics", "parameterclass":0, "classid":84, "classname":"de.java_chess.javaChess.renderer2d.BoardLayer", "methodid":623, "methodname":"de.java_chess.javaChess.renderer2d.BoardLayer.paintComponent(java.awt.Graphics)", "isreturn":0, "sourcecode":"// Methods\r\npublic void paintComponent(Graphics g) {\r\n    // g.setColor( new Color( 190, 190, 140) );\r\n    // g.setColor( new Color( 229, 229, 225) );\r\n    g.setColor(new Color(247, 247, 245));\r\n    g.fillRect(0, 0, _boardSize, _boardSize);\r\n    // g.setColor( new Color( 122, 80, 44));\r\n    // g.setColor( new Color( 250, 105, 86));\r\n    // g.setColor( new Color( 235, 142, 9));\r\n    g.setColor(new Color(249, 134, 89));\r\n    for (int i = 0; i < 8; i++)\r\n        for (int j = 0; j < 8; j++)\r\n            if (((i % 2) != 0) && ((j % 2) == 0))\r\n                g.fillRect((i * (_squareSize)), (j * (_squareSize)), _squareSize, _squareSize);\r\n            else\r\n                if (((i % 2) == 0) && ((j % 2) != 0))\r\n                    g.fillRect((i * (_squareSize)), (j * (_squareSize)), _squareSize, _squareSize);\r\n\r\n\r\n\r\n\r\n}"},
 {"id":386, "parametername":"GameController controller", "parametertype":"de.java_chess.javaChess.GameController", "parameterclass":1, "classid":85, "classname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "methodid":624, "methodname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new renderer instance.\r\n *\r\n * @param controller\r\n * \t\tThe game controller.\r\n * @param board\r\n * \t\tThe current board.\r\n */\r\npublic ChessBoardRenderer2D(GameController controller, Board board) {\r\n    setBoard(board);// Store the board in a class variable.\r\n\r\n    // Use a boarder layout for the entire component, since it holds\r\n    // more that the chessboard itself.\r\n    setLayout(new BorderLayout());\r\n    // Add the row numbers to the board.\r\n    JPanel rowNumbers = new JPanel();\r\n    rowNumbers.setLayout(new GridLayout(8, 1));\r\n    rowNumbers.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    for (int i = 8; i > 0; i--) {\r\n        rowNumbers.add(new JLabel((\"\" + i), JLabel.CENTER));\r\n    }\r\n    add(rowNumbers, BorderLayout.WEST);\r\n    // Add the board itself.\r\n    JLayeredPane boardPane = new JLayeredPane();\r\n    boardPane.setPreferredSize(new Dimension((8 * (ChessBoardRenderer2D._squareSize)), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    boardPane.setOpaque(false);\r\n    // The squares of the board are drawn on the board layer.\r\n    boardPane.add(new BoardLayer(), JLayeredPane.DEFAULT_LAYER);\r\n    // The next layer holds the pieces.\r\n    boardPane.add((_piecesLayer = new PiecesLayer(getBoard())), JLayeredPane.PALETTE_LAYER);\r\n    // The next layer holds the control markers, when the user moves a piece.\r\n    if (controller != null)\r\n        boardPane.add((_controlLayer = new ControlLayer(controller, _piecesLayer)), JLayeredPane.MODAL_LAYER);\r\n\r\n    // The next layer shows the animated pieces.\r\n    boardPane.add(_piecesLayer.getAnimationLayer(), JLayeredPane.DRAG_LAYER);\r\n    add(boardPane);\r\n    // Add the line names to the board\r\n    JPanel lineNames = new JPanel();\r\n    lineNames.setLayout(new FlowLayout(FlowLayout.CENTER, 0, 0));\r\n    lineNames.setPreferredSize(new Dimension(((8 * (ChessBoardRenderer2D._squareSize)) + ((ChessBoardRenderer2D._squareSize) / 2)), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    JLabel placeHolder = new JLabel();\r\n    placeHolder.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    lineNames.add(placeHolder);\r\n    byte[] name = new byte[1];\r\n    for (int i = 0; i < 8; i++) {\r\n        name[0] = ((byte) (a + i));\r\n        JLabel nameLabel = new JLabel(new String(name), JLabel.CENTER);\r\n        nameLabel.setPreferredSize(new Dimension(ChessBoardRenderer2D._squareSize, ((ChessBoardRenderer2D._squareSize) / 2)));\r\n        lineNames.add(nameLabel);\r\n    }\r\n    add(lineNames, BorderLayout.SOUTH);\r\n}"},
 {"id":387, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":85, "classname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "methodid":624, "methodname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new renderer instance.\r\n *\r\n * @param controller\r\n * \t\tThe game controller.\r\n * @param board\r\n * \t\tThe current board.\r\n */\r\npublic ChessBoardRenderer2D(GameController controller, Board board) {\r\n    setBoard(board);// Store the board in a class variable.\r\n\r\n    // Use a boarder layout for the entire component, since it holds\r\n    // more that the chessboard itself.\r\n    setLayout(new BorderLayout());\r\n    // Add the row numbers to the board.\r\n    JPanel rowNumbers = new JPanel();\r\n    rowNumbers.setLayout(new GridLayout(8, 1));\r\n    rowNumbers.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    for (int i = 8; i > 0; i--) {\r\n        rowNumbers.add(new JLabel((\"\" + i), JLabel.CENTER));\r\n    }\r\n    add(rowNumbers, BorderLayout.WEST);\r\n    // Add the board itself.\r\n    JLayeredPane boardPane = new JLayeredPane();\r\n    boardPane.setPreferredSize(new Dimension((8 * (ChessBoardRenderer2D._squareSize)), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    boardPane.setOpaque(false);\r\n    // The squares of the board are drawn on the board layer.\r\n    boardPane.add(new BoardLayer(), JLayeredPane.DEFAULT_LAYER);\r\n    // The next layer holds the pieces.\r\n    boardPane.add((_piecesLayer = new PiecesLayer(getBoard())), JLayeredPane.PALETTE_LAYER);\r\n    // The next layer holds the control markers, when the user moves a piece.\r\n    if (controller != null)\r\n        boardPane.add((_controlLayer = new ControlLayer(controller, _piecesLayer)), JLayeredPane.MODAL_LAYER);\r\n\r\n    // The next layer shows the animated pieces.\r\n    boardPane.add(_piecesLayer.getAnimationLayer(), JLayeredPane.DRAG_LAYER);\r\n    add(boardPane);\r\n    // Add the line names to the board\r\n    JPanel lineNames = new JPanel();\r\n    lineNames.setLayout(new FlowLayout(FlowLayout.CENTER, 0, 0));\r\n    lineNames.setPreferredSize(new Dimension(((8 * (ChessBoardRenderer2D._squareSize)) + ((ChessBoardRenderer2D._squareSize) / 2)), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    JLabel placeHolder = new JLabel();\r\n    placeHolder.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    lineNames.add(placeHolder);\r\n    byte[] name = new byte[1];\r\n    for (int i = 0; i < 8; i++) {\r\n        name[0] = ((byte) (a + i));\r\n        JLabel nameLabel = new JLabel(new String(name), JLabel.CENTER);\r\n        nameLabel.setPreferredSize(new Dimension(ChessBoardRenderer2D._squareSize, ((ChessBoardRenderer2D._squareSize) / 2)));\r\n        lineNames.add(nameLabel);\r\n    }\r\n    add(lineNames, BorderLayout.SOUTH);\r\n}"},
 {"id":388, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":85, "classname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "methodid":626, "methodname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Render a ply (the move of a piece).\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    _piecesLayer.doPly(ply);\r\n    repaint();\r\n}"},
 {"id":389, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":85, "classname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "methodid":634, "methodname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.setBoard(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\npublic final void setBoard(Board board) {\r\n    _board = board;\r\n}"},
 {"id":390, "parametername":"Component c", "parametertype":"java.awt.Component", "parameterclass":0, "classid":86, "classname":"de.java_chess.javaChess.renderer2d.ChessSet", "methodid":635, "methodname":"de.java_chess.javaChess.renderer2d.ChessSet.-init-(java.awt.Component)", "isreturn":0, "sourcecode":"// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new chess set component.\r\n *\r\n * @param c\r\n * \t\tThe parent component.\r\n */\r\npublic ChessSet(Component c) {\r\n    super(240, 80, BufferedImage.TYPE_INT_ARGB);\r\n    Image im = null;\r\n    // try {\r\n    // URL url = getClass().getResource(\"ChessPieces_neu.gif\");\r\n    // im = Toolkit.getDefaultToolkit().getImage( url );\r\n    // im = Toolkit.getDefaultToolkit().getImage( new URL( \"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/ChessPieces02.gif\"));\r\n    // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // original\r\n    // im = ResourceLoader.getInstance().loadImage( \"ChessPieces02.gif\");\r\n    // achraf\r\n    URL urlStart = getClass().getResource(\"images/ChessPieces02.gif\");\r\n    im = Toolkit.getDefaultToolkit().getImage(urlStart);\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // } catch( MalformedURLException ignored) {}\r\n    MediaTracker mT = new MediaTracker(c);\r\n    mT.addImage(im, 0);\r\n    try {\r\n        mT.waitForID(0);\r\n    } catch (InterruptedException ie) {\r\n    }\r\n    Graphics g = getGraphics();\r\n    g.drawImage(im, 0, 0, c);\r\n}"},
 {"id":391, "parametername":"GameController controller", "parametertype":"de.java_chess.javaChess.GameController", "parameterclass":1, "classid":87, "classname":"de.java_chess.javaChess.renderer2d.ControlLayer", "methodid":636, "methodname":"de.java_chess.javaChess.renderer2d.ControlLayer.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.renderer2d.PiecesLayer)", "isreturn":0, "sourcecode":"// Constructors\r\nControlLayer(GameController controller, PiecesLayer pl) {\r\n    setController(controller);\r\n    _squareSize = ChessBoardRenderer2D.getSquareSize();\r\n    _boardSize = 8 * (_squareSize);\r\n    setLayout(null);\r\n    setOpaque(false);\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    _piecesLayer = pl;\r\n    addMouseListener(new MouseAdapter() {\r\n        public void mouseClicked(MouseEvent e) {\r\n            if ((_sourceSquare) == (-1)) {\r\n                _sourceSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                repaint();\r\n            } else {\r\n                final int destSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                new Thread(new Runnable() {\r\n                    public void run() {\r\n                        // The capture flag is added by the game controller(!).\r\n                        getController().userPly(new PlyImpl(new PositionImpl(_sourceSquare), new PositionImpl(destSquare), false));\r\n                        _sourceSquare = -1;\r\n                        repaint();\r\n                    }\r\n                }).start();\r\n                // getController().userPly( new PlyImpl( new PositionImpl( _sourceSquare), new PositionImpl( destSquare)));\r\n                // _sourceSquare = -1;\r\n                // repaint();\r\n            }\r\n        }\r\n    });\r\n}"},
 {"id":392, "parametername":"PiecesLayer pl", "parametertype":"de.java_chess.javaChess.renderer2d.PiecesLayer", "parameterclass":94, "classid":87, "classname":"de.java_chess.javaChess.renderer2d.ControlLayer", "methodid":636, "methodname":"de.java_chess.javaChess.renderer2d.ControlLayer.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.renderer2d.PiecesLayer)", "isreturn":0, "sourcecode":"// Constructors\r\nControlLayer(GameController controller, PiecesLayer pl) {\r\n    setController(controller);\r\n    _squareSize = ChessBoardRenderer2D.getSquareSize();\r\n    _boardSize = 8 * (_squareSize);\r\n    setLayout(null);\r\n    setOpaque(false);\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    _piecesLayer = pl;\r\n    addMouseListener(new MouseAdapter() {\r\n        public void mouseClicked(MouseEvent e) {\r\n            if ((_sourceSquare) == (-1)) {\r\n                _sourceSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                repaint();\r\n            } else {\r\n                final int destSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                new Thread(new Runnable() {\r\n                    public void run() {\r\n                        // The capture flag is added by the game controller(!).\r\n                        getController().userPly(new PlyImpl(new PositionImpl(_sourceSquare), new PositionImpl(destSquare), false));\r\n                        _sourceSquare = -1;\r\n                        repaint();\r\n                    }\r\n                }).start();\r\n                // getController().userPly( new PlyImpl( new PositionImpl( _sourceSquare), new PositionImpl( destSquare)));\r\n                // _sourceSquare = -1;\r\n                // repaint();\r\n            }\r\n        }\r\n    });\r\n}"},
 {"id":393, "parametername":"Graphics g", "parametertype":"java.awt.Graphics", "parameterclass":0, "classid":87, "classname":"de.java_chess.javaChess.renderer2d.ControlLayer", "methodid":640, "methodname":"de.java_chess.javaChess.renderer2d.ControlLayer.paintComponent(java.awt.Graphics)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Overridden  paintComponent method to draw the marker for\r\n * the source square.\r\n *\r\n * @param g\r\n * \t\tThe graphics context.\r\n */\r\npublic void paintComponent(Graphics g) {\r\n    if ((_sourceSquare) != (-1)) {\r\n        // If a source square is selected,\r\n        markSquare(_sourceSquare, g);// mark it.\r\n\r\n    }\r\n}"},
 {"id":394, "parametername":"int square", "parametertype":"int", "parameterclass":0, "classid":87, "classname":"de.java_chess.javaChess.renderer2d.ControlLayer", "methodid":639, "methodname":"de.java_chess.javaChess.renderer2d.ControlLayer.markSquare(int,java.awt.Graphics)", "isreturn":0, "sourcecode":"/**\r\n * Draw a marker at the given square.\r\n *\r\n * @param square\r\n * \t\tThe square to mark.\r\n * @param g\r\n * \t\tThe graphics context.\r\n */\r\nprivate final void markSquare(int square, Graphics g) {\r\n    int xpos = (square & 7) * (_squareSize);\r\n    // Compute the location of the\r\n    int ypos = (7 - (square >> 3)) * (_squareSize);// square\r\n\r\n    int rectSize = (_squareSize) - 1;\r\n    // and its size.\r\n    g.setColor(Color.blue);\r\n    // Simply draw a blue frame there.\r\n    for (int i = 0; i < 3; i++) {\r\n        g.drawRect((xpos++), (ypos++), rectSize, rectSize);\r\n        rectSize -= 2;\r\n    }\r\n}"},
 {"id":395, "parametername":"Graphics g", "parametertype":"java.awt.Graphics", "parameterclass":0, "classid":87, "classname":"de.java_chess.javaChess.renderer2d.ControlLayer", "methodid":639, "methodname":"de.java_chess.javaChess.renderer2d.ControlLayer.markSquare(int,java.awt.Graphics)", "isreturn":0, "sourcecode":"/**\r\n * Draw a marker at the given square.\r\n *\r\n * @param square\r\n * \t\tThe square to mark.\r\n * @param g\r\n * \t\tThe graphics context.\r\n */\r\nprivate final void markSquare(int square, Graphics g) {\r\n    int xpos = (square & 7) * (_squareSize);\r\n    // Compute the location of the\r\n    int ypos = (7 - (square >> 3)) * (_squareSize);// square\r\n\r\n    int rectSize = (_squareSize) - 1;\r\n    // and its size.\r\n    g.setColor(Color.blue);\r\n    // Simply draw a blue frame there.\r\n    for (int i = 0; i < 3; i++) {\r\n        g.drawRect((xpos++), (ypos++), rectSize, rectSize);\r\n        rectSize -= 2;\r\n    }\r\n}"},
 {"id":396, "parametername":"GameController controller", "parametertype":"de.java_chess.javaChess.GameController", "parameterclass":1, "classid":87, "classname":"de.java_chess.javaChess.renderer2d.ControlLayer", "methodid":641, "methodname":"de.java_chess.javaChess.renderer2d.ControlLayer.setController(de.java_chess.javaChess.GameController)", "isreturn":0, "sourcecode":"/**\r\n * Set a new game controller.\r\n *\r\n * @param The\r\n * \t\tnew game controller.\r\n */\r\nprivate final void setController(GameController controller) {\r\n    _controller = controller;\r\n}"},
 {"id":397, "parametername":"ActionListener listener", "parametertype":"java.awt.event.ActionListener", "parameterclass":0, "classid":88, "classname":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel", "methodid":643, "methodname":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.addActionListener(java.awt.event.ActionListener)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Add a action listener to this timer.\r\n *\r\n * @param listener\r\n * \t\tThe action listener to add.\r\n */\r\npublic void addActionListener(ActionListener listener) {\r\n    _actionListeners.add(listener);\r\n}"},
 {"id":398, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":88, "classname":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel", "methodid":647, "methodname":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.notifyListeners(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * Notify the waiting action listeners.\r\n *\r\n * @param event\r\n * \t\tThe action event to send.\r\n */\r\nprivate void notifyListeners(ActionEvent event) {\r\n    // Iterate over all the listeners and send them the event.\r\n    for (Iterator iterator = _actionListeners.iterator(); iterator.hasNext();) {\r\n        ActionListener listener = ((ActionListener) (iterator.next()));\r\n        listener.actionPerformed(event);\r\n    }\r\n}"},
 {"id":399, "parametername":"int time", "parametertype":"int", "parameterclass":0, "classid":88, "classname":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel", "methodid":649, "methodname":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.setCountdown(int)", "isreturn":0, "sourcecode":"/**\r\n * Set the length of the countdown in seconds.\r\n *\r\n * @param time\r\n * \t\tThe length of the countdown.\r\n */\r\npublic void setCountdown(int time) {\r\n    // _startTime = -1L;\r\n    _remainingTime = _time = 1000L * ((long) (time));\r\n    display(_time);\r\n}"},
 {"id":400, "parametername":"long time", "parametertype":"long", "parameterclass":0, "classid":88, "classname":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel", "methodid":645, "methodname":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.display(long)", "isreturn":0, "sourcecode":"/**\r\n * Display the current time.\r\n *\r\n * @param time\r\n * \t\tThe current time in milliseconds.\r\n */\r\nvoid display(long time) {\r\n    // Dont display negative time.\r\n    if (time < 0L) {\r\n        time = 0L;\r\n    }\r\n    int timeSec = ((int) (time / 1000L));// Display accurate to  1 s.\r\n\r\n    StringBuffer timeString = new StringBuffer();\r\n    int hours = timeSec / 3600;\r\n    timeString.append((\"\" + hours));\r\n    int minutes = (timeSec / 60) % 60;\r\n    timeString.append(((minutes < 10 ? \":0\" : \":\") + minutes));\r\n    int seconds = timeSec % 60;\r\n    timeString.append(((seconds < 10 ? \":0\" : \":\") + seconds));\r\n    _display.setText(timeString.toString());\r\n    _display.paintImmediately(0, 0, CountdownTimerPanel._displayWidth, CountdownTimerPanel._displayHeight);\r\n}"},
 {"id":401, "parametername":"String newText", "parametertype":"java.lang.String", "parameterclass":0, "classid":89, "classname":"de.java_chess.javaChess.renderer2d.EnginePanel", "methodid":655, "methodname":"de.java_chess.javaChess.renderer2d.EnginePanel.modifyText(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Adds the given text to the existing\r\n *\r\n * @param newText\r\n * \t\tThe text to add\r\n */\r\npublic final void modifyText(String newText) {\r\n    String sCurrentText = getText();\r\n    if (!(sCurrentText.equals(\"\"))) {\r\n        setText(((sCurrentText + \"\n\") + newText));\r\n        Point point = new Point(0, ((int) (this.jtEngine.getSize().getHeight())));\r\n        this.jScrollPane.getViewport().setViewPosition(point);\r\n    } else {\r\n        setText(newText);\r\n    }\r\n}"},
 {"id":402, "parametername":"String newText", "parametertype":"java.lang.String", "parameterclass":0, "classid":89, "classname":"de.java_chess.javaChess.renderer2d.EnginePanel", "methodid":656, "methodname":"de.java_chess.javaChess.renderer2d.EnginePanel.setText(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Set the current text of the engine panel.\r\n *\r\n * @param newText\r\n * \t\tThe new text to set.\r\n */\r\npublic final void setText(String newText) {\r\n    this.jtEngine.setText(newText);\r\n}"},
 {"id":403, "parametername":"int maxTime", "parametertype":"int", "parameterclass":0, "classid":90, "classname":"de.java_chess.javaChess.renderer2d.GameTimerPanel", "methodid":658, "methodname":"de.java_chess.javaChess.renderer2d.GameTimerPanel.-init-(int)", "isreturn":0, "sourcecode":"/**\r\n * Create a given game timer with a countdown time.\r\n *\r\n * @param maxTime\r\n * \t\tThe remaining time.\r\n */\r\npublic GameTimerPanel(int maxTime) {\r\n    this();\r\n    setCountdown(maxTime);\r\n}"},
 {"id":404, "parametername":"int time", "parametertype":"int", "parameterclass":0, "classid":90, "classname":"de.java_chess.javaChess.renderer2d.GameTimerPanel", "methodid":664, "methodname":"de.java_chess.javaChess.renderer2d.GameTimerPanel.reset(int)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Reset to a given time.\r\n *\r\n * @param time\r\n * \t\tThe time to reset to.\r\n */\r\npublic void reset(int time) {\r\n    stop();// Stop the timer.\r\n\r\n    setCountdown(time);\r\n    setNoClockRunning();\r\n}"},
 {"id":405, "parametername":"int time", "parametertype":"int", "parameterclass":0, "classid":90, "classname":"de.java_chess.javaChess.renderer2d.GameTimerPanel", "methodid":666, "methodname":"de.java_chess.javaChess.renderer2d.GameTimerPanel.setCountdown(int)", "isreturn":0, "sourcecode":"/**\r\n * Set the remaining time for each timer.\r\n *\r\n * @param time\r\n * \t\tThe remaining time for each time.\r\n */\r\npublic void setCountdown(int time) {\r\n    _white.setCountdown(time);\r\n    _black.setCountdown(time);\r\n}"},
 {"id":406, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":90, "classname":"de.java_chess.javaChess.renderer2d.GameTimerPanel", "methodid":659, "methodname":"de.java_chess.javaChess.renderer2d.GameTimerPanel.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * Get a event from one of the timers.\r\n *\r\n * ActionEvent event The event.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    if (!(\"interrupted\".equals(event.getActionCommand()))) {\r\n        // This event means, that the timer sending the event has stopped,\r\n        // so stop the entire timer for now.\r\n        stop();\r\n        notifyListeners(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ((event.getSource()) == (_white) ? \"timeout white\" : \"timeout black\")));\r\n    }\r\n}"},
 {"id":407, "parametername":"ActionListener listener", "parametertype":"java.awt.event.ActionListener", "parameterclass":0, "classid":90, "classname":"de.java_chess.javaChess.renderer2d.GameTimerPanel", "methodid":660, "methodname":"de.java_chess.javaChess.renderer2d.GameTimerPanel.addActionListener(java.awt.event.ActionListener)", "isreturn":0, "sourcecode":"/**\r\n * Add a action listener to this timer.\r\n *\r\n * @param listener\r\n * \t\tThe action listener to add.\r\n */\r\npublic void addActionListener(ActionListener listener) {\r\n    _actionListeners.add(listener);\r\n}"},
 {"id":408, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":90, "classname":"de.java_chess.javaChess.renderer2d.GameTimerPanel", "methodid":663, "methodname":"de.java_chess.javaChess.renderer2d.GameTimerPanel.notifyListeners(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * Notify the waiting action listeners.\r\n *\r\n * @param event\r\n * \t\tThe action event to send.\r\n */\r\nprivate void notifyListeners(ActionEvent event) {\r\n    // Iterate over all the listeners and send them the event.\r\n    for (Iterator iterator = _actionListeners.iterator(); iterator.hasNext();) {\r\n        ActionListener listener = ((ActionListener) (iterator.next()));\r\n        listener.actionPerformed(event);\r\n    }\r\n}"},
 {"id":409, "parametername":"boolean active", "parametertype":"boolean", "parameterclass":0, "classid":90, "classname":"de.java_chess.javaChess.renderer2d.GameTimerPanel", "methodid":668, "methodname":"de.java_chess.javaChess.renderer2d.GameTimerPanel.setRunning(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the new running state of the timer.\r\n *\r\n * @param active\r\n * \t\tThe new state of the timer panel.\r\n */\r\npublic void setRunning(boolean active) {\r\n    _running = active;\r\n}"},
 {"id":410, "parametername":"ActionEvent ae", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":91, "classname":"de.java_chess.javaChess.renderer2d.NavigationPanel", "methodid":674, "methodname":"de.java_chess.javaChess.renderer2d.NavigationPanel.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * React on mouseclick\r\n */\r\npublic void actionPerformed(ActionEvent ae) {\r\n    if (ae.getSource().equals(jbStart))\r\n        moveToStart();\r\n\r\n    if (ae.getSource().equals(jbBack))\r\n        moveOnePlyBack();\r\n\r\n    if (ae.getSource().equals(jbForward))\r\n        moveOnePlyForward();\r\n\r\n    if (ae.getSource().equals(jbEnd))\r\n        moveToEnd();\r\n\r\n}"},
 {"id":411, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":92, "classname":"de.java_chess.javaChess.renderer2d.NotationPanel", "methodid":680, "methodname":"de.java_chess.javaChess.renderer2d.NotationPanel.-init-(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"/**\r\n * Standardconstructor\r\n */\r\npublic NotationPanel(GameNotation gameNotation) {\r\n    super();\r\n    // Store the game notation in this instance.\r\n    setGameNotation(gameNotation);\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":412, "parametername":"String newText", "parametertype":"java.lang.String", "parameterclass":0, "classid":92, "classname":"de.java_chess.javaChess.renderer2d.NotationPanel", "methodid":685, "methodname":"de.java_chess.javaChess.renderer2d.NotationPanel.modifyText(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Adds the given text to the existing\r\n *\r\n * @param newText\r\n * \t\tThe text to add\r\n */\r\npublic void modifyText(String newText) {\r\n    String sCurrentText = this.jtNotation.getText();\r\n    if ((sCurrentText.equals(\"\")) == false) {\r\n        this.jtNotation.setText(((sCurrentText + \"\n\") + newText));\r\n        Point point = new Point(0, ((int) (this.jtNotation.getSize().getHeight())));\r\n        this.jScrollPane.getViewport().setViewPosition(point);\r\n    } else {\r\n        this.jtNotation.setText(newText);\r\n    }\r\n}"},
 {"id":413, "parametername":"GameNotation gameNotation", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":92, "classname":"de.java_chess.javaChess.renderer2d.NotationPanel", "methodid":687, "methodname":"de.java_chess.javaChess.renderer2d.NotationPanel.setGameNotation(de.java_chess.javaChess.notation.GameNotation)", "isreturn":0, "sourcecode":"/**\r\n * Set a new notation object.\r\n *\r\n * @param gameNotation\r\n * \t\tThe new game notation.\r\n */\r\npublic void setGameNotation(GameNotation gameNotation) {\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":414, "parametername":"String newNotation", "parametertype":"java.lang.String", "parameterclass":0, "classid":92, "classname":"de.java_chess.javaChess.renderer2d.NotationPanel", "methodid":688, "methodname":"de.java_chess.javaChess.renderer2d.NotationPanel.setText(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Set a new notation.\r\n *\r\n * @param newNotation\r\n * \t\tThe new notation.\r\n */\r\npublic void setText(String newNotation) {\r\n    this.jtNotation.setText(newNotation);\r\n}"},
 {"id":415, "parametername":"String newName", "parametertype":"java.lang.String", "parameterclass":0, "classid":92, "classname":"de.java_chess.javaChess.renderer2d.NotationPanel", "methodid":689, "methodname":"de.java_chess.javaChess.renderer2d.NotationPanel.setWhitePlayerName(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Sets the white players name\r\n *\r\n * @param newName\r\n * \t\tThe new string for the white player\r\n */\r\npublic void setWhitePlayerName(String newName) {\r\n    this.jbWhite.setText(newName);\r\n    // If theres a notation object, pass the new name to it.\r\n    if ((_gameNotation) != null) {\r\n        _gameNotation.setPlayerInfo(newName, true);\r\n    }\r\n}"},
 {"id":416, "parametername":"String newName", "parametertype":"java.lang.String", "parameterclass":0, "classid":92, "classname":"de.java_chess.javaChess.renderer2d.NotationPanel", "methodid":686, "methodname":"de.java_chess.javaChess.renderer2d.NotationPanel.setBlackPlayerName(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Sets the black players name\r\n *\r\n * @param newName\r\n * \t\tThe new string for the black player\r\n */\r\npublic void setBlackPlayerName(String newName) {\r\n    this.jbBlack.setText(newName);\r\n    // If theres a notation object, pass the new name to it.\r\n    if ((_gameNotation) != null) {\r\n        _gameNotation.setPlayerInfo(newName, false);\r\n    }\r\n}"},
 {"id":417, "parametername":"ActionEvent e", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":92, "classname":"de.java_chess.javaChess.renderer2d.NotationPanel", "methodid":681, "methodname":"de.java_chess.javaChess.renderer2d.NotationPanel.actionPerformed(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"public void actionPerformed(ActionEvent e) {\r\n    boolean bWhiteOrBlack = true;\r\n    PlayerDialog playerDialog = null;\r\n    if (e.getSource().equals(jbWhite)) {\r\n        playerDialog = new PlayerDialog(1, getWhitePlayerName());\r\n        bWhiteOrBlack = true;\r\n    } else\r\n        if (e.getSource().equals(jbBlack)) {\r\n            playerDialog = new PlayerDialog(2, getBlackPlayerName());\r\n            bWhiteOrBlack = false;\r\n        }\r\n\r\n    if (playerDialog != null) {\r\n        Tools.setDialogToCenter(playerDialog);\r\n        playerDialog.show();\r\n        if (bWhiteOrBlack == true) {\r\n            jbWhite.setText(playerDialog.getNewName());\r\n        } else {\r\n            jbBlack.setText(playerDialog.getNewName());\r\n        }\r\n    }\r\n}"},
 {"id":418, "parametername":"byte color", "parametertype":"byte", "parameterclass":0, "classid":93, "classname":"de.java_chess.javaChess.renderer2d.PieceRenderer", "methodid":690, "methodname":"de.java_chess.javaChess.renderer2d.PieceRenderer.-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new piece renderer instance.\r\n *\r\n * @param color\r\n * \t\tThe color of the piece.\r\n * @param piece\r\n * \t\tThe type of the piece.\r\n * @param set\r\n * \t\tThe set of chess pieces.\r\n * @unknown The parent component.\r\n */\r\npublic PieceRenderer(byte color, byte piece, ChessSet set, Component c) {\r\n    super(40, 40, BufferedImage.TYPE_INT_ARGB);\r\n    _piece = piece;\r\n    _color = color;\r\n    PieceRenderer._set = set;\r\n    Graphics g = getGraphics();\r\n    g.drawImage(PieceRenderer._set.getSubimage((((_piece) - 1) * 40), ((_color) * 40), 40, 40), 0, 0, c);\r\n}"},
 {"id":419, "parametername":"byte piece", "parametertype":"byte", "parameterclass":0, "classid":93, "classname":"de.java_chess.javaChess.renderer2d.PieceRenderer", "methodid":690, "methodname":"de.java_chess.javaChess.renderer2d.PieceRenderer.-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new piece renderer instance.\r\n *\r\n * @param color\r\n * \t\tThe color of the piece.\r\n * @param piece\r\n * \t\tThe type of the piece.\r\n * @param set\r\n * \t\tThe set of chess pieces.\r\n * @unknown The parent component.\r\n */\r\npublic PieceRenderer(byte color, byte piece, ChessSet set, Component c) {\r\n    super(40, 40, BufferedImage.TYPE_INT_ARGB);\r\n    _piece = piece;\r\n    _color = color;\r\n    PieceRenderer._set = set;\r\n    Graphics g = getGraphics();\r\n    g.drawImage(PieceRenderer._set.getSubimage((((_piece) - 1) * 40), ((_color) * 40), 40, 40), 0, 0, c);\r\n}"},
 {"id":420, "parametername":"ChessSet set", "parametertype":"de.java_chess.javaChess.renderer2d.ChessSet", "parameterclass":86, "classid":93, "classname":"de.java_chess.javaChess.renderer2d.PieceRenderer", "methodid":690, "methodname":"de.java_chess.javaChess.renderer2d.PieceRenderer.-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new piece renderer instance.\r\n *\r\n * @param color\r\n * \t\tThe color of the piece.\r\n * @param piece\r\n * \t\tThe type of the piece.\r\n * @param set\r\n * \t\tThe set of chess pieces.\r\n * @unknown The parent component.\r\n */\r\npublic PieceRenderer(byte color, byte piece, ChessSet set, Component c) {\r\n    super(40, 40, BufferedImage.TYPE_INT_ARGB);\r\n    _piece = piece;\r\n    _color = color;\r\n    PieceRenderer._set = set;\r\n    Graphics g = getGraphics();\r\n    g.drawImage(PieceRenderer._set.getSubimage((((_piece) - 1) * 40), ((_color) * 40), 40, 40), 0, 0, c);\r\n}"},
 {"id":421, "parametername":"Component c", "parametertype":"java.awt.Component", "parameterclass":0, "classid":93, "classname":"de.java_chess.javaChess.renderer2d.PieceRenderer", "methodid":690, "methodname":"de.java_chess.javaChess.renderer2d.PieceRenderer.-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new piece renderer instance.\r\n *\r\n * @param color\r\n * \t\tThe color of the piece.\r\n * @param piece\r\n * \t\tThe type of the piece.\r\n * @param set\r\n * \t\tThe set of chess pieces.\r\n * @unknown The parent component.\r\n */\r\npublic PieceRenderer(byte color, byte piece, ChessSet set, Component c) {\r\n    super(40, 40, BufferedImage.TYPE_INT_ARGB);\r\n    _piece = piece;\r\n    _color = color;\r\n    PieceRenderer._set = set;\r\n    Graphics g = getGraphics();\r\n    g.drawImage(PieceRenderer._set.getSubimage((((_piece) - 1) * 40), ((_color) * 40), 40, 40), 0, 0, c);\r\n}"},
 {"id":422, "parametername":"Board board", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":94, "classname":"de.java_chess.javaChess.renderer2d.PiecesLayer", "methodid":691, "methodname":"de.java_chess.javaChess.renderer2d.PiecesLayer.-init-(de.java_chess.javaChess.board.Board)", "isreturn":0, "sourcecode":"PiecesLayer(Board board) {\r\n    super(new GridLayout(8, 8));\r\n    _set = new ChessSet(this);\r\n    _animationLayer = new AnimationLayer(this);\r\n    _board = board;\r\n    int _boardSize = 8 * (ChessBoardRenderer2D.getSquareSize());\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    setOpaque(false);\r\n    repaintBoard();\r\n}"},
 {"id":423, "parametername":"Ply ply", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":94, "classname":"de.java_chess.javaChess.renderer2d.PiecesLayer", "methodid":693, "methodname":"de.java_chess.javaChess.renderer2d.PiecesLayer.doPly(de.java_chess.javaChess.ply.Ply)", "isreturn":0, "sourcecode":"/**\r\n * Render a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    if (_animatedMoves) {\r\n        getAnimationLayer().animatePly(ply);\r\n        getAnimationLayer().start();\r\n        repaint();\r\n    } else {\r\n        // Check, if it was a castling\r\n        if (ply instanceof CastlingPly) {\r\n            int source = ply.getSource().getSquareIndex();\r\n            if (((CastlingPly) (ply)).isLeftCastling()) {\r\n                _square[(source - 2)].getPieceFrom(_square[source]);\r\n                _square[(source - 1)].getPieceFrom(_square[(source - 4)]);// Move the rook to the right\r\n\r\n            } else {\r\n                _square[(source + 2)].getPieceFrom(_square[source]);\r\n                _square[(source + 1)].getPieceFrom(_square[(source + 3)]);// Move the rook to the left\r\n\r\n            }\r\n        } else {\r\n            // If a pawn has just reached the last row\r\n            if (ply instanceof TransformationPly) {\r\n                // Copy the piece from source square to destination square.\r\n                _square[ply.getDestination().getSquareIndex()].getPieceFrom(_square[ply.getSource().getSquareIndex()]);\r\n                // Now change the rendering to the new piece type.\r\n                _square[ply.getDestination().getSquareIndex()].setIcon(new ImageIcon(new PieceRenderer(((ply.getDestination().getSquareIndex()) < 8 ? Piece.BLACK : Piece.WHITE), ((TransformationPly) (ply)).getTypeAfterTransformation(), _set, this)));\r\n            } else {\r\n                // Copy the piece from source square to destination square.\r\n                _square[ply.getDestination().getSquareIndex()].getPieceFrom(_square[ply.getSource().getSquareIndex()]);\r\n                // If its a en passant ply, remove the attacked pawn.\r\n                if (ply instanceof EnPassantPly) {\r\n                    _square[((EnPassantPly) (ply)).getAttackedPosition().getSquareIndex()].setIcon(null);\r\n                }\r\n            }\r\n        }\r\n        repaint();\r\n    }\r\n}"},
 {"id":424, "parametername":"int squareIndex", "parametertype":"int", "parameterclass":0, "classid":94, "classname":"de.java_chess.javaChess.renderer2d.PiecesLayer", "methodid":695, "methodname":"de.java_chess.javaChess.renderer2d.PiecesLayer.getPositionRenderer(int)", "isreturn":0, "sourcecode":"/**\r\n * Get the position renderer for a given square.\r\n *\r\n * @param squareIndex\r\n * \t\tThe index of the square.\r\n * @return The position renderer for the given square.\r\n */\r\nfinal PositionRenderer getPositionRenderer(int squareIndex) {\r\n    return _square[squareIndex];\r\n}"},
 {"id":425, "parametername":"de.java_chess.javaChess.renderer2d.PositionRenderer", "parametertype":"de.java_chess.javaChess.renderer2d.PositionRenderer", "parameterclass":95, "classid":94, "classname":"de.java_chess.javaChess.renderer2d.PiecesLayer", "methodid":695, "methodname":"de.java_chess.javaChess.renderer2d.PiecesLayer.getPositionRenderer(int)", "isreturn":1, "sourcecode":"/**\r\n * Get the position renderer for a given square.\r\n *\r\n * @param squareIndex\r\n * \t\tThe index of the square.\r\n * @return The position renderer for the given square.\r\n */\r\nfinal PositionRenderer getPositionRenderer(int squareIndex) {\r\n    return _square[squareIndex];\r\n}"},
 {"id":426, "parametername":"Image image", "parametertype":"java.awt.Image", "parameterclass":0, "classid":95, "classname":"de.java_chess.javaChess.renderer2d.PositionRenderer", "methodid":698, "methodname":"de.java_chess.javaChess.renderer2d.PositionRenderer.-init-(java.awt.Image)", "isreturn":0, "sourcecode":"/**\r\n * Create a new position rendering with a given image of a piece.\r\n *\r\n * image The image for the rendering.\r\n */\r\nPositionRenderer(Image image) {\r\n    super(new ImageIcon(image));\r\n}"},
 {"id":427, "parametername":"PositionRenderer positionRenderer", "parametertype":"de.java_chess.javaChess.renderer2d.PositionRenderer", "parameterclass":95, "classid":95, "classname":"de.java_chess.javaChess.renderer2d.PositionRenderer", "methodid":699, "methodname":"de.java_chess.javaChess.renderer2d.PositionRenderer.getPieceFrom(de.java_chess.javaChess.renderer2d.PositionRenderer)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Move a piece from another position to this one.\r\n *\r\n * positionRenderer The position renderer for the source.\r\n */\r\nvoid getPieceFrom(PositionRenderer positionRenderer) {\r\n    setIcon(positionRenderer.getIcon());\r\n    positionRenderer.setIcon(null);\r\n}"},
 {"id":428, "parametername":"ImageIcon icon", "parametertype":"javax.swing.ImageIcon", "parameterclass":0, "classid":95, "classname":"de.java_chess.javaChess.renderer2d.PositionRenderer", "methodid":700, "methodname":"de.java_chess.javaChess.renderer2d.PositionRenderer.setIcon(javax.swing.ImageIcon)", "isreturn":0, "sourcecode":"/**\r\n * Set a new icon and align it properly.\r\n *\r\n * @param icon\r\n * \t\tThe new icon.\r\n */\r\npublic void setIcon(ImageIcon icon) {\r\n    super.setIcon(icon);\r\n    if (icon != null) {\r\n        invalidate();\r\n    } else {\r\n        revalidate();\r\n    }\r\n}"},
 {"id":429, "parametername":"String sVersionNumber", "parametertype":"java.lang.String", "parameterclass":0, "classid":96, "classname":"de.java_chess.javaChess.renderer2d.StatusPanel", "methodid":702, "methodname":"de.java_chess.javaChess.renderer2d.StatusPanel.-init-(java.lang.String)", "isreturn":0, "sourcecode":"public StatusPanel(String sVersionNumber) {\r\n    this.sVersion = sVersionNumber;\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":430, "parametername":"String newStatusText", "parametertype":"java.lang.String", "parameterclass":0, "classid":96, "classname":"de.java_chess.javaChess.renderer2d.StatusPanel", "methodid":705, "methodname":"de.java_chess.javaChess.renderer2d.StatusPanel.setStatusText(java.lang.String)", "isreturn":0, "sourcecode":"public void setStatusText(String newStatusText) {\r\n    this.jlStatus.setText(newStatusText);\r\n}"},
 {"id":431, "parametername":"String newActionText", "parametertype":"java.lang.String", "parameterclass":0, "classid":96, "classname":"de.java_chess.javaChess.renderer2d.StatusPanel", "methodid":704, "methodname":"de.java_chess.javaChess.renderer2d.StatusPanel.setActionText(java.lang.String)", "isreturn":0, "sourcecode":"public void setActionText(String newActionText) {\r\n    this.jlAction.setText(newActionText);\r\n}"},
 {"id":432, "parametername":"String newVersionText", "parametertype":"java.lang.String", "parameterclass":0, "classid":96, "classname":"de.java_chess.javaChess.renderer2d.StatusPanel", "methodid":706, "methodname":"de.java_chess.javaChess.renderer2d.StatusPanel.setVersionInfo(java.lang.String)", "isreturn":0, "sourcecode":"public void setVersionInfo(String newVersionText) {\r\n    this.jlVersion.setText(newVersionText);\r\n}"},
 {"id":433, "parametername":"boolean countdown", "parametertype":"boolean", "parameterclass":0, "classid":97, "classname":"de.java_chess.javaChess.renderer2d.TimerPanel", "methodid":707, "methodname":"de.java_chess.javaChess.renderer2d.TimerPanel.-init-(boolean)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new timer panel.\r\n *\r\n * @param countdown\r\n * \t\tFlag to indicate, if we count downwards.\r\n */\r\npublic TimerPanel(boolean countdown) {\r\n    setCountingDirection(countdown);\r\n    _actionListeners = new ArrayList();\r\n    _display = new JLabel(\"0:00:00\", JLabel.RIGHT);\r\n    _display.setPreferredSize(new Dimension(TimerPanel._displayWidth, TimerPanel._displayHeight));\r\n    _display.setHorizontalTextPosition(SwingConstants.CENTER);\r\n    add(_display);\r\n}"},
 {"id":434, "parametername":"ActionListener listener", "parametertype":"java.awt.event.ActionListener", "parameterclass":0, "classid":97, "classname":"de.java_chess.javaChess.renderer2d.TimerPanel", "methodid":708, "methodname":"de.java_chess.javaChess.renderer2d.TimerPanel.addActionListener(java.awt.event.ActionListener)", "isreturn":0, "sourcecode":"// Methods\r\n/**\r\n * Add a action listener to this timer.\r\n *\r\n * @param listener\r\n * \t\tThe action listener to add.\r\n */\r\npublic void addActionListener(ActionListener listener) {\r\n    _actionListeners.add(listener);\r\n}"},
 {"id":435, "parametername":"ActionEvent event", "parametertype":"java.awt.event.ActionEvent", "parameterclass":0, "classid":97, "classname":"de.java_chess.javaChess.renderer2d.TimerPanel", "methodid":713, "methodname":"de.java_chess.javaChess.renderer2d.TimerPanel.notifyListeners(java.awt.event.ActionEvent)", "isreturn":0, "sourcecode":"/**\r\n * Notify the waiting action listeners.\r\n *\r\n * @param event\r\n * \t\tThe action event to send.\r\n */\r\nprivate void notifyListeners(ActionEvent event) {\r\n    // Iterate over all the listeners and send them the event.\r\n    for (Iterator iterator = _actionListeners.iterator(); iterator.hasNext();) {\r\n        ActionListener listener = ((ActionListener) (iterator.next()));\r\n        listener.actionPerformed(event);\r\n    }\r\n}"},
 {"id":436, "parametername":"int time", "parametertype":"int", "parameterclass":0, "classid":97, "classname":"de.java_chess.javaChess.renderer2d.TimerPanel", "methodid":715, "methodname":"de.java_chess.javaChess.renderer2d.TimerPanel.setCountdown(int)", "isreturn":0, "sourcecode":"/**\r\n * Set the length of the countdown in seconds.\r\n *\r\n * @param time\r\n * \t\tThe length of the countdown.\r\n */\r\npublic void setCountdown(int time) {\r\n    _remainingTime = _time = 1000L * ((long) (time));\r\n    display(_time);\r\n}"},
 {"id":437, "parametername":"long time", "parametertype":"long", "parameterclass":0, "classid":97, "classname":"de.java_chess.javaChess.renderer2d.TimerPanel", "methodid":710, "methodname":"de.java_chess.javaChess.renderer2d.TimerPanel.display(long)", "isreturn":0, "sourcecode":"/**\r\n * Display the current time.\r\n *\r\n * @param time\r\n * \t\tThe current time in milliseconds.\r\n */\r\nvoid display(long time) {\r\n    // Dont display negative time.\r\n    if (time < 0L) {\r\n        time = 0L;\r\n    }\r\n    if (!(isCountdown())) {\r\n        time = (_time) - time;\r\n    }\r\n    int timeSec = ((int) (time / 1000L));// Display accurate to  1 s.\r\n\r\n    StringBuffer timeString = new StringBuffer();\r\n    int hours = timeSec / 3600;\r\n    timeString.append((\"\" + hours));\r\n    int minutes = (timeSec / 60) % 60;\r\n    timeString.append(((minutes < 10 ? \":0\" : \":\") + minutes));\r\n    int seconds = timeSec % 60;\r\n    timeString.append(((seconds < 10 ? \":0\" : \":\") + seconds));\r\n    _display.setText(timeString.toString());\r\n    _display.paintImmediately(0, 0, TimerPanel._displayWidth, TimerPanel._displayHeight);\r\n}"},
 {"id":438, "parametername":"boolean countdown", "parametertype":"boolean", "parameterclass":0, "classid":97, "classname":"de.java_chess.javaChess.renderer2d.TimerPanel", "methodid":716, "methodname":"de.java_chess.javaChess.renderer2d.TimerPanel.setCountingDirection(boolean)", "isreturn":0, "sourcecode":"/**\r\n * Set the counting direction.\r\n *\r\n * @param countdown\r\n * \t\tFlag to indicate, if we want a countdown.\r\n */\r\nprivate final void setCountingDirection(boolean countdown) {\r\n    _countdown = countdown;\r\n}"},
 {"id":439, "parametername":"ActionListener listener", "parametertype":"java.awt.event.ActionListener", "parameterclass":0, "classid":99, "classname":"de.java_chess.javaChess.timer.GameTimer", "methodid":721, "methodname":"de.java_chess.javaChess.timer.GameTimer.addActionListener(java.awt.event.ActionListener)", "isreturn":0, "sourcecode":"/**\r\n * Add a action listener to the timer.\r\n *\r\n * @param listener\r\n * \t\tThe action listener to add.\r\n */\r\nvoid addActionListener(ActionListener listener);"},
 {"id":440, "parametername":"Object[] items", "parametertype":"java.lang.Object[]", "parameterclass":0, "classid":100, "classname":"de.java_chess.javaChess.util.ArrayStackIterator", "methodid":726, "methodname":"de.java_chess.javaChess.util.ArrayStackIterator.-init-(java.lang.Object[],int)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new iterator instance.\r\n *\r\n * @param items\r\n * \t\tThe array with the items.\r\n * @param nItems\r\n * \t\tThe number of items (since the array is most likely longer).\r\n */\r\npublic ArrayStackIterator(Object[] items, int nItems) {\r\n    _items = items;\r\n    _nItems = nItems;\r\n    _curElement = 0;\r\n}"},
 {"id":441, "parametername":"int nItems", "parametertype":"int", "parameterclass":0, "classid":100, "classname":"de.java_chess.javaChess.util.ArrayStackIterator", "methodid":726, "methodname":"de.java_chess.javaChess.util.ArrayStackIterator.-init-(java.lang.Object[],int)", "isreturn":0, "sourcecode":"// Constructors\r\n/**\r\n * Create a new iterator instance.\r\n *\r\n * @param items\r\n * \t\tThe array with the items.\r\n * @param nItems\r\n * \t\tThe number of items (since the array is most likely longer).\r\n */\r\npublic ArrayStackIterator(Object[] items, int nItems) {\r\n    _items = items;\r\n    _nItems = nItems;\r\n    _curElement = 0;\r\n}"},
 {"id":442, "parametername":"String location", "parametertype":"java.lang.String", "parameterclass":0, "classid":101, "classname":"de.java_chess.javaChess.util.ResourceLoader", "methodid":731, "methodname":"de.java_chess.javaChess.util.ResourceLoader.addLocation(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Add a new location to load resources from.\r\n *\r\n * @param location\r\n * \t\tThe location to use.\r\n */\r\npublic final void addLocation(String location) {\r\n    if (!(location.endsWith(\"/\"))) {\r\n        location += \"/\";\r\n    }\r\n    _locations.add(location);\r\n}"},
 {"id":443, "parametername":"String imageName", "parametertype":"java.lang.String", "parameterclass":0, "classid":101, "classname":"de.java_chess.javaChess.util.ResourceLoader", "methodid":733, "methodname":"de.java_chess.javaChess.util.ResourceLoader.loadImage(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Load an image resource.\r\n *\r\n * @return The image resource, if it was found or null otherwise.\r\n */\r\npublic final Image loadImage(String imageName) {\r\n    Image result = null;\r\n    for (Iterator iter = _locations.iterator(); iter.hasNext();) {\r\n        try {\r\n            result = Toolkit.getDefaultToolkit().getImage(new URL(((iter.next()) + imageName)));\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        } catch (MalformedURLException ignored) {\r\n        }\r\n    }\r\n    return null;// Image not found.\r\n\r\n}"},
 {"id":444, "parametername":"int type", "parametertype":"int", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":734, "methodname":"de.java_chess.javaChess.util.StringTextDocument.-init-(int,int)", "isreturn":0, "sourcecode":"/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * \t\tThe number of allowed character to enter in the JTextField\r\n */\r\npublic StringTextDocument(int type, int characterCount) {\r\n    super();\r\n    iCharacterCount = characterCount;\r\n    iType = type;\r\n}"},
 {"id":445, "parametername":"int characterCount", "parametertype":"int", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":734, "methodname":"de.java_chess.javaChess.util.StringTextDocument.-init-(int,int)", "isreturn":0, "sourcecode":"/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * \t\tThe number of allowed character to enter in the JTextField\r\n */\r\npublic StringTextDocument(int type, int characterCount) {\r\n    super();\r\n    iCharacterCount = characterCount;\r\n    iType = type;\r\n}"},
 {"id":446, "parametername":"int offset", "parametertype":"int", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":736, "methodname":"de.java_chess.javaChess.util.StringTextDocument.insertString(int,java.lang.String,javax.swing.text.AttributeSet)", "isreturn":0, "sourcecode":"/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * \t\tThe number of allowed character to enter in the JTextField\r\n * @param checkForNumbers\r\n * \t\tFlag whether the string to enter has to be parsed for\r\n * \t\tnumbers >0 only\r\n */\r\n// public StringTextDocument(int characterCount, boolean checkForNumbers)\r\n// {\r\n// super();\r\n// this.iCharacterCount = characterCount;\r\n// this.bCheckForNumbers = checkForNumbers;\r\n// }\r\n/**\r\n * This method has to be overwritten for personal use. The code below is taken\r\n * from the source mentioned in the class description\r\n */\r\npublic void insertString(int offset, String s, AttributeSet attributeSet) throws BadLocationException {\r\n    if (s == null)\r\n        return;\r\n\r\n    String oldString = getText(0, getLength());\r\n    String newString = ((oldString.substring(0, offset)) + s) + (oldString.substring(offset));\r\n    if (canBecomeValid(newString))\r\n        super.insertString(offset, s, attributeSet);\r\n\r\n}"},
 {"id":447, "parametername":"String s", "parametertype":"java.lang.String", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":736, "methodname":"de.java_chess.javaChess.util.StringTextDocument.insertString(int,java.lang.String,javax.swing.text.AttributeSet)", "isreturn":0, "sourcecode":"/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * \t\tThe number of allowed character to enter in the JTextField\r\n * @param checkForNumbers\r\n * \t\tFlag whether the string to enter has to be parsed for\r\n * \t\tnumbers >0 only\r\n */\r\n// public StringTextDocument(int characterCount, boolean checkForNumbers)\r\n// {\r\n// super();\r\n// this.iCharacterCount = characterCount;\r\n// this.bCheckForNumbers = checkForNumbers;\r\n// }\r\n/**\r\n * This method has to be overwritten for personal use. The code below is taken\r\n * from the source mentioned in the class description\r\n */\r\npublic void insertString(int offset, String s, AttributeSet attributeSet) throws BadLocationException {\r\n    if (s == null)\r\n        return;\r\n\r\n    String oldString = getText(0, getLength());\r\n    String newString = ((oldString.substring(0, offset)) + s) + (oldString.substring(offset));\r\n    if (canBecomeValid(newString))\r\n        super.insertString(offset, s, attributeSet);\r\n\r\n}"},
 {"id":448, "parametername":"AttributeSet attributeSet", "parametertype":"javax.swing.text.AttributeSet", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":736, "methodname":"de.java_chess.javaChess.util.StringTextDocument.insertString(int,java.lang.String,javax.swing.text.AttributeSet)", "isreturn":0, "sourcecode":"/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * \t\tThe number of allowed character to enter in the JTextField\r\n * @param checkForNumbers\r\n * \t\tFlag whether the string to enter has to be parsed for\r\n * \t\tnumbers >0 only\r\n */\r\n// public StringTextDocument(int characterCount, boolean checkForNumbers)\r\n// {\r\n// super();\r\n// this.iCharacterCount = characterCount;\r\n// this.bCheckForNumbers = checkForNumbers;\r\n// }\r\n/**\r\n * This method has to be overwritten for personal use. The code below is taken\r\n * from the source mentioned in the class description\r\n */\r\npublic void insertString(int offset, String s, AttributeSet attributeSet) throws BadLocationException {\r\n    if (s == null)\r\n        return;\r\n\r\n    String oldString = getText(0, getLength());\r\n    String newString = ((oldString.substring(0, offset)) + s) + (oldString.substring(offset));\r\n    if (canBecomeValid(newString))\r\n        super.insertString(offset, s, attributeSet);\r\n\r\n}"},
 {"id":449, "parametername":"String sNewString", "parametertype":"java.lang.String", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":737, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValid(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Parse the string for number with value > 0\r\n *\r\n * @param sNewString\r\n * \t\tThe string to parse\r\n * @return <code>true</code> when the given string is a number with value > 0\r\n */\r\nprivate boolean isValid(String sNewString) {\r\n    try {\r\n        int iVal = Integer.parseInt(sNewString);\r\n        if (iVal > 0)\r\n            return true;\r\n\r\n        return false;\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}"},
 {"id":450, "parametername":"String s", "parametertype":"java.lang.String", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":735, "methodname":"de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)", "isreturn":0, "sourcecode":"/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * \t\tThe string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}"},
 {"id":451, "parametername":"char charToCheck", "parametertype":"char", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":738, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValidLine(char)", "isreturn":0, "sourcecode":"/**\r\n * Checks the character for being between a and h which limit the chessboard lines\r\n *\r\n * @param charToCheck\r\n * \t\tThe character to check\r\n * @return <code>true</code> when between a and h\r\n */\r\nprivate boolean isValidLine(char charToCheck) {\r\n    if (((charToCheck >= a) && (charToCheck <= h)) || ((charToCheck >= A) && (charToCheck <= H))) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"},
 {"id":452, "parametername":"String sString", "parametertype":"java.lang.String", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":739, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * \t\tThe string to parse\r\n * @param bEnPassantSquare\r\n * \t\tFlag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"},
 {"id":453, "parametername":"boolean bEnPassantSquare", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":739, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)", "isreturn":0, "sourcecode":"/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * \t\tThe string to parse\r\n * @param bEnPassantSquare\r\n * \t\tFlag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"},
 {"id":454, "parametername":"JDialog dialog", "parametertype":"javax.swing.JDialog", "parameterclass":0, "classid":103, "classname":"de.java_chess.javaChess.util.Tools", "methodid":741, "methodname":"de.java_chess.javaChess.util.Tools.setDialogToCenter(javax.swing.JDialog)", "isreturn":0, "sourcecode":"/**\r\n * Sets the Dialog to the center of the screen\r\n *\r\n * @param dialog\r\n * \t\tThe dialog which is to be centered on the screen\r\n */\r\npublic static void setDialogToCenter(JDialog dialog) {\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    Dimension dialogSize = dialog.getSize();\r\n    dialog.setLocation((((screenSize.width) - (dialogSize.width)) / 2), (((screenSize.height) - (dialogSize.height)) / 2));\r\n}"},
 {"id":455, "parametername":"int capacity", "parametertype":"int", "parameterclass":0, "classid":104, "classname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack", "methodid":743, "methodname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.-init-(int)", "isreturn":0, "sourcecode":"/**\r\n * Create a new stack instance with a given initial\r\n * capacity.\r\n *\r\n * @param capacity\r\n * \t\tThe initial capacity.\r\n */\r\npublic UnsynchronizedArrayStack(int capacity) {\r\n    _nItems = 0;\r\n    _items = new Object[capacity];\r\n}"},
 {"id":456, "parametername":"Object item", "parametertype":"java.lang.Object", "parameterclass":0, "classid":104, "classname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack", "methodid":750, "methodname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.push(java.lang.Object)", "isreturn":0, "sourcecode":"/**\r\n * Push an item on the stack.\r\n *\r\n * @param item\r\n * \t\tThe item to push on the stack.\r\n */\r\npublic final void push(Object item) {\r\n    try {\r\n        _items[_nItems] = item;\r\n        (_nItems)++;\r\n    } catch (ArrayIndexOutOfBoundsException ae) {\r\n        increaseCapacity();\r\n        push(item);\r\n    }\r\n}"},
 {"id":457, "parametername":"Object o", "parametertype":"java.lang.Object", "parameterclass":0, "classid":104, "classname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack", "methodid":751, "methodname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.search(java.lang.Object)", "isreturn":0, "sourcecode":"/**\r\n * Return the position of a object on the stack, or -1 if it\r\n * is not found.\r\n *\r\n * @return The position of the object on the stack.\r\n */\r\npublic final int search(Object o) {\r\n    for (int i = 0; i < (_nItems); i++) {\r\n        if (_items[i].equals(o)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"},
 {"id":458, "parametername":"return false", "parametertype":"boolean", "parameterclass":0, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":3, "methodname":"de.java_chess.javaChess.GameController.computerPly()", "isreturn":1, "sourcecode":"/**\r\n * Let the computer make a move.\r\n */\r\npublic final boolean computerPly() {\r\n    Ply nextPly = getEngine().computeBestPly();\r\n    if (nextPly == null) {\r\n        System.out.println(\"No computer move returned\");\r\n        return false;\r\n    } else {\r\n        doPly(nextPly);\r\n        getEngine().startPermanentBrain();\r\n        return true;\r\n    }\r\n}"},
 {"id":459, "parametername":"return true", "parametertype":"boolean", "parameterclass":0, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":3, "methodname":"de.java_chess.javaChess.GameController.computerPly()", "isreturn":1, "sourcecode":"/**\r\n * Let the computer make a move.\r\n */\r\npublic final boolean computerPly() {\r\n    Ply nextPly = getEngine().computeBestPly();\r\n    if (nextPly == null) {\r\n        System.out.println(\"No computer move returned\");\r\n        return false;\r\n    } else {\r\n        doPly(nextPly);\r\n        getEngine().startPermanentBrain();\r\n        return true;\r\n    }\r\n}"},
 {"id":460, "parametername":"return new CastlingPlyImpl(source, true)", "parametertype":"boolean", "parameterclass":0, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":4, "methodname":"de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}"},
 {"id":461, "parametername":"return new CastlingPlyImpl(source, false)", "parametertype":"boolean", "parameterclass":0, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":4, "methodname":"de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}"},
 {"id":462, "parametername":"// Create and return a new transformation ply.\r\nreturn new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null))", "parametertype":"de.java_chess.javaChess.ply.TransformationPlyImpl", "parameterclass":78, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":4, "methodname":"de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}"},
 {"id":463, "parametername":"return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)))", "parametertype":"int", "parameterclass":0, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":4, "methodname":"de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}"},
 {"id":464, "parametername":"return ply// Return the original ply\r\n", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":4, "methodname":"de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}"},
 {"id":465, "parametername":"return ((_gameState) == (GameState.CHECKMATE)) || ((_gameState) == (GameState.DRAW))", "parametertype":"boolean", "parameterclass":0, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":6, "methodname":"de.java_chess.javaChess.GameController.gameOver(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Check if the game is over.\r\n *\r\n * @param white\r\n * \t\tTrue, if white is about to move.\r\n * @return true, if the game is over.\r\n */\r\nprivate final boolean gameOver(boolean white) {\r\n    _gameState = getEngine().getCurrentGameState(white);\r\n    return ((_gameState) == (GameState.CHECKMATE)) || ((_gameState) == (GameState.DRAW));\r\n}"},
 {"id":466, "parametername":"return _board", "parametertype":"de.java_chess.javaChess.GameController", "parameterclass":1, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":7, "methodname":"de.java_chess.javaChess.GameController.getBoard()", "isreturn":1, "sourcecode":"/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\nfinal Board getBoard() {\r\n    return _board;\r\n}"},
 {"id":467, "parametername":"return _engine", "parametertype":"de.java_chess.javaChess.GameController", "parameterclass":1, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":8, "methodname":"de.java_chess.javaChess.GameController.getEngine()", "isreturn":1, "sourcecode":"/**\r\n * Get the current chess engine.\r\n *\r\n * @return The current chess engine.\r\n */\r\nfinal ChessEngine getEngine() {\r\n    return _engine;\r\n}"},
 {"id":468, "parametername":"return _game", "parametertype":"de.java_chess.javaChess.GameController", "parameterclass":1, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":9, "methodname":"de.java_chess.javaChess.GameController.getGame()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}"},
 {"id":469, "parametername":"return _gameNotation", "parametertype":"de.java_chess.javaChess.GameController", "parameterclass":1, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":10, "methodname":"de.java_chess.javaChess.GameController.getGameNotation()", "isreturn":1, "sourcecode":"/**\r\n * Get the current game notation.\r\n *\r\n * @return The current game notation.\r\n */\r\npublic final GameNotation getGameNotation() {\r\n    return _gameNotation;\r\n}"},
 {"id":470, "parametername":"return _gameTimer", "parametertype":"de.java_chess.javaChess.GameController", "parameterclass":1, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":11, "methodname":"de.java_chess.javaChess.GameController.getGameTimer()", "isreturn":1, "sourcecode":"/**\r\n * Get the current game timer.\r\n *\r\n * @return The current game timer.\r\n */\r\nfinal GameTimer getGameTimer() {\r\n    return _gameTimer;\r\n}"},
 {"id":471, "parametername":"return _renderer", "parametertype":"de.java_chess.javaChess.GameController", "parameterclass":1, "classid":1, "classname":"de.java_chess.javaChess.GameController", "methodid":12, "methodname":"de.java_chess.javaChess.GameController.getRenderer()", "isreturn":1, "sourcecode":"/**\r\n * Get the renderer.\r\n *\r\n * @return The current renderer.\r\n */\r\nfinal ChessBoardRenderer getRenderer() {\r\n    return _renderer;\r\n}"},
 {"id":472, "parametername":"return JavaChess._instance", "parametertype":"de.java_chess.javaChess.JavaChess", "parameterclass":3, "classid":3, "classname":"de.java_chess.javaChess.JavaChess", "methodid":28, "methodname":"de.java_chess.javaChess.JavaChess.getInstance()", "isreturn":1, "sourcecode":"/**\r\n * Get the instance of this chess app.\r\n *\r\n * @return The instance of this chess app.\r\n */\r\npublic static final JavaChess getInstance() {\r\n    return JavaChess._instance;\r\n}"},
 {"id":473, "parametername":"return item", "parametertype":"javax.swing.JMenuItem", "parameterclass":0, "classid":3, "classname":"de.java_chess.javaChess.JavaChess", "methodid":29, "methodname":"de.java_chess.javaChess.JavaChess.getMenuItem(de.java_chess.javaChess.action.JavaChessAction)", "isreturn":1, "sourcecode":"/**\r\n * Create a return a menu item for a given action.\r\n *\r\n * @param action\r\n * \t\tThe action.\r\n * @return The menu item for this action.\r\n */\r\nprivate JMenuItem getMenuItem(JavaChessAction action) {\r\n    JMenuItem item = new JMenuItem(action.getName());\r\n    item.addActionListener(action);\r\n    return item;\r\n}"},
 {"id":474, "parametername":"return this.getSize()", "parametertype":"de.java_chess.javaChess.JavaChess", "parameterclass":3, "classid":3, "classname":"de.java_chess.javaChess.JavaChess", "methodid":32, "methodname":"de.java_chess.javaChess.JavaChess.packFrame()", "isreturn":1, "sourcecode":"private Dimension packFrame() {\r\n    boolean packFrame = true;\r\n    if (packFrame) {\r\n        pack();\r\n    } else {\r\n        validate();\r\n    }\r\n    return this.getSize();\r\n}"},
 {"id":475, "parametername":"return getShortDescription()", "parametertype":"de.java_chess.javaChess.action.JavaChessAction", "parameterclass":6, "classid":6, "classname":"de.java_chess.javaChess.action.JavaChessAction", "methodid":43, "methodname":"de.java_chess.javaChess.action.JavaChessAction.getName()", "isreturn":1, "sourcecode":"/**\r\n * Get the name of this action (which is currently the short description).\r\n *\r\n * @return The name of this action.\r\n */\r\npublic final String getName() {\r\n    return getShortDescription();\r\n}"},
 {"id":476, "parametername":"return ((String) (getValue(Action.SHORT_DESCRIPTION)))", "parametertype":"javax.swing.Action", "parameterclass":0, "classid":6, "classname":"de.java_chess.javaChess.action.JavaChessAction", "methodid":44, "methodname":"de.java_chess.javaChess.action.JavaChessAction.getShortDescription()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the short description (the name) of this action.\r\n *\r\n * @return The short description of this action.\r\n */\r\npublic String getShortDescription() {\r\n    return ((String) (getValue(Action.SHORT_DESCRIPTION)));\r\n}"},
 {"id":477, "parametername":"return SaveGameAsAction._pgnFileFilter", "parametertype":"de.java_chess.javaChess.action.SaveGameAsAction", "parameterclass":10, "classid":10, "classname":"de.java_chess.javaChess.action.SaveGameAsAction", "methodid":55, "methodname":"de.java_chess.javaChess.action.SaveGameAsAction.getPGNFileFilter()", "isreturn":1, "sourcecode":"/**\r\n * Get a PGN file filter.\r\n *\r\n * @return A PGN file filter.\r\n */\r\npublic static PGNFileFilter getPGNFileFilter() {\r\n    // To avoid the instanciation of too many object at app startup,\r\n    // less important object are created as needed.\r\n    if (null == (SaveGameAsAction._pgnFileFilter)) {\r\n        SaveGameAsAction._pgnFileFilter = new PGNFileFilter();\r\n    }\r\n    return SaveGameAsAction._pgnFileFilter;\r\n}"},
 {"id":478, "parametername":"return clone", "parametertype":"de.java_chess.javaChess.bitboard.BitBoardImpl", "parameterclass":12, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":61, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.clone()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Create a clone of this board.\r\n *\r\n * @return A clone of this board.\r\n */\r\npublic final Object clone() {\r\n    BitBoardImpl clone = new BitBoardImpl();\r\n    for (int i = 0; i < 4; i++) {\r\n        clone._boardLayer[i] = _boardLayer[i];\r\n    }\r\n    return clone;\r\n}"},
 {"id":479, "parametername":"return (((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3])) & (white ? _boardLayer[0] : ~(_boardLayer[0]))", "parametertype":"int", "parameterclass":0, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":64, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getAllPiecesForColor(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get all white or black pieces.\r\n *\r\n * @param white\r\n * \t\ttrue, if the white pieces are requested,\r\n * \t\tfalse for the black pieces.\r\n */\r\npublic final long getAllPiecesForColor(boolean white) {\r\n    return (((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3])) & (white ? _boardLayer[0] : ~(_boardLayer[0]));\r\n}"},
 {"id":480, "parametername":"return newBoard", "parametertype":"de.java_chess.javaChess.bitboard.BitBoard", "parameterclass":11, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":65, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\npublic final Board getBoardAfterPly(Ply ply) {\r\n    BitBoard newBoard = ((BitBoard) (clone()));\r\n    newBoard.doPly(ply);\r\n    return newBoard;\r\n}"},
 {"id":481, "parametername":"return buffer// Return the buffer with the bytes.\r\n", "parametertype":"byte", "parameterclass":0, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":66, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getBytes()", "isreturn":1, "sourcecode":"/**\r\n * Get the board as a byte stream.\r\n *\r\n * @return The board as a array of bytes.\r\n */\r\npublic final byte[] getBytes() {\r\n    // A buffer for the bytes.\r\n    byte[] buffer = new byte[32];\r\n    int bufferIndex = 0;\r\n    for (int layer = 0; layer < 4; layer++) {\r\n        // Get the current layer.\r\n        long currentLayer = _boardLayer[layer];\r\n        // Now shift the layer in the buffer.\r\n        for (int bytePos = 0; bytePos < 8; bytePos++) {\r\n            buffer[(bufferIndex++)] = ((byte) (((int) (currentLayer)) & 255));\r\n            currentLayer >>= 8;\r\n        }\r\n    }\r\n    return buffer;// Return the buffer with the bytes.\r\n\r\n}"},
 {"id":482, "parametername":"return ~(((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3]))", "parametertype":"int", "parameterclass":0, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":67, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getEmptySquares()", "isreturn":1, "sourcecode":"/**\r\n * Get a bitmask with all the free squares.\r\n *\r\n * @return A bitmask with all the empty squares marked by a 1 bit.\r\n */\r\npublic final long getEmptySquares() {\r\n    return ~(((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3]));\r\n}"},
 {"id":483, "parametername":"return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))))", "parametertype":"int", "parameterclass":0, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":68, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getPiece(de.java_chess.javaChess.position.Position)", "isreturn":1, "sourcecode":"/**\r\n * Get the piece of a given position, or null of the square is empty.\r\n *\r\n * @param position\r\n * \t\tThe position of the piece.\r\n * @return The piece of the square or null, of the square is empty.\r\n */\r\npublic final Piece getPiece(Position position) {\r\n    int bitpos = position.getSquareIndex();\r\n    int pieceType = ((((int) ((_boardLayer[1]) >> bitpos)) & 1) | ((((int) ((_boardLayer[2]) >> bitpos)) & 1) << 1)) | ((((int) ((_boardLayer[3]) >> bitpos)) & 1) << 2);\r\n    return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))));\r\n}"},
 {"id":484, "parametername":"return ((((pieceTypeColor & 1) != 0 ? _boardLayer[0] : ~(_boardLayer[0])) & ((pieceTypeColor & 2) != 0 ? _boardLayer[1] : ~(_boardLayer[1]))) & ((pieceTypeColor & 4) != 0 ? _boardLayer[2] : ~(_boardLayer[2]))) & ((pieceTypeColor & 8) != 0 ? _boardLayer[3] : ~(_boardLayer[3]))", "parametertype":"int", "parameterclass":0, "classid":12, "classname":"de.java_chess.javaChess.bitboard.BitBoardImpl", "methodid":69, "methodname":"de.java_chess.javaChess.bitboard.BitBoardImpl.getPositionOfPieces(int)", "isreturn":1, "sourcecode":"/**\r\n * Get the positions of some pieces as a long (64 bit wide) bitmask.\r\n *\r\n * @param pieceTypeColor\r\n * \t\tThe color and type of the pieces.\r\n */\r\npublic final long getPositionOfPieces(int pieceTypeColor) {\r\n    return ((((pieceTypeColor & 1) != 0 ? _boardLayer[0] : ~(_boardLayer[0])) & ((pieceTypeColor & 2) != 0 ? _boardLayer[1] : ~(_boardLayer[1]))) & ((pieceTypeColor & 4) != 0 ? _boardLayer[2] : ~(_boardLayer[2]))) & ((pieceTypeColor & 8) != 0 ? _boardLayer[3] : ~(_boardLayer[3]));\r\n}"},
 {"id":485, "parametername":"return new BufferedReader(new InputStreamReader(resourceURL.openStream()))", "parametertype":"java.net.URL", "parameterclass":0, "classid":14, "classname":"de.java_chess.javaChess.dialogs.DialogAbout", "methodid":82, "methodname":"de.java_chess.javaChess.dialogs.DialogAbout.getDialogResource(java.lang.String)", "isreturn":1, "sourcecode":"/**\r\n * Get a dialog resource as a reader.\r\n *\r\n * @param resourceName\r\n * \t\tThe name of the resource.\r\n * @return A reader to read from.\r\n */\r\nprivate final Reader getDialogResource(String resourceName) {\r\n    try {\r\n        // Create a URL into the jar.\r\n        URL resourceURL = new URL((\"jar:file:javaChess.jar!/de/java_chess/javaChess/dialogs/resources/\" + resourceName));\r\n        return new BufferedReader(new InputStreamReader(resourceURL.openStream()));\r\n    } catch (IOException ie) {\r\n        // Ugly! But the same behaviour than before...\r\n        return new StringReader(ie.getMessage());\r\n    }\r\n}"},
 {"id":486, "parametername":"// Ugly! But the same behaviour than before...\r\nreturn new StringReader(ie.getMessage())", "parametertype":"java.io.IOException", "parameterclass":0, "classid":14, "classname":"de.java_chess.javaChess.dialogs.DialogAbout", "methodid":82, "methodname":"de.java_chess.javaChess.dialogs.DialogAbout.getDialogResource(java.lang.String)", "isreturn":1, "sourcecode":"/**\r\n * Get a dialog resource as a reader.\r\n *\r\n * @param resourceName\r\n * \t\tThe name of the resource.\r\n * @return A reader to read from.\r\n */\r\nprivate final Reader getDialogResource(String resourceName) {\r\n    try {\r\n        // Create a URL into the jar.\r\n        URL resourceURL = new URL((\"jar:file:javaChess.jar!/de/java_chess/javaChess/dialogs/resources/\" + resourceName));\r\n        return new BufferedReader(new InputStreamReader(resourceURL.openStream()));\r\n    } catch (IOException ie) {\r\n        // Ugly! But the same behaviour than before...\r\n        return new StringReader(ie.getMessage());\r\n    }\r\n}"},
 {"id":487, "parametername":"return DialogAbout._instance", "parametertype":"de.java_chess.javaChess.dialogs.DialogAbout", "parameterclass":14, "classid":14, "classname":"de.java_chess.javaChess.dialogs.DialogAbout", "methodid":83, "methodname":"de.java_chess.javaChess.dialogs.DialogAbout.getInstance()", "isreturn":1, "sourcecode":"// //////////////////////////////////////////\r\n// ////////////// Methods //////////////////\r\n// /////////////////////////////////////////\r\n/**\r\n * Get the one and only instance of this class\r\n * (singleton pattern).\r\n *\r\n * @return The only instance of this class.\r\n */\r\npublic static DialogAbout getInstance() {\r\n    // If theres no instance yet, create one.\r\n    if ((DialogAbout._instance) == null) {\r\n        DialogAbout._instance = new DialogAbout();\r\n    }\r\n    return DialogAbout._instance;\r\n}"},
 {"id":488, "parametername":"return ((byte) ((pieceColor) & ((byte) (1))))", "parametertype":"int", "parameterclass":0, "classid":16, "classname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel", "methodid":90, "methodname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.getColor()", "isreturn":1, "sourcecode":"/**\r\n * Get the color of this piece.\r\n *\r\n * @return The color of this piece.\r\n */\r\npublic byte getColor() {\r\n    return ((byte) ((pieceColor) & ((byte) (1))));\r\n}"},
 {"id":489, "parametername":"// To avoid the instanciation of a image each time, just reuse\r\n// the images of the icons.\r\nreturn _pieceIcon[this.getColor()][type].getImage()", "parametertype":"javax.swing.ImageIcon", "parameterclass":0, "classid":16, "classname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel", "methodid":91, "methodname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.getSelectedPieceImage()", "isreturn":1, "sourcecode":"public Image getSelectedPieceImage() {\r\n    byte type = this.getType();\r\n    if (type == 0) {\r\n        type = Piece.KING;\r\n    }\r\n    // To avoid the instanciation of a image each time, just reuse\r\n    // the images of the icons.\r\n    return _pieceIcon[this.getColor()][type].getImage();\r\n}"},
 {"id":490, "parametername":"return ((byte) ((pieceColor) >> 1))", "parametertype":"int", "parameterclass":0, "classid":16, "classname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel", "methodid":92, "methodname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.getType()", "isreturn":1, "sourcecode":"// -----------------------------------------------------------------------\r\n// Interface methods:\r\n// -----------------------------------------------------------------------\r\n/**\r\n * Get the type of this piece.\r\n *\r\n * @return The type of this piece.\r\n */\r\npublic byte getType() {\r\n    return ((byte) ((pieceColor) >> 1));\r\n}"},
 {"id":491, "parametername":"return this.pieceColor", "parametertype":"de.java_chess.javaChess.dialogs.PieceSelectionPanel", "parameterclass":16, "classid":16, "classname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel", "methodid":93, "methodname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.getTypeAndColor()", "isreturn":1, "sourcecode":"/**\r\n * Get type and color as 1 byte.\r\n *\r\n * @return Type and color and 1 byte.\r\n */\r\npublic byte getTypeAndColor() {\r\n    return this.pieceColor;\r\n}"},
 {"id":492, "parametername":"return ((this.pieceColor) & 1) != 0", "parametertype":"int", "parameterclass":0, "classid":16, "classname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel", "methodid":95, "methodname":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.isWhite()", "isreturn":1, "sourcecode":"/**\r\n * Check, if this piece is white.\r\n *\r\n * @return true, if this piece is white, false if black.\r\n */\r\npublic boolean isWhite() {\r\n    return ((this.pieceColor) & 1) != 0;\r\n}"},
 {"id":493, "parametername":"return this.jtNewName.getText()", "parametertype":"javax.swing.text.JTextComponent", "parameterclass":0, "classid":17, "classname":"de.java_chess.javaChess.dialogs.PlayerDialog", "methodid":102, "methodname":"de.java_chess.javaChess.dialogs.PlayerDialog.getNewName()", "isreturn":1, "sourcecode":"/**\r\n * Returns the name from within the JTextField\r\n *\r\n * @return The new name\r\n */\r\npublic String getNewName() {\r\n    return this.jtNewName.getText();\r\n}"},
 {"id":494, "parametername":"return TransformationDialog._instance", "parametertype":"de.java_chess.javaChess.dialogs.TransformationDialog", "parameterclass":19, "classid":19, "classname":"de.java_chess.javaChess.dialogs.TransformationDialog", "methodid":115, "methodname":"de.java_chess.javaChess.dialogs.TransformationDialog.getInstance()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the only instance of this class.\r\n *\r\n * @return The only instance of this class.\r\n */\r\npublic static final TransformationDialog getInstance() {\r\n    if ((TransformationDialog._instance) == null) {\r\n        TransformationDialog._instance = new TransformationDialog(null, true);\r\n    }\r\n    return TransformationDialog._instance;\r\n}"},
 {"id":495, "parametername":"return _pieceType", "parametertype":"de.java_chess.javaChess.dialogs.TransformationDialog", "parameterclass":19, "classid":19, "classname":"de.java_chess.javaChess.dialogs.TransformationDialog", "methodid":116, "methodname":"de.java_chess.javaChess.dialogs.TransformationDialog.getPieceType()", "isreturn":1, "sourcecode":"/**\r\n * Get the currently selected piece type.\r\n *\r\n * @return The currently selected piece type.\r\n */\r\npublic byte getPieceType() {\r\n    return _pieceType;\r\n}"},
 {"id":496, "parametername":"// Return a weighted score\r\nreturn ((short) (((((short) (2)) * positionalValue) + (((short) (7)) * materialValue)) + checkValue))", "parametertype":"int", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":125, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze()", "isreturn":1, "sourcecode":"/**\r\n * Analyze the current board.\r\n */\r\npublic final short analyze() {\r\n    // A check thread has a value, too.\r\n    short checkValue = 0;\r\n    // Start with the tests, if one of the players is in check.\r\n    // Its important to start the test with the color that moves next!\r\n    if (whiteHasMoveRight()) {\r\n        if (isInCheck(true)) {\r\n            // If the king of the moving player is in check,\r\n            checkValue += BitBoardAnalyzer.BLACK_WIN;// the player seems to win.\r\n\r\n        }\r\n        if (isInCheck(false)) {\r\n            // If the opponents king is in check,\r\n            checkValue += BitBoardAnalyzer.WHITE_WIN;// the opponent seems to win.\r\n\r\n        }\r\n    } else {\r\n        if (isInCheck(false)) {\r\n            // If the opponents king is in check,\r\n            checkValue += BitBoardAnalyzer.WHITE_WIN;// the opponent seems to win.\r\n\r\n        }\r\n        if (isInCheck(true)) {\r\n            // If the king of the moving player is in check,\r\n            checkValue += BitBoardAnalyzer.BLACK_WIN;// the player seems to win.\r\n\r\n        }\r\n    }\r\n    // Early checks hinder the position building are punished therefore.\r\n    if ((getGame().getNumberOfPlies()) < 12) {\r\n        checkValue = ((short) (checkValue / 4));\r\n    }\r\n    // Now compute the position and material value of all pieces.\r\n    short materialValue = 0;\r\n    // Count the figures and their material value.\r\n    short positionalValue = 0;// Score the position value.\r\n\r\n    // Check the entire board.\r\n    // Use a bitmask to speedup the test for a piece on the square\r\n    long emptySquareMask = getBoard().getEmptySquares();\r\n    // Get the positions of the white and black pawns.\r\n    long[] pawnPos = new long[2];\r\n    pawnPos[0] = getBoard().getPositionOfPieces(((Piece.PAWN) << 1));\r\n    pawnPos[1] = getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1));\r\n    // I reuse the same PositionImpl object to avoid the overhead of\r\n    // object instancing for each square.\r\n    Position pos = new PositionImpl(0);\r\n    for (int i = 0; i < 64; i++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            pos.setSquareIndex(i);\r\n            Piece p = getBoard().getPiece(pos);\r\n            if (p != null) {\r\n                short mValue = 0;\r\n                short pValue = 0;\r\n                // Add the value of the piece\r\n                switch (p.getType()) {\r\n                    case Piece.PAWN :\r\n                        mValue = 10;\r\n                        pValue = BitBoardAnalyzerImpl._pawnPositionalValue[((getGame().getNumberOfPlies()) <= 12 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        // Check, if this pawn could be promoted\r\n                        if (p.isWhite()) {\r\n                            int j = i + 8;\r\n                            Position pos2 = new PositionImpl(0);\r\n                            while (j < 64) {\r\n                                pos2.setSquareIndex(j);\r\n                                Piece p2 = getBoard().getPiece(pos2);\r\n                                if ((p2 != null) && ((p2.getType()) == (Piece.PAWN))) {\r\n                                    pValue -= 2;\r\n                                    break;\r\n                                }\r\n                                j += 8;\r\n                            } \r\n                        } else {\r\n                            int j = i - 8;\r\n                            Position pos2 = new PositionImpl(0);\r\n                            while (j >= 0) {\r\n                                pos2.setSquareIndex(j);\r\n                                Piece p2 = getBoard().getPiece(pos2);\r\n                                if ((p2 != null) && ((p2.getType()) == (Piece.PAWN))) {\r\n                                    pValue -= 2;\r\n                                    break;\r\n                                }\r\n                                j += 8;\r\n                            } \r\n                        }\r\n                        break;\r\n                    case Piece.KNIGHT :\r\n                        pValue = BitBoardAnalyzerImpl._knightPositionalValue[((getGame().getNumberOfPlies()) <= 8 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        if ((getGame().getNumberOfPlies()) < 12) {\r\n                            // Check if this piece blocks a own pawn\r\n                            int row = i >>> 3;\r\n                            if ((((p.isWhite()) && ((row == 2) || (row == 3))) && ((((1L << (i - 8)) | (1L << (i - 16))) & (pawnPos[1])) != 0L)) || (((!(p.isWhite())) && ((row == 4) || (row == 5))) && ((((1L << (i + 8)) | (1L << (i + 16))) & (pawnPos[0])) != 0L))) {\r\n                                pValue -= BitBoardAnalyzerImpl._pawnBlocker;\r\n                            }\r\n                        }\r\n                        mValue = 30;\r\n                        break;\r\n                    case Piece.BISHOP :\r\n                        pValue = BitBoardAnalyzerImpl._bishopPositionalValue[((getGame().getNumberOfPlies()) <= 8 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        if ((getGame().getNumberOfPlies()) <= 12) {\r\n                            // Check if this piece blocks a own pawn\r\n                            int row = i >>> 3;\r\n                            if ((((p.isWhite()) && ((row == 2) || (row == 3))) && ((((1L << (i - 8)) | (1L << (i - 16))) & (pawnPos[1])) != 0L)) || (((!(p.isWhite())) && ((row == 4) || (row == 5))) && ((((1L << (i + 8)) | (1L << (i + 16))) & (pawnPos[0])) != 0L))) {\r\n                                pValue -= BitBoardAnalyzerImpl._pawnBlocker;\r\n                            }\r\n                        }\r\n                        mValue = 30;\r\n                        break;\r\n                    case Piece.ROOK :\r\n                        mValue = 45;\r\n                        pValue = BitBoardAnalyzerImpl._rookPositionalValue[((getGame().getNumberOfPlies()) <= 8 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        break;\r\n                    case Piece.QUEEN :\r\n                        mValue = 80;\r\n                        pValue = BitBoardAnalyzerImpl._queenPositionalValue[((getGame().getNumberOfPlies()) <= 14 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        break;\r\n                    case Piece.KING :\r\n                        pValue = BitBoardAnalyzerImpl._kingPositionalValue[(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        break;\r\n                }\r\n                if (p.isWhite()) {\r\n                    materialValue += mValue;\r\n                    positionalValue += pValue;\r\n                } else {\r\n                    materialValue -= mValue;\r\n                    positionalValue -= pValue;\r\n                }\r\n            }\r\n        }\r\n        // Shift the mask to test the next square\r\n        emptySquareMask >>>= 1;\r\n    }\r\n    // Return a weighted score\r\n    return ((short) (((((short) (2)) * positionalValue) + (((short) (7)) * materialValue)) + checkValue));\r\n}"},
 {"id":497, "parametername":"return analyze()", "parametertype":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "parameterclass":21, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":126, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board to analyze.\r\n * @param white\r\n * \t\tFlag to indicate, if white has the next move.\r\n */\r\npublic final short analyze(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    setMoveRight(white);\r\n    return analyze();\r\n}"},
 {"id":498, "parametername":"return _board", "parametertype":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "parameterclass":21, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":127, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.getBoard()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the currently analyzed board.\r\n *\r\n * @return The currently analyzed board.\r\n */\r\npublic final BitBoard getBoard() {\r\n    return _board;\r\n}"},
 {"id":499, "parametername":"return _game", "parametertype":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "parameterclass":21, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":128, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.getGame()", "isreturn":1, "sourcecode":"/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}"},
 {"id":500, "parametername":"return _plyGenerator", "parametertype":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "parameterclass":21, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":129, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.getPlyGenerator()", "isreturn":1, "sourcecode":"/**\r\n * Get the ply generator.\r\n *\r\n * @return The PlyGenerator.\r\n */\r\nprivate final PlyGenerator getPlyGenerator() {\r\n    return _plyGenerator;\r\n}"},
 {"id":501, "parametername":"return true// King is in check!\r\n", "parametertype":"boolean", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":130, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * \t\tFlag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}"},
 {"id":502, "parametername":"return true// King is in check!\r\n", "parametertype":"boolean", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":130, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * \t\tFlag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}"},
 {"id":503, "parametername":"return true// King is in check!\r\n", "parametertype":"boolean", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":130, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * \t\tFlag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}"},
 {"id":504, "parametername":"return true// King is in check!\r\n", "parametertype":"boolean", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":130, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * \t\tFlag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}"},
 {"id":505, "parametername":"return true// King is in check!\r\n", "parametertype":"boolean", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":130, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * \t\tFlag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}"},
 {"id":506, "parametername":"return true// King is in check!\r\n", "parametertype":"boolean", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":130, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * \t\tFlag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}"},
 {"id":507, "parametername":"return true// King is in check!\r\n", "parametertype":"boolean", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":130, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * \t\tFlag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}"},
 {"id":508, "parametername":"return true// King is in check!\r\n", "parametertype":"boolean", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":130, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * \t\tFlag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}"},
 {"id":509, "parametername":"return true", "parametertype":"boolean", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":130, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * \t\tFlag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}"},
 {"id":510, "parametername":"// Get the positions of all black pawns and compare them with a moved king.\r\nreturn (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L", "parametertype":"int", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":130, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * \t\tFlag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}"},
 {"id":511, "parametername":"// Get the positions of all white pawns and compare them with a moved king.\r\nreturn (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L", "parametertype":"int", "parameterclass":0, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":130, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * \t\tFlag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}"},
 {"id":512, "parametername":"return isInCheck(white)", "parametertype":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "parameterclass":21, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":131, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * \t\tThe board to test.\r\n * @param white\r\n * \t\ttrue, if the white king is checked, false otherwise.\r\n */\r\npublic final boolean isInCheck(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return isInCheck(white);\r\n}"},
 {"id":513, "parametername":"return _whiteMoves", "parametertype":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "parameterclass":21, "classid":21, "classname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl", "methodid":136, "methodname":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.whiteHasMoveRight()", "isreturn":1, "sourcecode":"/**\r\n * Check, if white moves next.\r\n *\r\n * @return true, if white moves next, false otherwise.\r\n */\r\nprivate final boolean whiteHasMoveRight() {\r\n    return _whiteMoves;\r\n}"},
 {"id":514, "parametername":"// Use the byte as a index for a precomputed array\r\n// of bit indexes.\r\nreturn highestBit + (BitUtils._highestBit[bytePart])", "parametertype":"int", "parameterclass":0, "classid":22, "classname":"de.java_chess.javaChess.engine.BitUtils", "methodid":138, "methodname":"de.java_chess.javaChess.engine.BitUtils.getHighestBit(long)", "isreturn":1, "sourcecode":"/**\r\n * Find the index of highest set bit in a long bitmask.\r\n *\r\n * @param bitmask\r\n * \t\tThe bitmask to operate on.\r\n * @return The index of the highest set bit or 0, if no bits are set.\r\n */\r\npublic static final int getHighestBit(long bitmask) {\r\n    int highestBit = 0;\r\n    // The following 3 statements split the 64 bit word down to\r\n    // a byte.\r\n    int dwordPart = ((int) (bitmask >>> 32));\r\n    if (dwordPart != 0) {\r\n        highestBit += 32;\r\n    } else {\r\n        dwordPart = ((int) (bitmask));\r\n    }\r\n    int wordPart = (dwordPart >>> 16) & 65535;\r\n    if (wordPart != 0) {\r\n        highestBit += 16;\r\n    } else {\r\n        wordPart = dwordPart & 65535;\r\n    }\r\n    int bytePart = (wordPart >>> 8) & 255;\r\n    if (bytePart != 0) {\r\n        highestBit += 8;\r\n    } else {\r\n        bytePart = wordPart & 255;\r\n    }\r\n    // Use the byte as a index for a precomputed array\r\n    // of bit indexes.\r\n    return highestBit + (BitUtils._highestBit[bytePart]);\r\n}"},
 {"id":515, "parametername":"return _analyzer.analyze(((BitBoard) (board)), isWhite())", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":158, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.analyzeBoard(de.java_chess.javaChess.board.Board)", "isreturn":1, "sourcecode":"/**\r\n * Compute a score for a game position.\r\n *\r\n * @return A score for the current game position.\r\n */\r\npublic final short analyzeBoard(Board board) {\r\n    return _analyzer.analyze(((BitBoard) (board)), isWhite());\r\n}"},
 {"id":516, "parametername":"return _bestPly.getPly()", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":159, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.computeBestPly()", "isreturn":1, "sourcecode":"/**\r\n * Compute the best ply for the current position.\r\n *\r\n * @return The best known ply for the current position.\r\n */\r\npublic Ply computeBestPly() {\r\n    _bestPly = null;// Remove ply from last computation.\r\n\r\n    long startTime = System.currentTimeMillis();\r\n    if (inOpeningBook()) {\r\n        _bestPly = getOpeningBook().getOpeningBookPly();\r\n        if ((_bestPly) == null) {\r\n            // If theres no ply in the opening book.\r\n            setInOpeningBook(false);\r\n        }\r\n    }\r\n    if ((_bestPly) == null) {\r\n        // If we dont have a ply yet\r\n        start();\r\n        try {\r\n            Thread.sleep(getMaximumSearchTime());\r\n            setSearchStop(true);\r\n            // if( this.bFixedTime == false) {\r\n            _searchThread.join();// Wait for the search thread to end the search at this search depth.\r\n\r\n            // }\r\n            _searchThread = null;// Remove the thread, so it can be recreated for the next move.\r\n\r\n        } catch (InterruptedException ignored) {\r\n        }\r\n    }\r\n    long usedTime = (System.currentTimeMillis()) - startTime;\r\n    if ((_bestPly) != null) {\r\n        if ((this._enginePanel) != null) {\r\n            StringBuffer sOut = new StringBuffer();\r\n            sOut.append(\"Best ply: \");\r\n            sOut.append(_bestPly.getPly().toString());\r\n            sOut.append(\" with score \");\r\n            sOut.append(_bestPly.getScore());\r\n            sOut.append(\" and search depth \");\r\n            sOut.append(getSearchDepth());\r\n            this._enginePanel.modifyText(sOut.toString());\r\n            sOut = new StringBuffer();\r\n            sOut.append(\"Analyzed boards: \");\r\n            sOut.append(getAnalyzedBoards());\r\n            sOut.append(\" in \");\r\n            sOut.append(usedTime);\r\n            sOut.append(\" ms\");\r\n            this._enginePanel.modifyText(sOut.toString());\r\n        }\r\n        if ((this._statusPanel) != null)\r\n            this._statusPanel.setStatusText(\"Your turn...\");\r\n\r\n        return _bestPly.getPly();\r\n    }\r\n    return null;\r\n}"},
 {"id":517, "parametername":"return null", "parametertype":"<nulltype>", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":159, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.computeBestPly()", "isreturn":1, "sourcecode":"/**\r\n * Compute the best ply for the current position.\r\n *\r\n * @return The best known ply for the current position.\r\n */\r\npublic Ply computeBestPly() {\r\n    _bestPly = null;// Remove ply from last computation.\r\n\r\n    long startTime = System.currentTimeMillis();\r\n    if (inOpeningBook()) {\r\n        _bestPly = getOpeningBook().getOpeningBookPly();\r\n        if ((_bestPly) == null) {\r\n            // If theres no ply in the opening book.\r\n            setInOpeningBook(false);\r\n        }\r\n    }\r\n    if ((_bestPly) == null) {\r\n        // If we dont have a ply yet\r\n        start();\r\n        try {\r\n            Thread.sleep(getMaximumSearchTime());\r\n            setSearchStop(true);\r\n            // if( this.bFixedTime == false) {\r\n            _searchThread.join();// Wait for the search thread to end the search at this search depth.\r\n\r\n            // }\r\n            _searchThread = null;// Remove the thread, so it can be recreated for the next move.\r\n\r\n        } catch (InterruptedException ignored) {\r\n        }\r\n    }\r\n    long usedTime = (System.currentTimeMillis()) - startTime;\r\n    if ((_bestPly) != null) {\r\n        if ((this._enginePanel) != null) {\r\n            StringBuffer sOut = new StringBuffer();\r\n            sOut.append(\"Best ply: \");\r\n            sOut.append(_bestPly.getPly().toString());\r\n            sOut.append(\" with score \");\r\n            sOut.append(_bestPly.getScore());\r\n            sOut.append(\" and search depth \");\r\n            sOut.append(getSearchDepth());\r\n            this._enginePanel.modifyText(sOut.toString());\r\n            sOut = new StringBuffer();\r\n            sOut.append(\"Analyzed boards: \");\r\n            sOut.append(getAnalyzedBoards());\r\n            sOut.append(\" in \");\r\n            sOut.append(usedTime);\r\n            sOut.append(\" ms\");\r\n            this._enginePanel.modifyText(sOut.toString());\r\n        }\r\n        if ((this._statusPanel) != null)\r\n            this._statusPanel.setStatusText(\"Your turn...\");\r\n\r\n        return _bestPly.getPly();\r\n    }\r\n    return null;\r\n}"},
 {"id":518, "parametername":"return _analyzedBoards", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":162, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getAnalyzedBoards()", "isreturn":1, "sourcecode":"/**\r\n * Get the number of analyzed boards.\r\n *\r\n * @return The number of analyzed boards.\r\n */\r\npublic final long getAnalyzedBoards() {\r\n    return _analyzedBoards;\r\n}"},
 {"id":519, "parametername":"return _board", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":163, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getBoard()", "isreturn":1, "sourcecode":"/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\npublic Board getBoard() {\r\n    return _board;\r\n}"},
 {"id":520, "parametername":"return validPliesAvailable ? GameState.CHECK : GameState.CHECKMATE", "parametertype":"boolean", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":164, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getCurrentGameState(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get the current game state.\r\n *\r\n * @param white\r\n * \t\tTrue, if the state of the white player is requested.\r\n * @return The current game state.\r\n */\r\npublic final byte getCurrentGameState(boolean white) {\r\n    // Test if the given player is in check.\r\n    boolean inCheck = _analyzer.isInCheck(((BitBoard) (getBoard())), white);\r\n    // Test if the player has valid plies available.\r\n    // The following computation of the available plies is not really efficient,\r\n    // since they are done anyway (either to compute the next computer ply or to\r\n    // check if a user ply is valid). So maybe the plygenerator or the engine should\r\n    // cache the computed plies.\r\n    boolean validPliesAvailable = (_plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white).length) > 0;\r\n    if (inCheck) {\r\n        return validPliesAvailable ? GameState.CHECK : GameState.CHECKMATE;\r\n    } else {\r\n        return validPliesAvailable ? GameState.ONGOING : GameState.DRAW;\r\n    }\r\n}"},
 {"id":521, "parametername":"return validPliesAvailable ? GameState.ONGOING : GameState.DRAW", "parametertype":"boolean", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":164, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getCurrentGameState(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get the current game state.\r\n *\r\n * @param white\r\n * \t\tTrue, if the state of the white player is requested.\r\n * @return The current game state.\r\n */\r\npublic final byte getCurrentGameState(boolean white) {\r\n    // Test if the given player is in check.\r\n    boolean inCheck = _analyzer.isInCheck(((BitBoard) (getBoard())), white);\r\n    // Test if the player has valid plies available.\r\n    // The following computation of the available plies is not really efficient,\r\n    // since they are done anyway (either to compute the next computer ply or to\r\n    // check if a user ply is valid). So maybe the plygenerator or the engine should\r\n    // cache the computed plies.\r\n    boolean validPliesAvailable = (_plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white).length) > 0;\r\n    if (inCheck) {\r\n        return validPliesAvailable ? GameState.CHECK : GameState.CHECKMATE;\r\n    } else {\r\n        return validPliesAvailable ? GameState.ONGOING : GameState.DRAW;\r\n    }\r\n}"},
 {"id":522, "parametername":"return _game", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":165, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getGame()", "isreturn":1, "sourcecode":"/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}"},
 {"id":523, "parametername":"return this.getHashtable().getMaximumSize()", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":166, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getHashSize()", "isreturn":1, "sourcecode":"/**\r\n * Returns the hash size\r\n *\r\n * @return The hashsize\r\n */\r\npublic int getHashSize() {\r\n    return this.getHashtable().getMaximumSize();\r\n}"},
 {"id":524, "parametername":"return _hashtable", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":167, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getHashtable()", "isreturn":1, "sourcecode":"/**\r\n * Get the current hashtable for this ply generator.\r\n *\r\n * @return The current hashtable for this ply generator.\r\n */\r\npublic final PlyHashtable getHashtable() {\r\n    return _hashtable;\r\n}"},
 {"id":525, "parametername":"return _maxSearchTime", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":168, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getMaximumSearchTime()", "isreturn":1, "sourcecode":"/**\r\n * Get the maximum search time.\r\n *\r\n * @return The maximum search time.\r\n */\r\npublic final int getMaximumSearchTime() {\r\n    return _maxSearchTime;\r\n}"},
 {"id":526, "parametername":"// Return the engine menu.\r\nreturn engineMenu", "parametertype":"javax.swing.JMenu", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":169, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getMenu()", "isreturn":1, "sourcecode":"/**\r\n * Return a menu from the chess engine, where the user\r\n * can change the settings.\r\n *\r\n * @return A menu for the engine settings.\r\n */\r\npublic final JMenu getMenu() {\r\n    // Create a new menu.\r\n    JMenu engineMenu = new JMenu(\"Engine\");\r\n    // Add a toggle item for to the permanent brain.\r\n    engineMenu.add((_permanentBrainMenuItem = new JCheckBoxMenuItem(\"Use permanent brain\", usePermanentBrain())));\r\n    _permanentBrainMenuItem.addActionListener(this);\r\n    // Add a menu for the maximum search time\r\n    JMenu searchTimeMenu = new JMenu(\"Search time\");\r\n    // Add a sub-menu for fixed time.\r\n    JMenu searchTimeSubMenuFix = new JMenu(\"Fixed time\");\r\n    // Add a sub-menu for average time.\r\n    JMenu searchTimeSubMenuAv = new JMenu(\"Average time\");\r\n    // Add various options for the fixed search time\r\n    // (maybe a user defined search time should be added, too).\r\n    buttonGroupSearchTime = new ButtonGroup();\r\n    _fixSearchTimeMenuItem = new JRadioButtonMenuItem[_searchTime.length];\r\n    for (int st = 0; st < (_searchTime.length); st++) {\r\n        _fixSearchTimeMenuItem[st] = new JRadioButtonMenuItem(((\"\" + (_searchTime[st])) + \" seconds\"));\r\n        _fixSearchTimeMenuItem[st].addActionListener(this);\r\n        if ((_searchTime[st]) == 5) {\r\n            // set initially 5 sec max search time:\r\n            _fixSearchTimeMenuItem[st].setSelected(true);\r\n            this.setMaximumSearchTime(5000);\r\n        }\r\n        buttonGroupSearchTime.add(_fixSearchTimeMenuItem[st]);\r\n        // Add the current search time menu item to its menu.\r\n        searchTimeSubMenuFix.add(_fixSearchTimeMenuItem[st]);\r\n    }\r\n    // Add various options for the average search time\r\n    _avSearchTimeMenuItem = new JRadioButtonMenuItem[_searchTime.length];\r\n    for (int st = 0; st < (_searchTime.length); st++) {\r\n        _avSearchTimeMenuItem[st] = new JRadioButtonMenuItem(((\"\" + (_searchTime[st])) + \" seconds\"));\r\n        _avSearchTimeMenuItem[st].addActionListener(this);\r\n        // Add the current search time menu item to its menu.\r\n        searchTimeSubMenuAv.add(_avSearchTimeMenuItem[st]);\r\n        buttonGroupSearchTime.add(_avSearchTimeMenuItem[st]);\r\n    }\r\n    searchTimeMenu.add(searchTimeSubMenuFix);\r\n    searchTimeMenu.add(searchTimeSubMenuAv);\r\n    // Add the search time menu to the main engine menu.\r\n    engineMenu.add(searchTimeMenu);\r\n    // Add a menu for the hashtable size.\r\n    JMenu hashtableSizeMenu = new JMenu(\"Hashtable size\");\r\n    // Add various options for the hashtable size.\r\n    this.buttonGroupHashSize = new ButtonGroup();\r\n    _hashtableSizeMenuItem = new JRadioButtonMenuItem[_hashtableSizes.length];\r\n    for (int hts = 0; hts < (_hashtableSizes.length); hts++) {\r\n        _hashtableSizeMenuItem[hts] = new JRadioButtonMenuItem(((\"\" + (_hashtableSizes[hts])) + \" entries\"));\r\n        _hashtableSizeMenuItem[hts].addActionListener(this);\r\n        if ((_hashtableSizes[hts]) == 10000) {\r\n            _hashtableSizeMenuItem[hts].setSelected(true);\r\n            getHashtable().setMaximumSize(_hashtableSizes[hts]);\r\n        }\r\n        // Add the current search time menu item to its menu.\r\n        hashtableSizeMenu.add(_hashtableSizeMenuItem[hts]);\r\n        this.buttonGroupHashSize.add(_hashtableSizeMenuItem[hts]);\r\n    }\r\n    // Add the search time menu to the main engine menu.\r\n    engineMenu.add(hashtableSizeMenu);\r\n    // Add a menu item to read openings from PGN files.\r\n    engineMenu.addSeparator();\r\n    engineMenu.add(new LoadOpeningsAction(getOpeningBook()));\r\n    // Return the engine menu.\r\n    return engineMenu;\r\n}"},
 {"id":527, "parametername":"return _openingBook", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":170, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getOpeningBook()", "isreturn":1, "sourcecode":"/**\r\n * Get the current opening book.\r\n *\r\n * @return The current opening book.\r\n */\r\nprivate final OpeningBook getOpeningBook() {\r\n    return _openingBook;\r\n}"},
 {"id":528, "parametername":"return _permanentBrain", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":171, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getPermanentBrain()", "isreturn":1, "sourcecode":"/**\r\n * Get the permanent brain.\r\n *\r\n * @return The permanent brain.\r\n */\r\npublic final PermanentBrain getPermanentBrain() {\r\n    return _permanentBrain;\r\n}"},
 {"id":529, "parametername":"return _searchDepth", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":172, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getSearchDepth()", "isreturn":1, "sourcecode":"/**\r\n * Get the current search depth.\r\n *\r\n * @return The current search depth.\r\n */\r\npublic final int getSearchDepth() {\r\n    return _searchDepth;\r\n}"},
 {"id":530, "parametername":"return retString", "parametertype":"String", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":173, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getStatusDisplayString()", "isreturn":1, "sourcecode":"/**\r\n * Returns the status string to display in status bar\r\n */\r\npublic String getStatusDisplayString() {\r\n    String retString = ((((\"HashSize: \" + (this.getHashSize())) + \" entries; \") + \"Search time: \") + ((this.getMaximumSearchTime()) / 1000)) + \"sec\";\r\n    if (this.isFixedTime()) {\r\n        retString += \" fix\";\r\n    } else {\r\n        retString += \" average\";\r\n    }\r\n    return retString;\r\n}"},
 {"id":531, "parametername":"return _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), (!(isWhite())))", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":174, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.getUserPlies()", "isreturn":1, "sourcecode":"/**\r\n * Get all the potential plies for the human player.\r\n *\r\n * @return All the potential plies for the human player.\r\n */\r\npublic final Ply[] getUserPlies() {\r\n    return _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), (!(isWhite())));\r\n}"},
 {"id":532, "parametername":"return _inOpeningBook", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":175, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.inOpeningBook()", "isreturn":1, "sourcecode":"/**\r\n * Get the flag to indicate, if we are still in the opening book.\r\n *\r\n * @return true, if we are still in the opening book. False otherwise.\r\n */\r\nprivate final boolean inOpeningBook() {\r\n    return _inOpeningBook;\r\n}"},
 {"id":533, "parametername":"return this.bFixedTime", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":178, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.isFixedTime()", "isreturn":1, "sourcecode":"/**\r\n * Returns whether the search time is fixed or not.\r\n *\r\n * @return Is the search time fixed?\r\n */\r\npublic boolean isFixedTime() {\r\n    return this.bFixedTime;\r\n}"},
 {"id":534, "parametername":"return _stopSearch", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":179, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.isSearchStop()", "isreturn":1, "sourcecode":"/**\r\n * Check, if a search should be stopped.\r\n *\r\n * @return true, if the search should be stopped.\r\n */\r\npublic final boolean isSearchStop() {\r\n    return _stopSearch;\r\n}"},
 {"id":535, "parametername":"return _white", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":180, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.isWhite()", "isreturn":1, "sourcecode":"/**\r\n * Get the color of this engine.\r\n *\r\n * @param white\r\n * \t\ttrue, if the engine operates with the white pieces.\r\n */\r\npublic boolean isWhite() {\r\n    return _white;\r\n}"},
 {"id":536, "parametername":"return analyzeBoard(board)", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":1, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":537, "parametername":"// Is this a checkmate?\r\nreturn BitBoardAnalyzer.BLACK_HAS_WON", "parametertype":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "parameterclass":20, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":1, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":538, "parametername":"// Looks like a draw?\r\nreturn BitBoardAnalyzer.DRAW", "parametertype":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "parameterclass":20, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":1, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":539, "parametername":"return curAlpha", "parametertype":"short", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":1, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":540, "parametername":"// Is this a checkmate?\r\nreturn BitBoardAnalyzer.WHITE_HAS_WON", "parametertype":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "parameterclass":20, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":1, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":541, "parametername":"// Looks like a draw?\r\nreturn BitBoardAnalyzer.DRAW", "parametertype":"de.java_chess.javaChess.engine.BitBoardAnalyzer", "parameterclass":20, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":1, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":542, "parametername":"return curBeta", "parametertype":"short", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":181, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "isreturn":1, "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":543, "parametername":"return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha)", "parametertype":"int", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":199, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * \t\tFlag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}"},
 {"id":544, "parametername":"return null", "parametertype":"<nulltype>", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":199, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * \t\tFlag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}"},
 {"id":545, "parametername":"return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta)", "parametertype":"int", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":199, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * \t\tFlag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}"},
 {"id":546, "parametername":"return null", "parametertype":"<nulltype>", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":199, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * \t\tFlag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}"},
 {"id":547, "parametername":"return _usePermanentBrain", "parametertype":"de.java_chess.javaChess.engine.ChessEngineImpl", "parameterclass":24, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":202, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.usePermanentBrain()", "isreturn":1, "sourcecode":"/**\r\n * Check, if the permanent brain should be used.\r\n *\r\n * @return A flag, that indicates, if the permanent brain should be used.\r\n */\r\nprivate final boolean usePermanentBrain() {\r\n    return _usePermanentBrain;\r\n}"},
 {"id":548, "parametername":"return true// ply, it seems to be valid.\r\n", "parametertype":"boolean", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":203, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.validateUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\npublic final boolean validateUserPly(Ply ply) {\r\n    // Get the user plies from the permanent brain, where they\r\n    // were hopefully already computed (if the PB is actually active).\r\n    Ply[] plies = getPermanentBrain().getUserPlies();\r\n    // If the permanent brain is not activated at the moment, remove the\r\n    // computed plies immediately, so they are recomputed for the next move!\r\n    if (!(usePermanentBrain())) {\r\n        getPermanentBrain().resetUserPlies();\r\n    }\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        if (plies[p].equals(ply)) {\r\n            // if the user ply equals this computed\r\n            // Perform this ply in the opening book\r\n            getOpeningBook().doUserPly(ply);\r\n            // Store the last user ply in a instance variable.\r\n            _lastUserPly = ply;\r\n            return true;// ply, it seems to be valid.\r\n\r\n        }\r\n    }\r\n    // The computer could not compute the ply, the user has made,\r\n    // so we assume, that it is not valid.\r\n    System.out.println((\"Invalid move \" + (ply.toString())));\r\n    System.out.println((\"Piecetype on source square \" + ((getBoard().getPiece(ply.getSource())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getSource()).getType()))));\r\n    System.out.println((\"Piecetype on destination square \" + ((getBoard().getPiece(ply.getDestination())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getDestination()).getType()))));\r\n    System.out.println(\"Valid moves are:\");\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        System.out.print(((plies[p].toString()) + \" \"));\r\n    }\r\n    System.out.println();\r\n    return false;\r\n}"},
 {"id":549, "parametername":"return false", "parametertype":"boolean", "parameterclass":0, "classid":24, "classname":"de.java_chess.javaChess.engine.ChessEngineImpl", "methodid":203, "methodname":"de.java_chess.javaChess.engine.ChessEngineImpl.validateUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\npublic final boolean validateUserPly(Ply ply) {\r\n    // Get the user plies from the permanent brain, where they\r\n    // were hopefully already computed (if the PB is actually active).\r\n    Ply[] plies = getPermanentBrain().getUserPlies();\r\n    // If the permanent brain is not activated at the moment, remove the\r\n    // computed plies immediately, so they are recomputed for the next move!\r\n    if (!(usePermanentBrain())) {\r\n        getPermanentBrain().resetUserPlies();\r\n    }\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        if (plies[p].equals(ply)) {\r\n            // if the user ply equals this computed\r\n            // Perform this ply in the opening book\r\n            getOpeningBook().doUserPly(ply);\r\n            // Store the last user ply in a instance variable.\r\n            _lastUserPly = ply;\r\n            return true;// ply, it seems to be valid.\r\n\r\n        }\r\n    }\r\n    // The computer could not compute the ply, the user has made,\r\n    // so we assume, that it is not valid.\r\n    System.out.println((\"Invalid move \" + (ply.toString())));\r\n    System.out.println((\"Piecetype on source square \" + ((getBoard().getPiece(ply.getSource())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getSource()).getType()))));\r\n    System.out.println((\"Piecetype on destination square \" + ((getBoard().getPiece(ply.getDestination())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getDestination()).getType()))));\r\n    System.out.println(\"Valid moves are:\");\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        System.out.print(((plies[p].toString()) + \" \"));\r\n    }\r\n    System.out.println();\r\n    return false;\r\n}"},
 {"id":550, "parametername":"return _analyzer", "parametertype":"de.java_chess.javaChess.engine.PlyGenerator", "parameterclass":25, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":222, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.getAnalyzer()", "isreturn":1, "sourcecode":"/**\r\n * Get a analyzer for check test.\r\n *\r\n * @return A analyzer for chess boards.\r\n */\r\nfinal BitBoardAnalyzer getAnalyzer() {\r\n    return _analyzer;\r\n}"},
 {"id":551, "parametername":"return _board", "parametertype":"de.java_chess.javaChess.engine.PlyGenerator", "parameterclass":25, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":223, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.getBoard()", "isreturn":1, "sourcecode":"/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\nfinal BitBoard getBoard() {\r\n    return _board;\r\n}"},
 {"id":552, "parametername":"return _game", "parametertype":"de.java_chess.javaChess.engine.PlyGenerator", "parameterclass":25, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":224, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.getGame()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}"},
 {"id":553, "parametername":"return _hashtable", "parametertype":"de.java_chess.javaChess.engine.PlyGenerator", "parameterclass":25, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":225, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.getHashtable()", "isreturn":1, "sourcecode":"/**\r\n * Get the current hashtable for this ply generator.\r\n *\r\n * @return The current hashtable for this ply generator.\r\n */\r\npublic final PlyHashtable getHashtable() {\r\n    return _hashtable;\r\n}"},
 {"id":554, "parametername":"return _knightMask[square]", "parametertype":"int", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":226, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.getKnightPlies(int)", "isreturn":1, "sourcecode":"/**\r\n * Get the knight plies for a given knight square.\r\n *\r\n * @param square\r\n * \t\tThe square, where the knight is located.\r\n * @return All the knight plies as a 64 bit bitmask.\r\n */\r\npublic final long getKnightPlies(int square) {\r\n    return _knightMask[square];\r\n}"},
 {"id":555, "parametername":"return getGame().getLastPly()", "parametertype":"de.java_chess.javaChess.game.Game", "parameterclass":50, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":227, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.getLastPly()", "isreturn":1, "sourcecode":"/**\r\n * Get the last ply.\r\n *\r\n * @return The last ply.\r\n */\r\nfinal Ply getLastPly() {\r\n    return getGame().getLastPly();\r\n    // return _lastPly;\r\n}"},
 {"id":556, "parametername":"return plies", "parametertype":"de.java_chess.javaChess.ply.Ply", "parameterclass":75, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":228, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get the plies for a given game position and color.\r\n *\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(boolean white) {\r\n    resetPlies();\r\n    _white = white;// Store the color of the current player.\r\n\r\n    // Compute some bitmasks, so we dont have to compute them again for each piece type.\r\n    _emptySquares = getBoard().getEmptySquares();// Get the positions of the empty squares.\r\n\r\n    _attackablePieces = (getBoard().getAllPiecesForColor((!(_white)))) & (~(getBoard().getPositionOfPieces((((Piece.KING) << 1) | (_white ? 0 : 1)))));\r\n    // Add the possible plies for all piece types.\r\n    // I tried to sort this list according to the probality for a check, so\r\n    // the analyzer has a better chance to find it early.\r\n    addPliesForKnights();\r\n    addPliesForBishops();\r\n    addPliesForRooks();\r\n    addPliesForQueens();\r\n    addPliesForPawns();\r\n    addPliesForKing();\r\n    // Check, if theres a good ply for this board in the hash table.\r\n    Ply hashtablePly = getHashtable().getPly(getBoard(), _white);\r\n    if (hashtablePly != null) {\r\n        // If so, increase the score of this ply.\r\n        for (int index = 0; index < (_plyCounter); index++) {\r\n            if (_currentPlies[index].getPly().equals(hashtablePly)) {\r\n                _currentPlies[index].setScore(HASHTABLE_PLY);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // Presort the plies\r\n    presortPlies();\r\n    // Convert the plies to a array of the correct size\r\n    Ply[] plies = new Ply[_plyCounter];\r\n    int destIndex = 0;\r\n    for (int sourceIndex = (_plyCounter) - 1; sourceIndex >= 0;) {\r\n        plies[(destIndex++)] = _currentPlies[(sourceIndex--)].getPly();\r\n    }\r\n    return plies;\r\n}"},
 {"id":557, "parametername":"return getPliesForColor(white)", "parametertype":"boolean", "parameterclass":0, "classid":25, "classname":"de.java_chess.javaChess.engine.PlyGenerator", "methodid":229, "methodname":"de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get the plies for a given board and color.\r\n * Passing the last ply is suboptimal, since its slower than\r\n * accessing the game history.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that lead to the given board.\r\n * @param board\r\n * \t\tThe board with the game position.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return getPliesForColor(white);\r\n}"},
 {"id":558, "parametername":"return _board", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "parameterclass":28, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":253, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.getBoard()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the board of this entry.\r\n *\r\n * @return The board of this entry.\r\n */\r\npublic final Board getBoard() {\r\n    return _board;\r\n}"},
 {"id":559, "parametername":"return _ply", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "parameterclass":28, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":254, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.getPly()", "isreturn":1, "sourcecode":"/**\r\n * Get the ply.\r\n *\r\n * @return The ply.\r\n */\r\npublic final Ply getPly() {\r\n    return _ply;\r\n}"},
 {"id":560, "parametername":"return _searchDepth", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "parameterclass":28, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":255, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.getSearchDepth()", "isreturn":1, "sourcecode":"/**\r\n * Get the search depth for the computed ply.\r\n *\r\n * @return The search depth for the computed ply.\r\n */\r\npublic final int getSearchDepth() {\r\n    return _searchDepth;\r\n}"},
 {"id":561, "parametername":"return PlyHashtableEntryImpl.hashKey(getBoard(), isWhiteMove())", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "parameterclass":28, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":256, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey()", "isreturn":1, "sourcecode":"/**\r\n * Get the hashcode for this ply.\r\n *\r\n * @return A hashcode for this ply.\r\n */\r\npublic final long hashKey() {\r\n    return PlyHashtableEntryImpl.hashKey(getBoard(), isWhiteMove());\r\n}"},
 {"id":562, "parametername":"return ZobristKeyImpl.getInstance().computeKey(((BitBoard) (board)), white)", "parametertype":"de.java_chess.javaChess.board.Board", "parameterclass":13, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":257, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey(de.java_chess.javaChess.board.Board,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get a hashcode for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\ttrue, if its a ply with the white pieces.\r\n * @return A hashcode for the given board and color.\r\n */\r\npublic static long hashKey(Board board, boolean white) {\r\n    return ZobristKeyImpl.getInstance().computeKey(((BitBoard) (board)), white);\r\n}"},
 {"id":563, "parametername":"return (getBoard().getPiece(getPly().getSource()).getColor()) == (Piece.WHITE)", "parametertype":"boolean", "parameterclass":0, "classid":28, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl", "methodid":258, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.isWhiteMove()", "isreturn":1, "sourcecode":"/**\r\n * Check, if its a move with white pieces.\r\n *\r\n * @return true, if its a move with white pieces.\r\n */\r\npublic final boolean isWhiteMove() {\r\n    return (getBoard().getPiece(getPly().getSource()).getColor()) == (Piece.WHITE);\r\n}"},
 {"id":564, "parametername":"return _maxSize", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "parameterclass":29, "classid":29, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "methodid":263, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getMaximumSize()", "isreturn":1, "sourcecode":"/**\r\n * Get the maximum number of entries in the hashtable.\r\n *\r\n * @return The maximum number of entries in the hashtable.\r\n */\r\npublic final int getMaximumSize() {\r\n    return _maxSize;\r\n}"},
 {"id":565, "parametername":"return entry.getPly()", "parametertype":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry", "parameterclass":27, "classid":29, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "methodid":264, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\ttrue, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}"},
 {"id":566, "parametername":"// No ply for this board found.\r\nreturn null", "parametertype":"<nulltype>", "parameterclass":0, "classid":29, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "methodid":264, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\ttrue, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}"},
 {"id":567, "parametername":"return _hashtable.size()", "parametertype":"java.util.Hashtable", "parameterclass":0, "classid":29, "classname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl", "methodid":265, "methodname":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getSize()", "isreturn":1, "sourcecode":"/**\r\n * Get the current number of entries.\r\n *\r\n * @return The current number of entries.\r\n */\r\npublic final int getSize() {\r\n    return _hashtable.size();\r\n}"},
 {"id":568, "parametername":"return val", "parametertype":"long", "parameterclass":0, "classid":30, "classname":"de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl", "methodid":271, "methodname":"de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.computeKey(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Compute a key for a board and a color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\tFlag to indicate if white moves.\r\n * @return The zobrist key.\r\n */\r\npublic long computeKey(BitBoard board, boolean white) {\r\n    long val = 0L;\r\n    // Get a bitmask of the empty squares to speedup the\r\n    // test for a piece on the square.\r\n    long emptySquareMask = board.getEmptySquares();\r\n    // Reuse the same position object for each square.\r\n    Position curPosition = new PositionImpl(0);\r\n    for (int square = 0; square < 64; square++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            curPosition.setSquareIndex(square);\r\n            Piece p = board.getPiece(curPosition);\r\n            if (p != null) {\r\n                val ^= _factors[p.getColor()][((p.getType()) - 1)][square];\r\n            }\r\n        }\r\n        emptySquareMask >>>= 1;// Shift the mask to test for the next square.\r\n\r\n    }\r\n    if (!white) {\r\n        val ^= _blackMoves;\r\n    }\r\n    return val;\r\n}"},
 {"id":569, "parametername":"return ZobristKeyImpl._instance", "parametertype":"de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl", "parameterclass":30, "classid":30, "classname":"de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl", "methodid":272, "methodname":"de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.getInstance()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the only instance of this class.\r\n */\r\npublic static final ZobristKeyImpl getInstance() {\r\n    if ((ZobristKeyImpl._instance) == null) {\r\n        ZobristKeyImpl._instance = new ZobristKeyImpl();\r\n    }\r\n    return ZobristKeyImpl._instance;\r\n}"},
 {"id":570, "parametername":"return i", "parametertype":"int", "parameterclass":0, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":280, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.findOpening()", "isreturn":1, "sourcecode":"/**\r\n * Try to find a opening for the current game notation.\r\n *\r\n * @return The index of the found opening.\r\n */\r\nprivate final int findOpening() {\r\n    for (int i = 0; i < (_openings.size()); i++) {\r\n        if (isInOpening(i)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;// No opening found.\r\n\r\n}"},
 {"id":571, "parametername":"return -1// No opening found.\r\n", "parametertype":"int", "parameterclass":0, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":280, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.findOpening()", "isreturn":1, "sourcecode":"/**\r\n * Try to find a opening for the current game notation.\r\n *\r\n * @return The index of the found opening.\r\n */\r\nprivate final int findOpening() {\r\n    for (int i = 0; i < (_openings.size()); i++) {\r\n        if (isInOpening(i)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;// No opening found.\r\n\r\n}"},
 {"id":572, "parametername":"return _notation", "parametertype":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "parameterclass":32, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":281, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.getNotation()", "isreturn":1, "sourcecode":"/**\r\n * Get the notation of the current game.\r\n *\r\n * @return The notation of the current game.\r\n */\r\nprivate final GameNotation getNotation() {\r\n    return _notation;\r\n}"},
 {"id":573, "parametername":"return new AnalyzedPlyImpl(currentOpening.getPlyNotation(pliesMade).getPly(), ((short) (0)))", "parametertype":"int", "parameterclass":0, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":282, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.getOpeningBookPly()", "isreturn":1, "sourcecode":"/**\r\n * Get the next ply from the opening book, if there is\r\n * one available, or null if not.\r\n *\r\n * @return The next ply from the opening book, or null\r\nif theres no ply available.\r\n */\r\npublic final AnalyzedPly getOpeningBookPly() {\r\n    // If we have no opening yet, try to find one.\r\n    if ((_currentOpening) == (-1)) {\r\n        _currentOpening = findOpening();\r\n    }\r\n    // Check, if we have found a opening.\r\n    if ((_currentOpening) != (-1)) {\r\n        // Check, if we have another ply in the opening.\r\n        int pliesMade = _notation.size();\r\n        GameNotation currentOpening = ((GameNotation) (_openings.get(_currentOpening)));\r\n        if ((currentOpening.size()) > pliesMade) {\r\n            return new AnalyzedPlyImpl(currentOpening.getPlyNotation(pliesMade).getPly(), ((short) (0)));\r\n        }\r\n    }\r\n    return null;// No ply found in the available opening books.\r\n\r\n}"},
 {"id":574, "parametername":"return null// No ply found in the available opening books.\r\n", "parametertype":"<nulltype>", "parameterclass":0, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":282, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.getOpeningBookPly()", "isreturn":1, "sourcecode":"/**\r\n * Get the next ply from the opening book, if there is\r\n * one available, or null if not.\r\n *\r\n * @return The next ply from the opening book, or null\r\nif theres no ply available.\r\n */\r\npublic final AnalyzedPly getOpeningBookPly() {\r\n    // If we have no opening yet, try to find one.\r\n    if ((_currentOpening) == (-1)) {\r\n        _currentOpening = findOpening();\r\n    }\r\n    // Check, if we have found a opening.\r\n    if ((_currentOpening) != (-1)) {\r\n        // Check, if we have another ply in the opening.\r\n        int pliesMade = _notation.size();\r\n        GameNotation currentOpening = ((GameNotation) (_openings.get(_currentOpening)));\r\n        if ((currentOpening.size()) > pliesMade) {\r\n            return new AnalyzedPlyImpl(currentOpening.getPlyNotation(pliesMade).getPly(), ((short) (0)));\r\n        }\r\n    }\r\n    return null;// No ply found in the available opening books.\r\n\r\n}"},
 {"id":575, "parametername":"return false", "parametertype":"boolean", "parameterclass":0, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":283, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.isInOpening(int)", "isreturn":1, "sourcecode":"/**\r\n * Check, if the current game notation is part of a given opening.\r\n *\r\n * @param openingIndex\r\n * \t\tThe index of the opening to test.\r\n */\r\nprivate final boolean isInOpening(int openingIndex) {\r\n    GameNotation notation = ((GameNotation) (_openings.get(openingIndex)));\r\n    // If the current game has more plies, than the opening, we can return\r\n    // false.\r\n    if ((_notation.size()) > (notation.size())) {\r\n        return false;\r\n    }\r\n    // Compare the notation ply by ply, which is rather slow, but should work\r\n    // for now.\r\n    for (int i = 0; i < (_notation.size()); i++) {\r\n        if (!(_notation.getPlyNotation(i).getPly().equals(notation.getPlyNotation(i).getPly()))) {\r\n            return false;\r\n        }\r\n    }\r\n    // The current game uses the given opening.\r\n    return true;\r\n}"},
 {"id":576, "parametername":"return false", "parametertype":"boolean", "parameterclass":0, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":283, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.isInOpening(int)", "isreturn":1, "sourcecode":"/**\r\n * Check, if the current game notation is part of a given opening.\r\n *\r\n * @param openingIndex\r\n * \t\tThe index of the opening to test.\r\n */\r\nprivate final boolean isInOpening(int openingIndex) {\r\n    GameNotation notation = ((GameNotation) (_openings.get(openingIndex)));\r\n    // If the current game has more plies, than the opening, we can return\r\n    // false.\r\n    if ((_notation.size()) > (notation.size())) {\r\n        return false;\r\n    }\r\n    // Compare the notation ply by ply, which is rather slow, but should work\r\n    // for now.\r\n    for (int i = 0; i < (_notation.size()); i++) {\r\n        if (!(_notation.getPlyNotation(i).getPly().equals(notation.getPlyNotation(i).getPly()))) {\r\n            return false;\r\n        }\r\n    }\r\n    // The current game uses the given opening.\r\n    return true;\r\n}"},
 {"id":577, "parametername":"// The current game uses the given opening.\r\nreturn true", "parametertype":"boolean", "parameterclass":0, "classid":32, "classname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl", "methodid":283, "methodname":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.isInOpening(int)", "isreturn":1, "sourcecode":"/**\r\n * Check, if the current game notation is part of a given opening.\r\n *\r\n * @param openingIndex\r\n * \t\tThe index of the opening to test.\r\n */\r\nprivate final boolean isInOpening(int openingIndex) {\r\n    GameNotation notation = ((GameNotation) (_openings.get(openingIndex)));\r\n    // If the current game has more plies, than the opening, we can return\r\n    // false.\r\n    if ((_notation.size()) > (notation.size())) {\r\n        return false;\r\n    }\r\n    // Compare the notation ply by ply, which is rather slow, but should work\r\n    // for now.\r\n    for (int i = 0; i < (_notation.size()); i++) {\r\n        if (!(_notation.getPlyNotation(i).getPly().equals(notation.getPlyNotation(i).getPly()))) {\r\n            return false;\r\n        }\r\n    }\r\n    // The current game uses the given opening.\r\n    return true;\r\n}"},
 {"id":578, "parametername":"return _openingBook", "parametertype":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction", "parameterclass":33, "classid":33, "classname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction", "methodid":288, "methodname":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.getOpeningBook()", "isreturn":1, "sourcecode":"/**\r\n * Get the current opening book.\r\n *\r\n * @return The current opening book.\r\n */\r\nprivate final OpeningBook getOpeningBook() {\r\n    return _openingBook;\r\n}"},
 {"id":579, "parametername":"return _engine", "parametertype":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "parameterclass":34, "classid":34, "classname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "methodid":293, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getEngine()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the current chess engine.\r\n *\r\n * @return The current chess engine.\r\n */\r\nprivate final ChessEngine getEngine() {\r\n    return _engine;\r\n}"},
 {"id":580, "parametername":"// i holds the index of the user ply now, which equals the\r\n// index of the computed response.\r\nreturn _computedPlies[i]", "parametertype":"int", "parameterclass":0, "classid":34, "classname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "methodid":294, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"},
 {"id":581, "parametername":"return null", "parametertype":"<nulltype>", "parameterclass":0, "classid":34, "classname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "methodid":294, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"},
 {"id":582, "parametername":"return _userPlies// Return the user plies.\r\n", "parametertype":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "parameterclass":34, "classid":34, "classname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain", "methodid":295, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getUserPlies()", "isreturn":1, "sourcecode":"/**\r\n * Get the potential plies for a user.\r\n * (Required to validate a user ply.)\r\n *\r\n * @return The potential plies for a user.\r\n */\r\npublic final Ply[] getUserPlies() {\r\n    // Lazy computation for better performance.\r\n    if ((_userPlies) == null) {\r\n        _userPlies = getEngine().getUserPlies();\r\n    }\r\n    return _userPlies;// Return the user plies.\r\n\r\n}"},
 {"id":583, "parametername":"return _ply", "parametertype":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl", "parameterclass":36, "classid":36, "classname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl", "methodid":304, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.getPly()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the computed ply.\r\n *\r\n * @return The computed ply.\r\n */\r\npublic final AnalyzedPly getPly() {\r\n    return _ply;\r\n}"},
 {"id":584, "parametername":"return _searchDepth", "parametertype":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl", "parameterclass":36, "classid":36, "classname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl", "methodid":305, "methodname":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.getSearchDepth()", "isreturn":1, "sourcecode":"/**\r\n * Get the used search depth.\r\n *\r\n * @return The used search depth.\r\n */\r\npublic final int getSearchDepth() {\r\n    return _searchDepth;\r\n}"},
 {"id":585, "parametername":"return suite", "parametertype":"junit.framework.TestSuite", "parameterclass":0, "classid":40, "classname":"de.java_chess.javaChess.engine.test.ChessEngineTest", "methodid":325, "methodname":"de.java_chess.javaChess.engine.test.ChessEngineTest.suite()", "isreturn":1, "sourcecode":"/**\r\n * Create the engine test suite.\r\n *\r\n * @return The engine test suite.\r\n */\r\npublic static Test suite() {\r\n    // Create a new test suite\r\n    TestSuite suite = new TestSuite();\r\n    // Test the ply generator\r\n    suite.addTest(new PlyGeneratorTest1());\r\n    suite.addTest(new PlyGeneratorTest2());\r\n    suite.addTest(new PlyGeneratorTest3());\r\n    suite.addTest(new PlyGeneratorTest4());\r\n    suite.addTest(new PlyGeneratorTest5());\r\n    suite.addTest(new PlyGeneratorTest6());\r\n    // Add the actual engine tests.\r\n    suite.addTest(new KingInKnightCheckTest());\r\n    // Test the analyzer\r\n    suite.addTest(new AnalyzerTest1());\r\n    suite.addTest(new AnalyzerTest2());\r\n    // Test the complete engine\r\n    suite.addTest(new MinimaxTest1());\r\n    suite.addTest(new MinimaxTest2());\r\n    suite.addTest(new BoardConsistencyTest1());\r\n    return suite;\r\n}"},
 {"id":586, "parametername":"return _gameStatus.empty() ? null : ((GameImpl.GameStatus) (_gameStatus.peek()))", "parametertype":"de.java_chess.javaChess.game.GameImpl.GameStatus", "parameterclass":0, "classid":52, "classname":"de.java_chess.javaChess.game.GameImpl", "methodid":381, "methodname":"de.java_chess.javaChess.game.GameImpl.getLastGameStatus()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the last game status.\r\n *\r\n * @return The last game status.\r\n */\r\nprivate final GameImpl.GameStatus getLastGameStatus() {\r\n    return _gameStatus.empty() ? null : ((GameImpl.GameStatus) (_gameStatus.peek()));\r\n}"},
 {"id":587, "parametername":"return lastStatus == null ? null : lastStatus.getPly()", "parametertype":"de.java_chess.javaChess.game.GameImpl.GameStatus", "parameterclass":0, "classid":52, "classname":"de.java_chess.javaChess.game.GameImpl", "methodid":382, "methodname":"de.java_chess.javaChess.game.GameImpl.getLastPly()", "isreturn":1, "sourcecode":"/**\r\n * Get the last ply.\r\n *\r\n * @return The last ply.\r\n */\r\npublic final Ply getLastPly() {\r\n    GameImpl.GameStatus lastStatus = getLastGameStatus();\r\n    return lastStatus == null ? null : lastStatus.getPly();\r\n}"},
 {"id":588, "parametername":"return _gameStatus.size()", "parametertype":"de.java_chess.javaChess.game.GameImpl", "parameterclass":52, "classid":52, "classname":"de.java_chess.javaChess.game.GameImpl", "methodid":383, "methodname":"de.java_chess.javaChess.game.GameImpl.getNumberOfPlies()", "isreturn":1, "sourcecode":"/**\r\n * Get the total number of plies.\r\n *\r\n * @return The total number of plies.\r\n */\r\npublic final int getNumberOfPlies() {\r\n    return _gameStatus.size();\r\n}"},
 {"id":589, "parametername":"return lastStatus == null ? false : lastStatus.hasBeenMoved(position)", "parametertype":"de.java_chess.javaChess.game.GameImpl.GameStatus", "parameterclass":0, "classid":52, "classname":"de.java_chess.javaChess.game.GameImpl", "methodid":384, "methodname":"de.java_chess.javaChess.game.GameImpl.hasBeenMoved(de.java_chess.javaChess.position.Position)", "isreturn":1, "sourcecode":"/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * \t\tThe position to check.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    GameImpl.GameStatus lastStatus = getLastGameStatus();\r\n    return lastStatus == null ? false : lastStatus.hasBeenMoved(position);\r\n}"},
 {"id":590, "parametername":"return resultBuffer.toString()", "parametertype":"StringBuffer", "parameterclass":0, "classid":52, "classname":"de.java_chess.javaChess.game.GameImpl", "methodid":386, "methodname":"de.java_chess.javaChess.game.GameImpl.toString()", "isreturn":1, "sourcecode":"/**\r\n * Convert the game to a string.\r\n *\r\n * @return A string representation of the game.\r\n */\r\npublic final String toString() {\r\n    // A buffer for the string representation\r\n    StringBuffer resultBuffer = new StringBuffer();\r\n    // Iterate over the stack content\r\n    for (Iterator iter = _gameStatus.iterator(); iter.hasNext();) {\r\n        resultBuffer.append(((GameImpl.GameStatus) (iter.next())).getPly().toString());\r\n        resultBuffer.append(\"\n\");\r\n    }\r\n    return resultBuffer.toString();\r\n}"},
 {"id":591, "parametername":"return _movedPieces", "parametertype":"de.java_chess.javaChess.game.GameImpl.GameStatus", "parameterclass":0, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":391, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.getMovedPieces()", "isreturn":1, "sourcecode":"/**\r\n * Get the bitmask for the moved pieces.\r\n *\r\n * @return The bitmask for the moved pieces.\r\n */\r\nprivate final long getMovedPieces() {\r\n    return _movedPieces;\r\n}"},
 {"id":592, "parametername":"return _ply", "parametertype":"de.java_chess.javaChess.game.GameImpl.GameStatus", "parameterclass":0, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":392, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.getPly()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the ply, that lead to this game status.\r\n *\r\n * @return The ply, that lead to this game status.\r\n */\r\nfinal Ply getPly() {\r\n    return _ply;\r\n}"},
 {"id":593, "parametername":"return ((_movedPieces) & (1L << (position.getSquareIndex()))) != 0L", "parametertype":"de.java_chess.javaChess.game.GameImpl.GameStatus", "parameterclass":0, "classid":51, "classname":"de.java_chess.javaChess.game.GameImpl$GameStatus", "methodid":393, "methodname":"de.java_chess.javaChess.game.GameImpl$GameStatus.hasBeenMoved(de.java_chess.javaChess.position.Position)", "isreturn":1, "sourcecode":"/**\r\n * Check if a piece on a given initial position\r\n * has been moved.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    return ((_movedPieces) & (1L << (position.getSquareIndex()))) != 0L;\r\n}"},
 {"id":594, "parametername":"return jmEditMenu", "parametertype":"javax.swing.JMenu", "parameterclass":0, "classid":54, "classname":"de.java_chess.javaChess.menu.EditMenu", "methodid":400, "methodname":"de.java_chess.javaChess.menu.EditMenu.getMenu()", "isreturn":1, "sourcecode":"/**\r\n * Return a menu from the chess engine, where the user\r\n * can change the settings.\r\n *\r\n * @return A menu for the engine settings.\r\n */\r\npublic final JMenu getMenu() {\r\n    // Create a new menu.\r\n    JMenu jmEditMenu = new JMenu(\"Edit\");\r\n    // Add menu items\r\n    jmiBlackPlayerName.setText(\"Black player name\");\r\n    jmiWhitePlayerName.setText(\"White player name\");\r\n    jmiEditPosition.setText(\"Edit/Setup position\");\r\n    jmiEditPosition.setMnemonic(S);\r\n    jmiBlackPlayerName.addActionListener(this);\r\n    jmiWhitePlayerName.addActionListener(this);\r\n    jmiEditPosition.addActionListener(this);\r\n    jmEditMenu.add(jmiWhitePlayerName);\r\n    jmEditMenu.add(jmiBlackPlayerName);\r\n    jmEditMenu.addSeparator();\r\n    jmEditMenu.add(jmiEditPosition);\r\n    jmEditMenu.setMnemonic(KeyEvent.VK_E);\r\n    return jmEditMenu;\r\n}"},
 {"id":595, "parametername":"return getPly((white ? moveIndex << 1 : (moveIndex << 1) + 1))", "parametertype":"int", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":415, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.getMove(int,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * \t\tThe index of the move.\r\n * @param boolean\r\n * \t\twhite Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\npublic final String getMove(int moveIndex, boolean white) {\r\n    return getPly((white ? moveIndex << 1 : (moveIndex << 1) + 1));\r\n}"},
 {"id":596, "parametername":"return _notationPanel", "parametertype":"de.java_chess.javaChess.notation.GameNotationImpl", "parameterclass":56, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":416, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.getNotationPanel()", "isreturn":1, "sourcecode":"/**\r\n * Get the panel for the output.\r\n *\r\n * @return The panel for the output.\r\n */\r\npublic final NotationPanel getNotationPanel() {\r\n    return _notationPanel;\r\n}"},
 {"id":597, "parametername":"return _openingName", "parametertype":"de.java_chess.javaChess.notation.GameNotationImpl", "parameterclass":56, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":417, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.getOpeningInfo()", "isreturn":1, "sourcecode":"/**\r\n * Get the info on the used opening.\r\n *\r\n * @return The name of the used opening.\r\n */\r\npublic final String getOpeningInfo() {\r\n    return _openingName;\r\n}"},
 {"id":598, "parametername":"// Convert the header to a String and return it.\r\nreturn resultBuffer.toString()", "parametertype":"StringBuffer", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":418, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.getPGNheader()", "isreturn":1, "sourcecode":"/**\r\n * Get some extended PGN compatible info on the game.\r\n *\r\n * @return Extended PGN compatible info on the game.\r\n */\r\npublic final String getPGNheader() {\r\n    // Create a buffer for the result.\r\n    StringBuffer resultBuffer = new StringBuffer();\r\n    // Add a empty event to the header\r\n    resultBuffer.append(\"[Event \"?\"]\n\");\r\n    // Info on the site\r\n    resultBuffer.append(\"[Site \"?\"]\n\");\r\n    // Add the current date to the header\r\n    resultBuffer.append(\"[Date \"\").append(new SimpleDateFormat(\"yyyy.MM.dd\").format(new Date())).append(\"\"]\n\");\r\n    // Add the round to the header\r\n    resultBuffer.append(\"[Round \"?\"]\n\");\r\n    // Add the name of the white player, if it is available.\r\n    if (!(\"\".equals(getPlayerInfo(true)))) {\r\n        resultBuffer.append(\"[White \"\").append(getPlayerInfo(true)).append(\"\"]\n\");\r\n    }\r\n    // Add the name of the black player, if it is available.\r\n    if (!(\"\".equals(getPlayerInfo(false)))) {\r\n        resultBuffer.append(\"[Black \"\").append(getPlayerInfo(false)).append(\"\"]\n\");\r\n    }\r\n    // Info on the result\r\n    resultBuffer.append(\"[Result \"?\"]\n\");\r\n    // Convert the header to a String and return it.\r\n    return resultBuffer.toString();\r\n}"},
 {"id":599, "parametername":"return _playerInfo[(white ? 1 : 0)]", "parametertype":"int", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":419, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.getPlayerInfo(boolean)", "isreturn":1, "sourcecode":"/**\r\n * Get some info on a player.\r\n *\r\n * @return Some info on a player.\r\n */\r\npublic final String getPlayerInfo(boolean white) {\r\n    return _playerInfo[(white ? 1 : 0)];\r\n}"},
 {"id":600, "parametername":"return _plies.get(plyIndex).toString()", "parametertype":"int", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":420, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.getPly(int)", "isreturn":1, "sourcecode":"/**\r\n * Get the ply with the given index.\r\n *\r\n * @param plyIndex\r\n * \t\tThe index of the ply.\r\n * @return The notation for the ply as a string.\r\n */\r\nprivate final String getPly(int plyIndex) {\r\n    return _plies.get(plyIndex).toString();\r\n}"},
 {"id":601, "parametername":"return ((PlyNotation) (_plies.get(index)))", "parametertype":"int", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":421, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.getPlyNotation(int)", "isreturn":1, "sourcecode":"/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * \t\tThe index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index) {\r\n    return ((PlyNotation) (_plies.get(index)));\r\n}"},
 {"id":602, "parametername":"return _plies.size()", "parametertype":"java.util.ArrayList", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":426, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.size()", "isreturn":1, "sourcecode":"/**\r\n * Get the number of plies in this notation.\r\n *\r\n * @return The number of plies.\r\n */\r\npublic int size() {\r\n    return _plies.size();\r\n}"},
 {"id":603, "parametername":"return _notation.toString()", "parametertype":"StringBuffer", "parameterclass":0, "classid":56, "classname":"de.java_chess.javaChess.notation.GameNotationImpl", "methodid":427, "methodname":"de.java_chess.javaChess.notation.GameNotationImpl.toString()", "isreturn":1, "sourcecode":"/**\r\n * Get the entire game as a string.\r\n *\r\n * @return The entire game as a string.\r\n */\r\npublic final String toString() {\r\n    return _notation.toString();\r\n}"},
 {"id":604, "parametername":"return _piece", "parametertype":"de.java_chess.javaChess.notation.PlyNotationImpl", "parameterclass":58, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":441, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.getPiece()", "isreturn":1, "sourcecode":"/**\r\n * Get the piece of this ply.\r\n *\r\n * @return The piece, that is moved with this ply.\r\n */\r\npublic final Piece getPiece() {\r\n    return _piece;\r\n}"},
 {"id":605, "parametername":"return notation", "parametertype":"String", "parameterclass":0, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":442, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.getPieceTypeNotation(byte)", "isreturn":1, "sourcecode":"/**\r\n * Get the notation for a piece type.\r\n *\r\n * @return The notation for a piece type.\r\n */\r\npublic final String getPieceTypeNotation(byte pieceType) {\r\n    String notation = \"\";// The result;\r\n\r\n    // Convert the piece type to a string.\r\n    switch (pieceType) {\r\n        case Piece.PAWN :\r\n            notation = \"P\";\r\n            break;\r\n        case Piece.KNIGHT :\r\n            notation = \"N\";\r\n            break;\r\n        case Piece.BISHOP :\r\n            notation = \"B\";\r\n            break;\r\n        case Piece.ROOK :\r\n            notation = \"R\";\r\n            break;\r\n        case Piece.QUEEN :\r\n            notation = \"Q\";\r\n            break;\r\n        case Piece.KING :\r\n            notation = \"K\";\r\n            break;\r\n    }\r\n    return notation;\r\n}"},
 {"id":606, "parametername":"return _ply", "parametertype":"de.java_chess.javaChess.notation.PlyNotationImpl", "parameterclass":58, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":443, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.getPly()", "isreturn":1, "sourcecode":"/**\r\n * Get the ply of this notation.\r\n *\r\n * @return The ply for this notation.\r\n */\r\npublic final Ply getPly() {\r\n    return _ply;\r\n}"},
 {"id":607, "parametername":"return getPly().isCapture()", "parametertype":"de.java_chess.javaChess.notation.PlyNotationImpl", "parameterclass":58, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":444, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.isCapture()", "isreturn":1, "sourcecode":"/**\r\n * Check if the piece captures another piece with this ply.\r\n *\r\n * @return true, if another piece is captureed with this ply.\r\n */\r\npublic final boolean isCapture() {\r\n    return getPly().isCapture();\r\n}"},
 {"id":608, "parametername":"return _check", "parametertype":"de.java_chess.javaChess.notation.PlyNotationImpl", "parameterclass":58, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":445, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.isCheck()", "isreturn":1, "sourcecode":"/**\r\n * Get the flag for a check.\r\n *\r\n * @return true, if the opponent is in check.\r\n */\r\npublic final boolean isCheck() {\r\n    return _check;\r\n}"},
 {"id":609, "parametername":"return _checkMate", "parametertype":"de.java_chess.javaChess.notation.PlyNotationImpl", "parameterclass":58, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":446, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.isCheckMate()", "isreturn":1, "sourcecode":"/**\r\n * Get the flag for a checkmate.\r\n *\r\n * @return true, if the opponent is checkmate.\r\n */\r\npublic final boolean isCheckMate() {\r\n    return _checkMate;\r\n}"},
 {"id":610, "parametername":"return _stringRepresentation", "parametertype":"de.java_chess.javaChess.notation.PlyNotationImpl", "parameterclass":58, "classid":58, "classname":"de.java_chess.javaChess.notation.PlyNotationImpl", "methodid":451, "methodname":"de.java_chess.javaChess.notation.PlyNotationImpl.toString()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Render this notation as a string.\r\n *\r\n * @return A string representation of this ply.\r\n */\r\npublic String toString() {\r\n    return _stringRepresentation;\r\n}"},
 {"id":611, "parametername":"return null", "parametertype":"<nulltype>", "parameterclass":0, "classid":59, "classname":"de.java_chess.javaChess.pgn.GameLoader", "methodid":453, "methodname":"de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * \t\tThe info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}"},
 {"id":612, "parametername":"// And return the notation for the ply.\r\nreturn notation", "parametertype":"de.java_chess.javaChess.notation.PlyNotation", "parameterclass":57, "classid":59, "classname":"de.java_chess.javaChess.pgn.GameLoader", "methodid":453, "methodname":"de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * \t\tThe info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}"},
 {"id":613, "parametername":"return _parser// And return it.\r\n", "parametertype":"de.java_chess.javaChess.pgn.PGNFile", "parameterclass":60, "classid":60, "classname":"de.java_chess.javaChess.pgn.PGNFile", "methodid":456, "methodname":"de.java_chess.javaChess.pgn.PGNFile.getPGNParser()", "isreturn":1, "sourcecode":"/**\r\n * Get the current parser, if theres already one, or\r\n * create a new parser and return it.\r\n *\r\n * @return The current PGN parser.\r\n */\r\nprivate final PGNParser getPGNParser() {\r\n    if ((_parser) == null) {\r\n        // If there is no parser yet, create one.\r\n        _parser = new PGNParser(new PGNLexer(getReader()));\r\n    }\r\n    return _parser;// And return it.\r\n\r\n}"},
 {"id":614, "parametername":"return _reader", "parametertype":"de.java_chess.javaChess.pgn.PGNFile", "parameterclass":60, "classid":60, "classname":"de.java_chess.javaChess.pgn.PGNFile", "methodid":457, "methodname":"de.java_chess.javaChess.pgn.PGNFile.getReader()", "isreturn":1, "sourcecode":"/**\r\n * Get the reader for the current file.\r\n *\r\n * @return The current reader.\r\n */\r\nprivate final Reader getReader() {\r\n    return _reader;\r\n}"},
 {"id":615, "parametername":"return notationBuffer", "parametertype":"de.java_chess.javaChess.notation.GameNotation", "parameterclass":55, "classid":60, "classname":"de.java_chess.javaChess.pgn.PGNFile", "methodid":458, "methodname":"de.java_chess.javaChess.pgn.PGNFile.readGame()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Read one game from the current file.\r\n *\r\n * @return The notation of the game.\r\n * @throws RecognitionException\r\n * \t\tIf a parser problem occured.\r\n * @throws TokenStreamException\r\n * \t\tIf a scanner problem occured.\r\n */\r\npublic final GameNotation readGame() throws RecognitionException, TokenStreamException {\r\n    // A buffer for the result.\r\n    GameNotation notationBuffer = new GameNotationImpl();\r\n    // Start the parsing of the file.\r\n    getPGNParser().pgnGame(notationBuffer);\r\n    return notationBuffer;\r\n}"},
 {"id":616, "parametername":"return false", "parametertype":"boolean", "parameterclass":0, "classid":61, "classname":"de.java_chess.javaChess.pgn.PGNFileFilter", "methodid":462, "methodname":"de.java_chess.javaChess.pgn.PGNFileFilter.accept(java.io.File)", "isreturn":1, "sourcecode":"// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Check if the given file is a PGN file.\r\n *\r\n * @param file\r\n * \t\tThe file to check.\r\n * @return true, if the file is a PGN file, false otherwise.\r\n */\r\npublic boolean accept(File file) {\r\n    if (file == null) {\r\n        return false;\r\n    }\r\n    String filename = file.getName();\r\n    int i = filename.lastIndexOf(.);\r\n    if ((i > 0) && (i < ((filename.length()) - 1))) {\r\n        return \"pgn\".equalsIgnoreCase(filename.substring((i + 1)).toLowerCase());\r\n    }\r\n    return false;\r\n}"},
 {"id":617, "parametername":"return \"pgn\".equalsIgnoreCase(filename.substring((i + 1)).toLowerCase())", "parametertype":"int", "parameterclass":0, "classid":61, "classname":"de.java_chess.javaChess.pgn.PGNFileFilter", "methodid":462, "methodname":"de.java_chess.javaChess.pgn.PGNFileFilter.accept(java.io.File)", "isreturn":1, "sourcecode":"// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Check if the given file is a PGN file.\r\n *\r\n * @param file\r\n * \t\tThe file to check.\r\n * @return true, if the file is a PGN file, false otherwise.\r\n */\r\npublic boolean accept(File file) {\r\n    if (file == null) {\r\n        return false;\r\n    }\r\n    String filename = file.getName();\r\n    int i = filename.lastIndexOf(.);\r\n    if ((i > 0) && (i < ((filename.length()) - 1))) {\r\n        return \"pgn\".equalsIgnoreCase(filename.substring((i + 1)).toLowerCase());\r\n    }\r\n    return false;\r\n}"},
 {"id":618, "parametername":"return false", "parametertype":"boolean", "parameterclass":0, "classid":61, "classname":"de.java_chess.javaChess.pgn.PGNFileFilter", "methodid":462, "methodname":"de.java_chess.javaChess.pgn.PGNFileFilter.accept(java.io.File)", "isreturn":1, "sourcecode":"// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Check if the given file is a PGN file.\r\n *\r\n * @param file\r\n * \t\tThe file to check.\r\n * @return true, if the file is a PGN file, false otherwise.\r\n */\r\npublic boolean accept(File file) {\r\n    if (file == null) {\r\n        return false;\r\n    }\r\n    String filename = file.getName();\r\n    int i = filename.lastIndexOf(.);\r\n    if ((i > 0) && (i < ((filename.length()) - 1))) {\r\n        return \"pgn\".equalsIgnoreCase(filename.substring((i + 1)).toLowerCase());\r\n    }\r\n    return false;\r\n}"},
 {"id":619, "parametername":"return \"PGN - Portable Game Notation format\"", "parametertype":"String", "parameterclass":0, "classid":61, "classname":"de.java_chess.javaChess.pgn.PGNFileFilter", "methodid":463, "methodname":"de.java_chess.javaChess.pgn.PGNFileFilter.getDescription()", "isreturn":1, "sourcecode":"/**\r\n * Get a description of this file filter.\r\n *\r\n * @return A description of this file filter.\r\n */\r\npublic String getDescription() {\r\n    return \"PGN - Portable Game Notation format\";\r\n}"},
 {"id":620, "parametername":"return _gameLoader", "parametertype":"de.java_chess.javaChess.pgn.PGNParser", "parameterclass":64, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":501, "methodname":"de.java_chess.javaChess.pgn.PGNParser.getGameLoader()", "isreturn":1, "sourcecode":"/**\r\n * Get the current game loader.\r\n *\r\n * @return The current game loader.\r\n */\r\nprivate final GameLoader getGameLoader() {\r\n    return _gameLoader;\r\n}"},
 {"id":621, "parametername":"return _notation", "parametertype":"de.java_chess.javaChess.pgn.PGNParser", "parameterclass":64, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":502, "methodname":"de.java_chess.javaChess.pgn.PGNParser.getNotation()", "isreturn":1, "sourcecode":"/**\r\n * Get the current notation.\r\n *\r\n * @return The current notation.\r\n */\r\npublic final GameNotation getNotation() {\r\n    return _notation;\r\n}"},
 {"id":622, "parametername":"return notation", "parametertype":"de.java_chess.javaChess.notation.PlyNotation", "parameterclass":57, "classid":64, "classname":"de.java_chess.javaChess.pgn.PGNParser", "methodid":507, "methodname":"de.java_chess.javaChess.pgn.PGNParser.ply()", "isreturn":1, "sourcecode":"public final PlyNotation ply() throws RecognitionException, TokenStreamException {\r\n    PlyNotation notation = null;\r\n    Token lc = null;\r\n    Token snOrg = null;\r\n    Token snDest = null;\r\n    Token lc2 = null;\r\n    PGNPlyFragment plyFragment = new PGNPlyFragment();\r\n    {\r\n        switch (LA(1)) {\r\n            case PGNTokenTypes.FIGURINE_LETTER_CODE :\r\n            case PGNTokenTypes.SQUARE_NAME :\r\n            case PGNTokenTypes.PIECE_MOVE :\r\n            case PGNTokenTypes.PIECE_CAPTURE :\r\n                {\r\n                    {\r\n                        {\r\n                            switch (LA(1)) {\r\n                                case PGNTokenTypes.FIGURINE_LETTER_CODE :\r\n                                    {\r\n                                        lc = LT(1);\r\n                                        match(PGNTokenTypes.FIGURINE_LETTER_CODE);\r\n                                        plyFragment.setPieceTypeFromLetter(lc.getText().charAt(0));\r\n                                        break;\r\n                                    }\r\n                                case PGNTokenTypes.SQUARE_NAME :\r\n                                case PGNTokenTypes.PIECE_MOVE :\r\n                                case PGNTokenTypes.PIECE_CAPTURE :\r\n                                    {\r\n                                        break;\r\n                                    }\r\n                                default :\r\n                                    {\r\n                                        throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                    }\r\n                            }\r\n                        }\r\n                        {\r\n                            {\r\n                                switch (LA(1)) {\r\n                                    case PGNTokenTypes.SQUARE_NAME :\r\n                                        {\r\n                                            snOrg = LT(1);\r\n                                            match(PGNTokenTypes.SQUARE_NAME);\r\n                                            plyFragment.setOrigin(snOrg.getText());\r\n                                            break;\r\n                                        }\r\n                                    case PGNTokenTypes.PIECE_MOVE :\r\n                                    case PGNTokenTypes.PIECE_CAPTURE :\r\n                                        {\r\n                                            break;\r\n                                        }\r\n                                    default :\r\n                                        {\r\n                                            throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                        }\r\n                                }\r\n                            }\r\n                            {\r\n                                switch (LA(1)) {\r\n                                    case PGNTokenTypes.PIECE_MOVE :\r\n                                        {\r\n                                            match(PGNTokenTypes.PIECE_MOVE);\r\n                                            plyFragment.setCapture(false);\r\n                                            break;\r\n                                        }\r\n                                    case PGNTokenTypes.PIECE_CAPTURE :\r\n                                        {\r\n                                            match(PGNTokenTypes.PIECE_CAPTURE);\r\n                                            plyFragment.setCapture(true);\r\n                                            break;\r\n                                        }\r\n                                    default :\r\n                                        {\r\n                                            throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                        }\r\n                                }\r\n                            }\r\n                            snDest = LT(1);\r\n                            match(PGNTokenTypes.SQUARE_NAME);\r\n                            plyFragment.setDestination(snDest.getText());\r\n                        }\r\n                        {\r\n                            switch (LA(1)) {\r\n                                case PGNTokenTypes.PAWN_PROMOTION :\r\n                                    {\r\n                                        match(PGNTokenTypes.PAWN_PROMOTION);\r\n                                        lc2 = LT(1);\r\n                                        match(PGNTokenTypes.FIGURINE_LETTER_CODE);\r\n                                        if (!((!(\"P\".equals(lc2.getText()))) && (!(\"K\".equals(lc2.getText())))))\r\n                                            throw new SemanticException(\" ! \"P\".equals( lc2.getText()) && ! \"K\".equals( lc2.getText())\");\r\n\r\n                                        plyFragment.setPawnPromotion(lc2.getText().charAt(0));\r\n                                        break;\r\n                                    }\r\n                                case PGNTokenTypes.GAME_TERMINATOR :\r\n                                case PGNTokenTypes.MOVE_INDEX :\r\n                                case PGNTokenTypes.FIGURINE_LETTER_CODE :\r\n                                case PGNTokenTypes.SQUARE_NAME :\r\n                                case PGNTokenTypes.PIECE_MOVE :\r\n                                case PGNTokenTypes.PIECE_CAPTURE :\r\n                                case PGNTokenTypes.LEFT_CASTLING :\r\n                                case PGNTokenTypes.RIGHT_CASTLING :\r\n                                case PGNTokenTypes.WS :\r\n                                    {\r\n                                        break;\r\n                                    }\r\n                                default :\r\n                                    {\r\n                                        throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                    }\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.LEFT_CASTLING :\r\n                {\r\n                    match(PGNTokenTypes.LEFT_CASTLING);\r\n                    plyFragment.setCastling(true);\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.RIGHT_CASTLING :\r\n                {\r\n                    match(PGNTokenTypes.RIGHT_CASTLING);\r\n                    plyFragment.setCastling(false);\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                }\r\n        }\r\n    }\r\n    // When we have all the info from the PGN file, we can try to\r\n    // create a ply notation from it.\r\n    notation = getGameLoader().completePly(plyFragment);\r\n    if (!(notation != null))\r\n        throw new SemanticException(\"notation != null\");\r\n\r\n    return notation;\r\n}"},
 {"id":623, "parametername":"return _destination", "parametertype":"de.java_chess.javaChess.pgn.PGNPlyFragment", "parameterclass":65, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":518, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.getDestination()", "isreturn":1, "sourcecode":"/**\r\n * Get the current destination of this ply.\r\n *\r\n * @return The currently known destination of this ply.\r\n */\r\npublic final Position getDestination() {\r\n    return _destination;\r\n}"},
 {"id":624, "parametername":"return _newPieceType", "parametertype":"de.java_chess.javaChess.pgn.PGNPlyFragment", "parameterclass":65, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":519, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.getNewPieceType()", "isreturn":1, "sourcecode":"/**\r\n * Get the new piece type after the pawn promotion.\r\n *\r\n * @return The new piece type after the pawn promotion.\r\n */\r\npublic final byte getNewPieceType() {\r\n    return _newPieceType;\r\n}"},
 {"id":625, "parametername":"return _origin", "parametertype":"de.java_chess.javaChess.pgn.PGNPlyFragment", "parameterclass":65, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":520, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.getOrigin()", "isreturn":1, "sourcecode":"/**\r\n * Get the current origin of this ply.\r\n *\r\n * @return The currently known origin of this ply.\r\n */\r\npublic final Position getOrigin() {\r\n    return _origin;\r\n}"},
 {"id":626, "parametername":"return _pieceType", "parametertype":"de.java_chess.javaChess.pgn.PGNPlyFragment", "parameterclass":65, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":521, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceType()", "isreturn":1, "sourcecode":"/**\r\n * Get the type of the moved piece.\r\n *\r\n * @return The type of the moved piece.\r\n */\r\npublic final byte getPieceType() {\r\n    return _pieceType;\r\n}"},
 {"id":627, "parametername":"return Piece.PAWN", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":522, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)", "isreturn":1, "sourcecode":"/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * \t\tThe figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}"},
 {"id":628, "parametername":"return Piece.KNIGHT", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":522, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)", "isreturn":1, "sourcecode":"/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * \t\tThe figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}"},
 {"id":629, "parametername":"return Piece.BISHOP", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":522, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)", "isreturn":1, "sourcecode":"/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * \t\tThe figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}"},
 {"id":630, "parametername":"return Piece.ROOK", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":522, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)", "isreturn":1, "sourcecode":"/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * \t\tThe figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}"},
 {"id":631, "parametername":"return Piece.QUEEN", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":522, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)", "isreturn":1, "sourcecode":"/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * \t\tThe figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}"},
 {"id":632, "parametername":"return Piece.KING", "parametertype":"de.java_chess.javaChess.piece.Piece", "parameterclass":67, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":522, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)", "isreturn":1, "sourcecode":"/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * \t\tThe figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}"},
 {"id":633, "parametername":"return ((byte) (-1))", "parametertype":"int", "parameterclass":0, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":522, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)", "isreturn":1, "sourcecode":"/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * \t\tThe figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}"},
 {"id":634, "parametername":"return _capture", "parametertype":"de.java_chess.javaChess.pgn.PGNPlyFragment", "parameterclass":65, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":523, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.isCapture()", "isreturn":1, "sourcecode":"/**\r\n * Check, if this ply fragment is a capture.\r\n *\r\n * @return true, if this move is a capture.\r\n */\r\npublic final boolean isCapture() {\r\n    return _capture;\r\n}"},
 {"id":635, "parametername":"return _castling", "parametertype":"de.java_chess.javaChess.pgn.PGNPlyFragment", "parameterclass":65, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":524, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.isCastling()", "isreturn":1, "sourcecode":"/**\r\n * Check, if this ply fragment is a castling.\r\n *\r\n * @return true, if this ply fragment represents a castling. False otherwise.\r\n */\r\npublic final boolean isCastling() {\r\n    return _castling;\r\n}"},
 {"id":636, "parametername":"return _leftCastling", "parametertype":"de.java_chess.javaChess.pgn.PGNPlyFragment", "parameterclass":65, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":525, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.isLeftCastling()", "isreturn":1, "sourcecode":"/**\r\n * Check, if this castling goes to the left.\r\n *\r\n * @return true, if this castling goes to the left.\r\n */\r\npublic final boolean isLeftCastling() {\r\n    return _leftCastling;\r\n}"},
 {"id":637, "parametername":"return _pawnPromotion", "parametertype":"de.java_chess.javaChess.pgn.PGNPlyFragment", "parameterclass":65, "classid":65, "classname":"de.java_chess.javaChess.pgn.PGNPlyFragment", "methodid":526, "methodname":"de.java_chess.javaChess.pgn.PGNPlyFragment.isPawnPromotion()", "isreturn":1, "sourcecode":"/**\r\n * Check, if this move is a pawn promotion.\r\n *\r\n * @return true, if this move is a pawn promotion. False otherwise.\r\n */\r\npublic final boolean isPawnPromotion() {\r\n    return _pawnPromotion;\r\n}"},
 {"id":638, "parametername":"return ((byte) ((_typeColor) & ((byte) (1))))", "parametertype":"int", "parameterclass":0, "classid":68, "classname":"de.java_chess.javaChess.piece.PieceImpl", "methodid":543, "methodname":"de.java_chess.javaChess.piece.PieceImpl.getColor()", "isreturn":1, "sourcecode":"/**\r\n * Get the color of this piece.\r\n *\r\n * @return The color of this piece.\r\n */\r\npublic final byte getColor() {\r\n    return ((byte) ((_typeColor) & ((byte) (1))));\r\n}"},
 {"id":639, "parametername":"return ((byte) ((_typeColor) >> 1))", "parametertype":"int", "parameterclass":0, "classid":68, "classname":"de.java_chess.javaChess.piece.PieceImpl", "methodid":544, "methodname":"de.java_chess.javaChess.piece.PieceImpl.getType()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the type of this piece.\r\n *\r\n * @return The type of this piece.\r\n */\r\npublic final byte getType() {\r\n    return ((byte) ((_typeColor) >> 1));\r\n}"},
 {"id":640, "parametername":"return _typeColor", "parametertype":"de.java_chess.javaChess.piece.PieceImpl", "parameterclass":68, "classid":68, "classname":"de.java_chess.javaChess.piece.PieceImpl", "methodid":545, "methodname":"de.java_chess.javaChess.piece.PieceImpl.getTypeAndColor()", "isreturn":1, "sourcecode":"/**\r\n * Get type and color as 1 byte.\r\n *\r\n * @return Type and color and 1 byte.\r\n */\r\npublic final byte getTypeAndColor() {\r\n    return _typeColor;\r\n}"},
 {"id":641, "parametername":"return ((_typeColor) & 1) != 0", "parametertype":"int", "parameterclass":0, "classid":68, "classname":"de.java_chess.javaChess.piece.PieceImpl", "methodid":546, "methodname":"de.java_chess.javaChess.piece.PieceImpl.isWhite()", "isreturn":1, "sourcecode":"/**\r\n * Check, if this piece is white.\r\n *\r\n * @return true, if this piece is white, false if black.\r\n */\r\npublic final boolean isWhite() {\r\n    return ((_typeColor) & 1) != 0;\r\n}"},
 {"id":642, "parametername":"return new AnalyzedPlyImpl(getPly(), getScore())", "parametertype":"de.java_chess.javaChess.ply.AnalyzedPlyImpl", "parameterclass":70, "classid":70, "classname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl", "methodid":555, "methodname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.clone()", "isreturn":1, "sourcecode":"/**\r\n * Clone this ply.\r\n *\r\n * @return A clone of this ply.\r\n */\r\npublic Object clone() {\r\n    return new AnalyzedPlyImpl(getPly(), getScore());\r\n}"},
 {"id":643, "parametername":"return _ply", "parametertype":"de.java_chess.javaChess.ply.AnalyzedPlyImpl", "parameterclass":70, "classid":70, "classname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl", "methodid":556, "methodname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.getPly()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the analyzed ply.\r\n *\r\n * @return The analyzed ply.\r\n */\r\npublic final Ply getPly() {\r\n    return _ply;\r\n}"},
 {"id":644, "parametername":"return _score", "parametertype":"de.java_chess.javaChess.ply.AnalyzedPlyImpl", "parameterclass":70, "classid":70, "classname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl", "methodid":557, "methodname":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.getScore()", "isreturn":1, "sourcecode":"/**\r\n * Get the scrore of this ply.\r\n *\r\n * @return The score of this ply.\r\n */\r\npublic final short getScore() {\r\n    return _score;\r\n}"},
 {"id":645, "parametername":"return _goesLeft", "parametertype":"de.java_chess.javaChess.ply.CastlingPlyImpl", "parameterclass":72, "classid":72, "classname":"de.java_chess.javaChess.ply.CastlingPlyImpl", "methodid":563, "methodname":"de.java_chess.javaChess.ply.CastlingPlyImpl.isLeftCastling()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Check, if this castling goes to the left side of the board.\r\n *\r\n * @return true, if the castling goes to the left side, false otherwise.\r\n */\r\npublic final boolean isLeftCastling() {\r\n    return _goesLeft;\r\n}"},
 {"id":646, "parametername":"return isLeftCastling() ? \"O-O-O\" : \"O-O\"", "parametertype":"String", "parameterclass":0, "classid":72, "classname":"de.java_chess.javaChess.ply.CastlingPlyImpl", "methodid":565, "methodname":"de.java_chess.javaChess.ply.CastlingPlyImpl.toString()", "isreturn":1, "sourcecode":"/**\r\n * Get a string representation of this castling.\r\n *\r\n * @return A string representation of this ply.\r\n */\r\npublic final String toString() {\r\n    return isLeftCastling() ? \"O-O-O\" : \"O-O\";\r\n}"},
 {"id":647, "parametername":"return _attackedPosition", "parametertype":"de.java_chess.javaChess.ply.EnPassantPlyImpl", "parameterclass":74, "classid":74, "classname":"de.java_chess.javaChess.ply.EnPassantPlyImpl", "methodid":569, "methodname":"de.java_chess.javaChess.ply.EnPassantPlyImpl.getAttackedPosition()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the position of the attacked pawn.\r\n *\r\n * @return Get the position of the attacked pawn.\r\n */\r\npublic final Position getAttackedPosition() {\r\n    return _attackedPosition;\r\n}"},
 {"id":648, "parametername":"return (ply.getSource().equals(getSource())) && (ply.getDestination().equals(getDestination()))", "parametertype":"boolean", "parameterclass":0, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":578, "methodname":"de.java_chess.javaChess.ply.PlyImpl.equals(de.java_chess.javaChess.ply.Ply)", "isreturn":1, "sourcecode":"/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * \t\tThe other ply.\r\n * @return true, if the 2 plies are equal.\r\n */\r\npublic final boolean equals(Ply ply) {\r\n    return (ply.getSource().equals(getSource())) && (ply.getDestination().equals(getDestination()));\r\n}"},
 {"id":649, "parametername":"return _destination", "parametertype":"de.java_chess.javaChess.ply.PlyImpl", "parameterclass":76, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":579, "methodname":"de.java_chess.javaChess.ply.PlyImpl.getDestination()", "isreturn":1, "sourcecode":"/**\r\n * Get the destination of the piece.\r\n *\r\n * @return The destination of the piece.\r\n */\r\npublic final Position getDestination() {\r\n    return _destination;\r\n}"},
 {"id":650, "parametername":"return _source", "parametertype":"de.java_chess.javaChess.ply.PlyImpl", "parameterclass":76, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":580, "methodname":"de.java_chess.javaChess.ply.PlyImpl.getSource()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the source of the ply.\r\n *\r\n * @return The source of the piece.\r\n */\r\npublic final Position getSource() {\r\n    return _source;\r\n}"},
 {"id":651, "parametername":"return _capture", "parametertype":"de.java_chess.javaChess.ply.PlyImpl", "parameterclass":76, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":581, "methodname":"de.java_chess.javaChess.ply.PlyImpl.isCapture()", "isreturn":1, "sourcecode":"/**\r\n * Check, if this ply captures another piece.\r\n *\r\n * @return true, if another piece is captured with this ply.\r\n */\r\npublic final boolean isCapture() {\r\n    return _capture;\r\n}"},
 {"id":652, "parametername":"return ((getSource().toSquareName()) + \"-\") + (getDestination().toSquareName())", "parametertype":"de.java_chess.javaChess.position.Position", "parameterclass":80, "classid":76, "classname":"de.java_chess.javaChess.ply.PlyImpl", "methodid":585, "methodname":"de.java_chess.javaChess.ply.PlyImpl.toString()", "isreturn":1, "sourcecode":"/**\r\n * Convert the ply into something human readable. Its not exactly chess\r\n * notation, since we dont have a board to check, if it is a move or\r\n * a attack.\r\n *\r\n * @return The ply as a string.\r\n */\r\npublic String toString() {\r\n    return ((getSource().toSquareName()) + \"-\") + (getDestination().toSquareName());\r\n}"},
 {"id":653, "parametername":"return _newPieceType", "parametertype":"de.java_chess.javaChess.ply.TransformationPlyImpl", "parameterclass":78, "classid":78, "classname":"de.java_chess.javaChess.ply.TransformationPlyImpl", "methodid":589, "methodname":"de.java_chess.javaChess.ply.TransformationPlyImpl.getTypeAfterTransformation()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the new type of the piece after the transformation.\r\n *\r\n * @return The new piece after the transformation.\r\n */\r\npublic final byte getTypeAfterTransformation() {\r\n    return _newPieceType;\r\n}"},
 {"id":654, "parametername":"return (pos.getSquareIndex()) == (getSquareIndex())", "parametertype":"boolean", "parameterclass":0, "classid":81, "classname":"de.java_chess.javaChess.position.PositionImpl", "methodid":600, "methodname":"de.java_chess.javaChess.position.PositionImpl.equals(de.java_chess.javaChess.position.Position)", "isreturn":1, "sourcecode":"/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * \t\tposition.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\npublic final boolean equals(Position pos) {\r\n    return (pos.getSquareIndex()) == (getSquareIndex());\r\n}"},
 {"id":655, "parametername":"return (_squareIndex) & 7", "parametertype":"int", "parameterclass":0, "classid":81, "classname":"de.java_chess.javaChess.position.PositionImpl", "methodid":601, "methodname":"de.java_chess.javaChess.position.PositionImpl.getLineIndex()", "isreturn":1, "sourcecode":"/**\r\n * Get the line index of this postion (0-7).\r\n *\r\n * @return The line index of this position.\r\n */\r\npublic final int getLineIndex() {\r\n    return (_squareIndex) & 7;\r\n}"},
 {"id":656, "parametername":"return (_squareIndex) >> 3", "parametertype":"int", "parameterclass":0, "classid":81, "classname":"de.java_chess.javaChess.position.PositionImpl", "methodid":602, "methodname":"de.java_chess.javaChess.position.PositionImpl.getRowIndex()", "isreturn":1, "sourcecode":"/**\r\n * Get the row index of this position (0-7).\r\n *\r\n * @return The row index of this position.\r\n */\r\npublic final int getRowIndex() {\r\n    return (_squareIndex) >> 3;\r\n}"},
 {"id":657, "parametername":"return _squareIndex", "parametertype":"de.java_chess.javaChess.position.PositionImpl", "parameterclass":81, "classid":81, "classname":"de.java_chess.javaChess.position.PositionImpl", "methodid":603, "methodname":"de.java_chess.javaChess.position.PositionImpl.getSquareIndex()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the square index of this position (0-63).\r\n *\r\n * @return The square index of this position.\r\n */\r\npublic final int getSquareIndex() {\r\n    return _squareIndex;\r\n}"},
 {"id":658, "parametername":"return new String(byteRepresentation)", "parametertype":"byte", "parameterclass":0, "classid":81, "classname":"de.java_chess.javaChess.position.PositionImpl", "methodid":605, "methodname":"de.java_chess.javaChess.position.PositionImpl.toSquareName()", "isreturn":1, "sourcecode":"/**\r\n * Convert this position to a square name (like a4).\r\n *\r\n * @return The suare name of this position.\r\n */\r\npublic final String toSquareName() {\r\n    byte[] byteRepresentation = new byte[2];\r\n    byteRepresentation[0] = ((byte) (((int) (a)) + (getLineIndex())));\r\n    byteRepresentation[1] = ((byte) (((int) (1)) + (getRowIndex())));\r\n    return new String(byteRepresentation);\r\n}"},
 {"id":659, "parametername":"return _piecesLayer", "parametertype":"de.java_chess.javaChess.renderer2d.AnimationLayer", "parameterclass":83, "classid":83, "classname":"de.java_chess.javaChess.renderer2d.AnimationLayer", "methodid":613, "methodname":"de.java_chess.javaChess.renderer2d.AnimationLayer.getPiecesLayer()", "isreturn":1, "sourcecode":"/**\r\n * Paint the animated piece.\r\n *\r\n * @param g\r\n * \t\tThe graphics context.\r\n */\r\n/* public void paint( Graphics g) {\nSystem.out.println( \"Repaint piece at \" + _currentPoint.x + \",\" + _currentPoint.y);\n// g.drawImage( _piece, _currentPoint.x, _currentPoint.y, this);\n}\n */\r\n/**\r\n * Get the current pieces layer.\r\n *\r\n * @return The current pieces layer.\r\n */\r\nPiecesLayer getPiecesLayer() {\r\n    return _piecesLayer;\r\n}"},
 {"id":660, "parametername":"return _boardSize", "parametertype":"de.java_chess.javaChess.renderer2d.BoardLayer", "parameterclass":84, "classid":84, "classname":"de.java_chess.javaChess.renderer2d.BoardLayer", "methodid":618, "methodname":"de.java_chess.javaChess.renderer2d.BoardLayer.getBoardSize()", "isreturn":1, "sourcecode":"/**\r\n * Get the board size.\r\n *\r\n * @return The board size.\r\n */\r\nfinal int getBoardSize() {\r\n    return _boardSize;\r\n}"},
 {"id":661, "parametername":"return getMinimumSize()", "parametertype":"de.java_chess.javaChess.renderer2d.BoardLayer", "parameterclass":84, "classid":84, "classname":"de.java_chess.javaChess.renderer2d.BoardLayer", "methodid":619, "methodname":"de.java_chess.javaChess.renderer2d.BoardLayer.getMaximumSize()", "isreturn":1, "sourcecode":"/**\r\n * Get the maximum size of the board.\r\n *\r\n * @return The maximum size of the board.\r\n */\r\npublic final Dimension getMaximumSize() {\r\n    return getMinimumSize();\r\n}"},
 {"id":662, "parametername":"return new Dimension(getBoardSize(), getBoardSize())", "parametertype":"de.java_chess.javaChess.renderer2d.BoardLayer", "parameterclass":84, "classid":84, "classname":"de.java_chess.javaChess.renderer2d.BoardLayer", "methodid":620, "methodname":"de.java_chess.javaChess.renderer2d.BoardLayer.getMinimumSize()", "isreturn":1, "sourcecode":"/**\r\n * Get the minimum size of the board.\r\n *\r\n * @return The minimum size of the board.\r\n */\r\npublic final Dimension getMinimumSize() {\r\n    return new Dimension(getBoardSize(), getBoardSize());\r\n}"},
 {"id":663, "parametername":"return getMinimumSize()", "parametertype":"de.java_chess.javaChess.renderer2d.BoardLayer", "parameterclass":84, "classid":84, "classname":"de.java_chess.javaChess.renderer2d.BoardLayer", "methodid":621, "methodname":"de.java_chess.javaChess.renderer2d.BoardLayer.getPreferredSize()", "isreturn":1, "sourcecode":"/**\r\n * Get the preferred size of the board.\r\n *\r\n * @return The preferred size of the board.\r\n */\r\npublic final Dimension getPreferredSize() {\r\n    return getMinimumSize();\r\n}"},
 {"id":664, "parametername":"return _squareSize", "parametertype":"de.java_chess.javaChess.renderer2d.BoardLayer", "parameterclass":84, "classid":84, "classname":"de.java_chess.javaChess.renderer2d.BoardLayer", "methodid":622, "methodname":"de.java_chess.javaChess.renderer2d.BoardLayer.getSquareSize()", "isreturn":1, "sourcecode":"/**\r\n * Get the square size.\r\n *\r\n * @return The square size.\r\n */\r\nfinal int getSquareSize() {\r\n    return _squareSize;\r\n}"},
 {"id":665, "parametername":"return _board", "parametertype":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "parameterclass":85, "classid":85, "classname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "methodid":627, "methodname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getBoard()", "isreturn":1, "sourcecode":"/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\npublic final Board getBoard() {\r\n    return _board;\r\n}"},
 {"id":666, "parametername":"return getMinimumSize()", "parametertype":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "parameterclass":85, "classid":85, "classname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "methodid":628, "methodname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getMaximumSize()", "isreturn":1, "sourcecode":"/**\r\n * Get the maximum size of the board.\r\n *\r\n * @return The maximum size of the board.\r\n */\r\npublic final Dimension getMaximumSize() {\r\n    return getMinimumSize();\r\n}"},
 {"id":667, "parametername":"return new Dimension(((8 * (ChessBoardRenderer2D.getSquareSize())) + ((ChessBoardRenderer2D.getSquareSize()) / 2)), ((8 * (ChessBoardRenderer2D.getSquareSize())) + ((ChessBoardRenderer2D.getSquareSize()) / 2)))", "parametertype":"int", "parameterclass":0, "classid":85, "classname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "methodid":629, "methodname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getMinimumSize()", "isreturn":1, "sourcecode":"/**\r\n * Get the minimum size of the board.\r\n *\r\n * @return The minimum size of the board.\r\n */\r\npublic final Dimension getMinimumSize() {\r\n    return new Dimension(((8 * (ChessBoardRenderer2D.getSquareSize())) + ((ChessBoardRenderer2D.getSquareSize()) / 2)), ((8 * (ChessBoardRenderer2D.getSquareSize())) + ((ChessBoardRenderer2D.getSquareSize()) / 2)));\r\n}"},
 {"id":668, "parametername":"return getMinimumSize()", "parametertype":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "parameterclass":85, "classid":85, "classname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "methodid":630, "methodname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getPreferredSize()", "isreturn":1, "sourcecode":"/**\r\n * Get the preferred size of the board.\r\n *\r\n * @return The preferred size of the board.\r\n */\r\npublic final Dimension getPreferredSize() {\r\n    return getMinimumSize();\r\n}"},
 {"id":669, "parametername":"return ChessBoardRenderer2D._squareSize", "parametertype":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "parameterclass":85, "classid":85, "classname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D", "methodid":631, "methodname":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getSquareSize()", "isreturn":1, "sourcecode":"/**\r\n * Get the size of a square.\r\n *\r\n * @return The size of a square as a int (since height and width are the same).\r\n */\r\npublic static final int getSquareSize() {\r\n    return ChessBoardRenderer2D._squareSize;\r\n}"},
 {"id":670, "parametername":"return _controller", "parametertype":"de.java_chess.javaChess.renderer2d.ControlLayer", "parameterclass":87, "classid":87, "classname":"de.java_chess.javaChess.renderer2d.ControlLayer", "methodid":638, "methodname":"de.java_chess.javaChess.renderer2d.ControlLayer.getController()", "isreturn":1, "sourcecode":"/**\r\n * Get the game controller.\r\n *\r\n * @return The game controller.\r\n */\r\nprivate final GameController getController() {\r\n    return _controller;\r\n}"},
 {"id":671, "parametername":"return ((int) ((_time) / 1000L))", "parametertype":"int", "parameterclass":0, "classid":88, "classname":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel", "methodid":646, "methodname":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.getRemainingTime()", "isreturn":1, "sourcecode":"/**\r\n * Get the remaining time in seconds.\r\n *\r\n * @return The remaining time in seconds.\r\n */\r\npublic int getRemainingTime() {\r\n    return ((int) ((_time) / 1000L));\r\n}"},
 {"id":672, "parametername":"return this.jtEngine.getText()", "parametertype":"de.java_chess.javaChess.renderer2d.EnginePanel", "parameterclass":89, "classid":89, "classname":"de.java_chess.javaChess.renderer2d.EnginePanel", "methodid":653, "methodname":"de.java_chess.javaChess.renderer2d.EnginePanel.getText()", "isreturn":1, "sourcecode":"/**\r\n * Get the current text of the panel.\r\n *\r\n * @return The current text of the panel.\r\n */\r\npublic final String getText() {\r\n    return this.jtEngine.getText();\r\n}"},
 {"id":673, "parametername":"return _running", "parametertype":"de.java_chess.javaChess.renderer2d.GameTimerPanel", "parameterclass":90, "classid":90, "classname":"de.java_chess.javaChess.renderer2d.GameTimerPanel", "methodid":661, "methodname":"de.java_chess.javaChess.renderer2d.GameTimerPanel.isRunning()", "isreturn":1, "sourcecode":"/**\r\n * Get the active state of this timer.\r\n *\r\n * @return The active state of this timer.\r\n */\r\npublic boolean isRunning() {\r\n    return _running;\r\n}"},
 {"id":674, "parametername":"return this.jbBlack.getText()", "parametertype":"de.java_chess.javaChess.renderer2d.NotationPanel", "parameterclass":92, "classid":92, "classname":"de.java_chess.javaChess.renderer2d.NotationPanel", "methodid":682, "methodname":"de.java_chess.javaChess.renderer2d.NotationPanel.getBlackPlayerName()", "isreturn":1, "sourcecode":"/**\r\n * Returns the black players name\r\n *\r\n * @return The String for the black player\r\n */\r\npublic String getBlackPlayerName() {\r\n    return this.jbBlack.getText();\r\n}"},
 {"id":675, "parametername":"return this.jbWhite.getText()", "parametertype":"de.java_chess.javaChess.renderer2d.NotationPanel", "parameterclass":92, "classid":92, "classname":"de.java_chess.javaChess.renderer2d.NotationPanel", "methodid":683, "methodname":"de.java_chess.javaChess.renderer2d.NotationPanel.getWhitePlayerName()", "isreturn":1, "sourcecode":"/**\r\n * Returns the white players name\r\n *\r\n * @return The String for the white player\r\n */\r\npublic String getWhitePlayerName() {\r\n    return this.jbWhite.getText();\r\n}"},
 {"id":676, "parametername":"return _animationLayer", "parametertype":"de.java_chess.javaChess.renderer2d.PiecesLayer", "parameterclass":94, "classid":94, "classname":"de.java_chess.javaChess.renderer2d.PiecesLayer", "methodid":694, "methodname":"de.java_chess.javaChess.renderer2d.PiecesLayer.getAnimationLayer()", "isreturn":1, "sourcecode":"/**\r\n * Get the current animation layer.\r\n *\r\n * @return The current animation layer.\r\n */\r\nfinal AnimationLayer getAnimationLayer() {\r\n    return _animationLayer;\r\n}"},
 {"id":677, "parametername":"return _square[squareIndex]", "parametertype":"int", "parameterclass":0, "classid":94, "classname":"de.java_chess.javaChess.renderer2d.PiecesLayer", "methodid":695, "methodname":"de.java_chess.javaChess.renderer2d.PiecesLayer.getPositionRenderer(int)", "isreturn":1, "sourcecode":"/**\r\n * Get the position renderer for a given square.\r\n *\r\n * @param squareIndex\r\n * \t\tThe index of the square.\r\n * @return The position renderer for the given square.\r\n */\r\nfinal PositionRenderer getPositionRenderer(int squareIndex) {\r\n    return _square[squareIndex];\r\n}"},
 {"id":678, "parametername":"return ((int) ((_time) / 1000L))", "parametertype":"int", "parameterclass":0, "classid":97, "classname":"de.java_chess.javaChess.renderer2d.TimerPanel", "methodid":711, "methodname":"de.java_chess.javaChess.renderer2d.TimerPanel.getRemainingTime()", "isreturn":1, "sourcecode":"/**\r\n * Get the remaining time in seconds.\r\n *\r\n * @return The remaining time in seconds.\r\n */\r\npublic int getRemainingTime() {\r\n    return ((int) ((_time) / 1000L));\r\n}"},
 {"id":679, "parametername":"return _countdown", "parametertype":"de.java_chess.javaChess.renderer2d.TimerPanel", "parameterclass":97, "classid":97, "classname":"de.java_chess.javaChess.renderer2d.TimerPanel", "methodid":712, "methodname":"de.java_chess.javaChess.renderer2d.TimerPanel.isCountdown()", "isreturn":1, "sourcecode":"/**\r\n * Check, if this timer counts downwards.\r\n *\r\n * @return true, if the counter counts downwards.\r\n */\r\nprivate final boolean isCountdown() {\r\n    return _countdown;\r\n}"},
 {"id":680, "parametername":"return suite", "parametertype":"junit.framework.TestSuite", "parameterclass":0, "classid":98, "classname":"de.java_chess.javaChess.test.JavaChessTest", "methodid":720, "methodname":"de.java_chess.javaChess.test.JavaChessTest.suite()", "isreturn":1, "sourcecode":"// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Create the main test suite.\r\n *\r\n * @return The main test suite.\r\n */\r\npublic static Test suite() {\r\n    // Create a new test suite.\r\n    TestSuite suite = new TestSuite();\r\n    // Add the test suite for the engine.\r\n    suite.addTest(ChessEngineTest.suite());\r\n    return suite;\r\n}"},
 {"id":681, "parametername":"return (_curElement) < (_nItems)", "parametertype":"boolean", "parameterclass":0, "classid":100, "classname":"de.java_chess.javaChess.util.ArrayStackIterator", "methodid":727, "methodname":"de.java_chess.javaChess.util.ArrayStackIterator.hasNext()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Check, if there are more elements to iterate over.\r\n *\r\n * @return true, if there are more elements.\r\n */\r\npublic final boolean hasNext() {\r\n    return (_curElement) < (_nItems);\r\n}"},
 {"id":682, "parametername":"return _items[((_curElement)++)]", "parametertype":"int", "parameterclass":0, "classid":100, "classname":"de.java_chess.javaChess.util.ArrayStackIterator", "methodid":728, "methodname":"de.java_chess.javaChess.util.ArrayStackIterator.next()", "isreturn":1, "sourcecode":"/**\r\n * Get the next elements from the collection.\r\n *\r\n * @return The next element from the collection.\r\n */\r\npublic final Object next() {\r\n    return _items[((_curElement)++)];\r\n}"},
 {"id":683, "parametername":"return ResourceLoader._instance", "parametertype":"de.java_chess.javaChess.util.ResourceLoader", "parameterclass":101, "classid":101, "classname":"de.java_chess.javaChess.util.ResourceLoader", "methodid":732, "methodname":"de.java_chess.javaChess.util.ResourceLoader.getInstance()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Get the only instance of this class.\r\n *\r\n * @return The only instance of this class.\r\n */\r\npublic static final ResourceLoader getInstance() {\r\n    if ((ResourceLoader._instance) == null) {\r\n        ResourceLoader._instance = new ResourceLoader();\r\n    }\r\n    return ResourceLoader._instance;\r\n}"},
 {"id":684, "parametername":"return result", "parametertype":"java.awt.Image", "parameterclass":0, "classid":101, "classname":"de.java_chess.javaChess.util.ResourceLoader", "methodid":733, "methodname":"de.java_chess.javaChess.util.ResourceLoader.loadImage(java.lang.String)", "isreturn":1, "sourcecode":"/**\r\n * Load an image resource.\r\n *\r\n * @return The image resource, if it was found or null otherwise.\r\n */\r\npublic final Image loadImage(String imageName) {\r\n    Image result = null;\r\n    for (Iterator iter = _locations.iterator(); iter.hasNext();) {\r\n        try {\r\n            result = Toolkit.getDefaultToolkit().getImage(new URL(((iter.next()) + imageName)));\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        } catch (MalformedURLException ignored) {\r\n        }\r\n    }\r\n    return null;// Image not found.\r\n\r\n}"},
 {"id":685, "parametername":"return null// Image not found.\r\n", "parametertype":"<nulltype>", "parameterclass":0, "classid":101, "classname":"de.java_chess.javaChess.util.ResourceLoader", "methodid":733, "methodname":"de.java_chess.javaChess.util.ResourceLoader.loadImage(java.lang.String)", "isreturn":1, "sourcecode":"/**\r\n * Load an image resource.\r\n *\r\n * @return The image resource, if it was found or null otherwise.\r\n */\r\npublic final Image loadImage(String imageName) {\r\n    Image result = null;\r\n    for (Iterator iter = _locations.iterator(); iter.hasNext();) {\r\n        try {\r\n            result = Toolkit.getDefaultToolkit().getImage(new URL(((iter.next()) + imageName)));\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        } catch (MalformedURLException ignored) {\r\n        }\r\n    }\r\n    return null;// Image not found.\r\n\r\n}"},
 {"id":686, "parametername":"// only character count\r\nreturn ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)", "parametertype":"int", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":735, "methodname":"de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)", "isreturn":1, "sourcecode":"/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * \t\tThe string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}"},
 {"id":687, "parametername":"// numbers only\r\nreturn (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s))", "parametertype":"int", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":735, "methodname":"de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)", "isreturn":1, "sourcecode":"/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * \t\tThe string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}"},
 {"id":688, "parametername":"// a3-d3 and a6-d6 are valid squares for en passant\r\nreturn this.isValidSquare(s, true)", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":735, "methodname":"de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)", "isreturn":1, "sourcecode":"/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * \t\tThe string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}"},
 {"id":689, "parametername":"// between a1 and h8\r\nreturn this.isValidSquare(s, false)", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":735, "methodname":"de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)", "isreturn":1, "sourcecode":"/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * \t\tThe string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}"},
 {"id":690, "parametername":"return false", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":735, "methodname":"de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)", "isreturn":1, "sourcecode":"/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * \t\tThe string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}"},
 {"id":691, "parametername":"return true", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":737, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValid(java.lang.String)", "isreturn":1, "sourcecode":"/**\r\n * Parse the string for number with value > 0\r\n *\r\n * @param sNewString\r\n * \t\tThe string to parse\r\n * @return <code>true</code> when the given string is a number with value > 0\r\n */\r\nprivate boolean isValid(String sNewString) {\r\n    try {\r\n        int iVal = Integer.parseInt(sNewString);\r\n        if (iVal > 0)\r\n            return true;\r\n\r\n        return false;\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}"},
 {"id":692, "parametername":"return false", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":737, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValid(java.lang.String)", "isreturn":1, "sourcecode":"/**\r\n * Parse the string for number with value > 0\r\n *\r\n * @param sNewString\r\n * \t\tThe string to parse\r\n * @return <code>true</code> when the given string is a number with value > 0\r\n */\r\nprivate boolean isValid(String sNewString) {\r\n    try {\r\n        int iVal = Integer.parseInt(sNewString);\r\n        if (iVal > 0)\r\n            return true;\r\n\r\n        return false;\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}"},
 {"id":693, "parametername":"return false", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":737, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValid(java.lang.String)", "isreturn":1, "sourcecode":"/**\r\n * Parse the string for number with value > 0\r\n *\r\n * @param sNewString\r\n * \t\tThe string to parse\r\n * @return <code>true</code> when the given string is a number with value > 0\r\n */\r\nprivate boolean isValid(String sNewString) {\r\n    try {\r\n        int iVal = Integer.parseInt(sNewString);\r\n        if (iVal > 0)\r\n            return true;\r\n\r\n        return false;\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}"},
 {"id":694, "parametername":"return true", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":738, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValidLine(char)", "isreturn":1, "sourcecode":"/**\r\n * Checks the character for being between a and h which limit the chessboard lines\r\n *\r\n * @param charToCheck\r\n * \t\tThe character to check\r\n * @return <code>true</code> when between a and h\r\n */\r\nprivate boolean isValidLine(char charToCheck) {\r\n    if (((charToCheck >= a) && (charToCheck <= h)) || ((charToCheck >= A) && (charToCheck <= H))) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"},
 {"id":695, "parametername":"return false", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":738, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValidLine(char)", "isreturn":1, "sourcecode":"/**\r\n * Checks the character for being between a and h which limit the chessboard lines\r\n *\r\n * @param charToCheck\r\n * \t\tThe character to check\r\n * @return <code>true</code> when between a and h\r\n */\r\nprivate boolean isValidLine(char charToCheck) {\r\n    if (((charToCheck >= a) && (charToCheck <= h)) || ((charToCheck >= A) && (charToCheck <= H))) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"},
 {"id":696, "parametername":"return true", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":739, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * \t\tThe string to parse\r\n * @param bEnPassantSquare\r\n * \t\tFlag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"},
 {"id":697, "parametername":"return true", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":739, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * \t\tThe string to parse\r\n * @param bEnPassantSquare\r\n * \t\tFlag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"},
 {"id":698, "parametername":"return false", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":739, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * \t\tThe string to parse\r\n * @param bEnPassantSquare\r\n * \t\tFlag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"},
 {"id":699, "parametername":"return true", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":739, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * \t\tThe string to parse\r\n * @param bEnPassantSquare\r\n * \t\tFlag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"},
 {"id":700, "parametername":"return false", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":739, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * \t\tThe string to parse\r\n * @param bEnPassantSquare\r\n * \t\tFlag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"},
 {"id":701, "parametername":"return false", "parametertype":"boolean", "parameterclass":0, "classid":102, "classname":"de.java_chess.javaChess.util.StringTextDocument", "methodid":739, "methodname":"de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)", "isreturn":1, "sourcecode":"/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * \t\tThe string to parse\r\n * @param bEnPassantSquare\r\n * \t\tFlag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"},
 {"id":702, "parametername":"return (_nItems) == 0", "parametertype":"int", "parameterclass":0, "classid":104, "classname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack", "methodid":745, "methodname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.empty()", "isreturn":1, "sourcecode":"// Methods\r\n/**\r\n * Test, if this stack is empty.\r\n *\r\n * @return true, if the stack is empty. False otherwise.\r\n */\r\npublic final boolean empty() {\r\n    return (_nItems) == 0;\r\n}"},
 {"id":703, "parametername":"return new ArrayStackIterator(_items, _nItems)", "parametertype":"de.java_chess.javaChess.util.UnsynchronizedArrayStack", "parameterclass":104, "classid":104, "classname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack", "methodid":747, "methodname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.iterator()", "isreturn":1, "sourcecode":"/**\r\n * Get a iterator for the elements of this stack.\r\n *\r\n * @return A iterator for the elements of this stack.\r\n */\r\npublic final Iterator iterator() {\r\n    return new ArrayStackIterator(_items, _nItems);\r\n}"},
 {"id":704, "parametername":"return empty() ? null : _items[((_nItems) - 1)]", "parametertype":"int", "parameterclass":0, "classid":104, "classname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack", "methodid":748, "methodname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.peek()", "isreturn":1, "sourcecode":"/**\r\n * Look at the object, that is at the top of the stack without removing it.\r\n *\r\n * @return The object at the top of the stack.\r\n */\r\npublic final Object peek() {\r\n    return empty() ? null : _items[((_nItems) - 1)];\r\n}"},
 {"id":705, "parametername":"return item", "parametertype":"Object", "parameterclass":0, "classid":104, "classname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack", "methodid":749, "methodname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.pop()", "isreturn":1, "sourcecode":"/**\r\n * Remove the object at the top of the stack and return it.\r\n *\r\n * @return The object at the top of the stack.\r\n */\r\npublic final Object pop() {\r\n    if (!(empty())) {\r\n        Object item = _items[(--(_nItems))];\r\n        _items[_nItems] = null;\r\n        return item;\r\n    }\r\n    return null;\r\n}"},
 {"id":706, "parametername":"return null", "parametertype":"<nulltype>", "parameterclass":0, "classid":104, "classname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack", "methodid":749, "methodname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.pop()", "isreturn":1, "sourcecode":"/**\r\n * Remove the object at the top of the stack and return it.\r\n *\r\n * @return The object at the top of the stack.\r\n */\r\npublic final Object pop() {\r\n    if (!(empty())) {\r\n        Object item = _items[(--(_nItems))];\r\n        _items[_nItems] = null;\r\n        return item;\r\n    }\r\n    return null;\r\n}"},
 {"id":707, "parametername":"return i", "parametertype":"int", "parameterclass":0, "classid":104, "classname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack", "methodid":751, "methodname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.search(java.lang.Object)", "isreturn":1, "sourcecode":"/**\r\n * Return the position of a object on the stack, or -1 if it\r\n * is not found.\r\n *\r\n * @return The position of the object on the stack.\r\n */\r\npublic final int search(Object o) {\r\n    for (int i = 0; i < (_nItems); i++) {\r\n        if (_items[i].equals(o)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"},
 {"id":708, "parametername":"return -1", "parametertype":"int", "parameterclass":0, "classid":104, "classname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack", "methodid":751, "methodname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.search(java.lang.Object)", "isreturn":1, "sourcecode":"/**\r\n * Return the position of a object on the stack, or -1 if it\r\n * is not found.\r\n *\r\n * @return The position of the object on the stack.\r\n */\r\npublic final int search(Object o) {\r\n    for (int i = 0; i < (_nItems); i++) {\r\n        if (_items[i].equals(o)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"},
 {"id":709, "parametername":"return _nItems", "parametertype":"de.java_chess.javaChess.util.UnsynchronizedArrayStack", "parameterclass":104, "classid":104, "classname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack", "methodid":752, "methodname":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.size()", "isreturn":1, "sourcecode":"/**\r\n * Get the current number of elements on the stack.\r\n *\r\n * @param The\r\n * \t\tcurrent size of the stack.\r\n */\r\npublic final int size() {\r\n    return _nItems;\r\n}"}]